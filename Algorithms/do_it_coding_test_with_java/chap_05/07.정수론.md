>[!정수론]
>수학에서 정수론은 수의 성질을 탐구하고 공부하는 분야를 뜻합니다. 실제 코딩 테스트에서는 모든 정수론의 분야가 나오지 않고, 영역도 매우 방대하므로 전체를 공부하기에는 효율성이 떨어집니다.
>정수론 영역에서 가장 많이 등장하는 소수 부분과 호제법 부분을 집중적으로 다루겠습니다.

### 1. 소수 구하기
- 소수(prime number)는 자신보다 작은 2개의 자연수를 곱해 만들 수 없는 1보다 큰 자연수를 말합니다.
##### 소수 구하기의 핵심 이론
- 에라토스테네스의 체 원리
	1. 구하고자 하는 소수의 범위만큼 1차원 배열을 생성한다.
	2. 2부터 시작하고 현재 숫자가 지워지지 않을 때는 현재 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하며 지운다. 이때 처음으로 선택된 숫자는 지우지 않는다.
	3. 배열의 끝까지 2.를 반복한 후 배열에서 남아 있는 모든 수를 출력한다.
>[!에라토스테네스의 체를 사용할 때 시간 복잡도는?]
>일반적으로 에라토스테네스의 체를 구현하려면 이중 for문을 이용하므로 시간 복잡도가 O(N^2) 정도라고 판단할 수 있다. 하지만 실제 시간 복잡도는 최적화의 정도에 따라 다르겠지만, 일반적으로 O(Nlog(logN))이다. 이유는 배수를 삭제하는 연산으로 실제 구현에서 바깥쪽 for문을 생략하는 경우가 빈번하게 발생하기 때문이다. 이러한 이유로 에라토스테네스의 체 기법은 현재에도 코딩 테스트에서 소수를 구하는 일반적인 방법으로 통용된다.

##### 문제 037 소수 구하기 (백준 1929)
- 문제 분석
	- 숫자 사이에 소수를 출력하는 문제이다.
	- N의 최대 범위가 1,000,000이므로 일반적인 소수 구하기 방식으로 문제를 풀면 시간 초과가 발생한다.
	- 에라토스테네스 방법으로 문제를 풀이한다.
- 손으로 풀어보기
	- 크기가 N+1인 배열을 선언한 후 값은 인덱스 값으로 채운다.
	- 1은 소수가 아니므로 삭제한다.
	- 2부터 N의 제곱근까지 값을 탐색한다. 값이 인덱스값이면 그대로 두고, 그 값의 배수를 탐색해 0으로 변경한다.
	- 배열에 남아 있는 수 중 M 이상 N 이하의 수를 모두 출력한다.
>[!N의 제곱근까지만 탐색하는 이유]
>N이 a*b라고 가정했을 때, a와 b 모두 N의 제곱근보다 클 수 없다. 따라서 N의 제곱근까지만 확인해도 전체 범위의 소수를 판별할 수 있다.
- 수도코드 작성하기
- 코드 구현하기

### 2. 오일러 피
- 오일러 피 함수 P[N]의 정의는 1부터 N까지 범위에서 N과 서로소인 자연수의 개수를 뜻한다. 오일러 피 함수는 증명 과정을 공부해야 완벽하게 알 수 있지만 여기서는 실제 코딩 테스트에 사용하기 위한 구현 부분만 알아본다.
##### 오일러 피의 핵심 이론
- 오일러 피 함수의 원리
	1. 구하고자 하는 오일러 피의 범위만큼 배열을 초기화한다.
	2. 2부터 시작해 현재 배열의 값과 인덱스가 같으면(= 소수일 때) 현재 선택된 숫자(K)의 배수에 해당하는 수를 배열에 끝까지 탐색하며 P[i] = P[i] - P[i]/K 연산을 수행한다.(i는 K의 배수)
	3. 배열의 끝까지 2를 반복하며 오일러 피 함수를 완성한다.
- 오일러 피 함수의 원리 이해하기
	1. 구하고자 하는 범위까지 배열을 생성한 후 2를 선택한다.
	2. 2의 모든 배수마다 P[i] = P[i] - P[i] / 2 연산을 수행해 값을 갱신한다. 예를 들어 8 = 8 - (8 / 2)를 통해 4를 계산한다.
	3. 소수 구하기에서 배수를 지우는 부분만 P[i] = P[i] - P[i] / K로 변경하면 오일러 피 함수를 간단하게 구현할 수 있다. 탐색을 계속 진행하면서 N = p(N)인 곳(소수)을 찾아 값을 갱신한다.
	4. 배열이 끝날 때까지 반복한다.
>[!수학적으로 오일러 피 함수 이해하기]
>- 초기 상태: p(6) = 6 -> 서로소가 될 수 있는 후보의 개수로 초기화(1,2,3,4,5,6)
>- 2의 배수로 인한 후보 탈락 -> p(6) = 6 - (6/2) = 3(1,2,3,4,5,6)
>- 3의 배수로 인한 후보 탈락 -> p(3) = 3 - (3/3) = 2(1,2,3,4,5,6)
>이때 후보에서 삭제하는 기준을 6이 아닌 업데이트된 3으로 진행하는 이유는 3의 배수 중 2의 배수인 수들은, 즉 3과 2의 공배수는 2의 배수에서 이미 삭제됐기 때문에 중복 삭제를 막기 위함이다. 
### 3. 유클리드 호제법
- 유클리드 호제법(euclidean-algorithm)은 두 수의 최대 공약수를 구하는 알고리즘이다. 일반적으로 최대 공약수를 구하는 방법은 소인수분해를 이용한 공통된 소수들의 곱으로 표현할 수 있지만 유클리드 호제법은 좀 더 간단한 방법을 제시한다.
##### 유클리드 호제법의 핵심 이론
| 연산  | 기능                  | 예제                         |
| --- | ------------------- | -------------------------- |
| MOD | 두 값을 나눈 나머지를 구하는 연산 | 10 MOD 4 = 2 // 10 % 4 = 2 |
- MOD 연산으로 구현하는 유클리드 호제법
	1. 큰 수를 작은 수로 나누는 MOD 연산을 수행한다.
	2. 앞 단계에서의 작은 수와 MOD 연산 결괏값(나머지)으로 MOD 연산을 수행한다.
	3. 나머지가 0이 되는 순간의 작은 수를 최대 공약수로 선택한다.
