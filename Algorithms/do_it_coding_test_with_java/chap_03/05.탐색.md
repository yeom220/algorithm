>[!탐색]
>탐색은 주어진 데이터에서 자신이 원하는 데이터를 찾아내는 알고리즘을 말합니다.
>주어진 데이터의 성질(정렬, 비정렬)에 따라 적절한 탐색 알고리즘을 선택하는 것이 중요하고, 실제 모든 코딩테스트 문제의 기본이 되는 알고리즘이므로 직접 구현해 원리를 완벽하게 이해하는 것이 중요합니다.

### 1. 깊이 우선 탐색
- 깊이 우선 탐색(DFS)은 그래프 완전 탐색 기법 중 하나이다.
- 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘이다.

| 기능        | 특징                          | 시간 복잡도(V: 노드수, E: 에지 수) |
| --------- | --------------------------- | ----------------------- |
| 그래프 완전 탐색 | - 재귀 함수로 구현<br>- 스택 자료구조 이용 | O(V + E)                |
- 깊이 우선 탐색은 실제 구현 시 재귀 함수를 이용하므로 스택 오버플로에 유의해야 한다.
- DFS를 응용하여 풀 수 있는 문제는 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등이 있다.
##### 깊이 우선 탐색의 핵심 이론
- DFS는 한 번 방문한 노드를 다시 방문하면 안 되므로 노드 방문 여부를 체크할 배열이 필요하며, 그래프는 인접 리스트로 표현한다.
- DFS의 탐색 방식은 후입선출 특성을 가지므로 스택을 사용하여 설명한다.
- DFS 구현은 스택보다는 스택 성질을 갖는 재귀 함수로 많이 구현한다.
1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화하기
2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입하기
3. 스택 자료구조에 값이 없을 때까지 반복하기

##### 문제 023 연결 요소의 개수 구하기 (백준 11724)
- 문제 분석
	- 노드의 최대 개수가 1,000이므로 시간 복잡도 N^2이하의 알고리즘을 모두 사용할 수 있다.
	- 연결 요소는 에지로 연결된 노드의 집합이며, 한 번의 DFS가 끝날 때까지 탐색한 모든 노드의 집합을 하나의 연결 요소로 판단할 수 있다.
- 손으로 풀어보기
- 수도코드 작성하기
```java
n(노드 개수) m(에지 개수)
A(그래프 데이터 저장 인접 리스트)
visited(방문 기록 저장 배열)
for(n의 개수만큼 반복){
	A 인접 리스트의 각 ArrayList 초기화
}
for(m의 개수만큼 반복){
	A 인접 리스트에 그래프 데이터 저장
}
for(n의 개수만큼 반복){
	if(방문하지 않은 노드가 있으면){
		연결 요소 개수++
		DFS 실행
	}
}
// DFS 구현하기
DFS {
	if(현재 노드 == 방문 노드) return;
	visited 배열에 현재 노드 방문 기록
	현재 노드의 연결 노드 중 방문하지 않은 노드로 DFS 실행(재귀 함수 형태)
}
```
- 코드 구현하기
### 2. 너비 우선 탐색
- 너비 우선 탐색(BFS)도 그래프를 완전 탐색하는 방법 중 하나로, 시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘이다.

| 기능        | 특징                           | 시간 복잡도(V: 노드 수, E:에지 수) |
| --------- | ---------------------------- | ----------------------- |
| 그래프 완전 탐색 | - FIFO 탐색<br>- Queue 자료구조 이용 | O(V + E)                |
- 너비 우선 탐색은 선입선출 방식으로 탐색하므로 큐를 이용해 구현한다. 또한 너비 우선 탐색은 탐색 시작 노드와 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는 경로가 여러 개일 때 최단 경로를 보장한다.
##### 너비 우선 탐색의 핵심 이론
1. BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
2. 큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입
3. 큐 자료구조에 값이 없을 때까지 반복

##### 문제 026 DFS와 BFS 프로그램 (백준 1260)
- 문제 분석
	- DFS와 BFS를 구현할 수 있는지 물어보는 문제이다.
- 손으로 풀어보기
- 수도코드 작성
```java
N(노드 개수) M(에지 개수) Start(시작점)
A(그래프 데이터 저장 인접 리스트) visited(방문 기록 저장 배열)
for(N의 개수만큼 반복){
	A 인접 리스트의 각 ArrayList 초기화
}
// 방문할 수 있는 노드가 여려 개일 경우에는 번호가 작은 것을 먼저 방문하기 위해 정렬하기
for(N의 개수만큼 반복){
	각 노드와 관련된 에지를 정렬
}
visited 배열 초기화
DFS(Start) 실행
visited 배열 초기화
BFS(Start) 실행

DFS{
	현재 노드 출력
	visited 배열에 현재 노드 방문 기록
	현재 노드의 연결 노드 중 방문하지 않은 노드로 DFS 실행(재귀 함수)
}
BFS{
	큐 자료구조에 시작 노드 삽입(add 연산)
	visited 배열에 현재 노드 방문 기록
	while(큐가 비어 있을 때까지){
		큐에서 노드 데이터 가져오기(poll 연산)
		가져온 노드 출력
		현재 노드의 연결 노드 중 미방문 노드를 큐에 삽입(add 연산)하고 방문 배열에 기록
	}
}
```
- 코드 구현

##### 문제 027 미로 탐색하기 (백준 2178)
- 문제 분석
	- N, M의 최대 데이터의 크기가 100으로 매우 작기 때문에 시간 제한은 고려하지 않아도 되는 문제이다.
	- 문제의 요구사항은 지나야 하는 칸 수의 최솟값을 찾는 것이다.
	- 이는 완전 탐색을 진행하며 몇 번째 깊이에서 원하는 값을 찾을 수 있는 지를 구하는 것과 동일하다.
	- 따라서 BFS를 사용해 최초로 도달했을 때 깊이를 출력하면 문제를 해결할 수 있다.
	- DFS보다 BFS가 적합한 이유는 BFS는 해당 깊이에서 갈 수 있는 노드 탐색을 마친 후 다음 깊이로 넘어가기 때문이다.
- 손으로 풀어보기
- 수도코드 작성
```java
dx, dy(상하좌우를 탐색하기 위한 define값 정의 변수)
A(데이터 저장 2차원 행렬)
N(row), M(column)
visited(방문 기록 저장 배열)
for(N의 개수만큼 반복){
	for(M의 개수만큼 반복){
		A 배열에 데이터 저장
	}
}
BFS(0, 0) 실행
A[N-1][M-1] 값 출력

BFS {
	큐 자료구조에 시작 노드 삽입(add 연산)
	visited 배열에 현재 노드 방문 기록
	while(큐가 비어 있을 때까지){
		큐에서 노드 데이터를 가져오기(poll 연산)
		for(상하좌우 탐색){
			if(유효한 좌표){
				if(이동할 수 있는 칸이면서 방문하지 않은 노드){
					visited 배열에 방문 기록
					A 배열에 depth를 현재 노드의 depth + 1로 업데이트
					큐에 데이터 삽입(add 연산)
				}
			}
		}
	}
}
```
- 코드 구현

### 3. 이진 탐색
>[!이진 탐색]
>이진 탐색(binary search)은 데이터가 정렬돼 있는 상태에서 원하는 값을 찾아내는 알고리즘이다. 대상 데이터의 중앙값과 찾고자 하는 값을 비교해 데이터의 크기를 절반씩 줄이면서 대상을 찾는다.

| 기능        | 특징                  | 시간 복잡도  |
| --------- | ------------------- | ------- |
| 타깃 데이터 탐색 | 중앙값 비교를 통한 대상 축소 방식 | O(logN) |
- 이진 탐색은 정렬 데이터에서 원하는 데이터를 탐색할 때 사용하는 가장 일반적인 알고리즘이다.
- 구현 및 원리가 비교적 간단하므로 많은 코딩 테스트에서 부분 문제로 요구하는 영역이다.
##### 이진 탐색의 핵심 이론
- 이진 탐색 과정
	1. 현재 데이터셋의 중앙값을 선택한다.
	2. 중앙값 > 타깃 데이터일 때 중앙값 기준으로 왼쪽 데이터셋을 선택한다.
	3. 중앙값 < 타식 데이터일 때 중앙값 기준으로 오른쪽 데이터셋을 선택한다.
	4. 과정 1~3을 반복하다가 중앙값 == 타깃 데이터일 때 탐색을 종료한다.

##### 문제 029 원하는 정수 찾기 (백준 1920)
- 문제 분석
	- N의 최대 범위가 100,000이므로 단순 반복문으로는 문제를 풀 수 없다.
	- 이진 탐색을 적용하면 O(nlogn) 시간 복잡도로 해결할 수 있다.
	- 이진 탐색은 정렬 데이터에 사용 가능한 알고리즘으로 정렬 함수도 사용 한다.
- 손으로 풀어보기
- 수도코드 작성
- 코드 구현하기
- 