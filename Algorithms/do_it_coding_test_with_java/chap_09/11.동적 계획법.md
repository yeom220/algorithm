### 1. 동적 계획법 알아보기
>[!동적 계획법(dynaimc programming]
>동적 계획법은 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법을 뜻한다.

##### 동적 계획법의 핵심 이론
- **동적 계획법의 원리와 구현 방식
	- 1) 큰 문제를 작은 문제로 나눌 수 있어야 한다.
	- 2) 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결괏값은 항상 같아야 한다.
	- 3) 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 이 DP 테이블을 이용한다. 이를 메노이제이션(memoization) 기법이라고 한다.
	- 4) 동적 계획법은 톱-다운 방식과 바텀-업 방식으로 구현할 수 있다.
- 동적 계획법의 가장 대표적인 문제인 피보나치 수열을 예로 든다.
	- 피보나치 수열 공식
	-  `D[N] = D[N - 1] + D[N - 2] // N번째 수열 = N - 1번째 수열 + N번째 - 2번째 수열`
- 1) 동적 계획법으로 풀수 있는지 확인하기
	- 6번째 피보나치 수열은 5번째 피보나치 수열과 4번째 피보나치 수열의 합이다. 즉, 6번째 피보나치 수열을 구하는 문제는 5번째 피보나치 수열과 4번째 피보나치 수열을 구하는 작은 문제로 나눌 수 있고, 수열의 값은 항상 같기 때문에 동적 계획법으로 풀 수 있다.
- 2) 점화식 세우기
- 3) 메모이제이션 원리 이해하기
	- 메모이제이션은 부분 문제를 풀었을 때 이 문제를 DP 테이블에 저장해 놓고 다음에 같은 문제가 나왔을 때 재계산하지 않고 DP 테이블의 값을 이용하는 것을 말한다.
- 4) 톱-다운 구현 방식 이해하기
	- 톱-다운 구현 방식은 위에서부터 문제를 파악해 내려오는 방식으로, 주로 재귀 함수 형태로 코드를 구현한다. 코드의 가독성이 좋고, 이해하기가 편하다는 장점이 있다.
- 5) 바텀-업 구현 방식 이해하기
	- 가장 작은 부분 문제부터 문제를 해결하면서 점점 큰 문제로 확장해 나가는 방식이다. 주로 반복문의 형태로 구현한다.
- 두 방식 중 좀 더 안전한 방식은 바텀-업이다. 톱-다운 방식은 재귀 함수의 형태로 구현돼 있기 때문에 재귀의 깊이가 매우 깊어질 경우 런타임 에러가 발생할 수 있다.
- 하지만 실제 코딩 테스트에서 이 부분까지 고려해야 하는 난이도는 잘 나오지 않는다.

##### 문제 087 2\*N 타일 채우기 (백준 11726)
- 문제 분석
	- 2 x N 크기의 직사각형을 1 x 2 또는 2 x 1 크기의 타일로 채우는 경우의 수를 구하는 점화식 D\[N]을 정의한다.
	- 점화식을 정의한 후에는 문제가 단순화되도록 가정하는 것이 중요하다.
	- 1부터 N - 1 크기에 직사각형과 관련된 경우의 수를 모두 구해 놓았다고 가정하고 문제에 접근한다.
	- N 바로 직전에 구해야 하는 N - 1, N - 2에서 N의 길이를 만들기 위한 경우의 수를 생각해 본다.
	- N -1 과 N - 2에서 만들 수 있는 타일의 경우의 수를 더하면 N 길이에서의 경우의 수를 구할 수 있다.
	- 점화식을 도출하면 다음과 같다.
	- `D[N] = (D[N - 1] + D[N - 2])`
- 손으로 풀어보기
	- 1) 점화식의 형태와 의미를 도출한다.
		- `D[N]: 길이 N으로 만들 수 있는 타일의 경우의 수`
	- 2) 점화식을 구한다.
		- `D[N] = D[N - 1] + D[N - 2] // D[N - 1]과 D[N - 2]의 경우의 수의 합이 D[N]`
	- 3) 점화식으로 D 배열을 채운 후 D\[N]의 값을 출력한다. D 배열을 채울 때마다 문제에서 주어진 값 (10,007)으로 % 연산을 수행한다.
- 수도코드 작성하기
- 코드 구현하기

##### 문제 090 최장 공통 부분 수열 찾기 (백준 9252)
- 문제 분석
	- LCS는 문자열을 이용한 대표적인 동적 계획법 문제이다. 이러한 종류의 문제를 풀기 위해서는 각 문자열을 축으로 하는 2차원 배열을 생성해야 한다.
	- 2차원 배열이 바로 점화식 배열이 된다.
	- 배열에 저장하는 값은 각 위치 인덱스를 마지막 문자로 하는 두 문자열의 최장 공통 수열의 길이이다.
- 손으로 풀어보기
	- 1) LCS 점화식을 이용해 값을 채운다. 
		- 특정 자리가 가리키는 행과 열의 문자열값을 비교해 값이 같으면 배열의 대각선 왼쪽 위의 값에 1을 더한 값을 저장한다.
			- `DP[i][j] = DP[i - 1][j - 1] + 1`
		- 비교한 값이 다르면 배열의 왼쪽의 값 중 큰 값을 선택해 저장한다.
			- `DP[i][j] = Math.max(DP[i - 1][j], DP[i][j - 1])`
	- 2) LCS 정답을 출력한다.
		- 먼저 마지막부터 탐색을 수행하고, 해당 자리에 있는 인덱스 문자열값을 비교해 값이 같으면 최장 증가 수열에 해당하는 문자로 기록하고, 왼쪽 대각선으로 이동한다.
		- 비교한 값이 다르면 배열의 왼쪽 위의 값 중 큰 값으로 이동한다.
- 수도코드 작성하기
- 코드 구현하기

##### 문제 094 행렬 곱 연산 횟수의 최솟값 구하기 (백준 11049)
- 문제 분석
	- 문제가 난이도가 있고, 점화식을 구하기 막막할 때는 동적 계획법의 특징을 다시 한번 떠올려 본다.
	- 부분 문제를 구해 큰 문제를 해결하는 방식이 동적 계획법의 특징 중 하나이다.
	- 행렬의 개수 N이 주어지고, 1 ~ N개를 모두 곱했을 때 최소 연산 횟수를 구해야 한다.
	- 만약 N개 이외의 부분 영역, 예를 들면 1 ~ N - 1, 2 ~ N, 3 ~ N - 2 등 N을 제외한 모든 부분 구역을 1개의 행렬로 만드는 데 필요한 최소 연산 횟수를 알고 있다고 가정한다.
	- **점화식 정의**
		- `D[i][j]: i ~ j 구간의 행렬을 합치는 데 드는 최소 연산 횟수`
		- D\[1]\[N - 1], D\[N]\[N]의 값을 안다고 가정했으므로 이때 1개의 행렬로 합치는 데 드는 횟수는 다음과 같다.
			-  `D[1][N - 1] + D[N][N] + a`
			- a는 두 행렬을 합치는 데 드는 값으로 2 x 3과 3 x 6 행렬이 있다면 2 x 3 x 6 = 36이다.
			- 이때는 1번째 행렬의 row 개수, N번째 행렬의 row 개수, column 개수를 곱하면 된다.
		- 이 아이디어를 바탕으로 생각하면 D\[1]\[N]의 값을 찾는 식을 구할 수 있다.
- 손으로 풀어보기
	- 행렬 구간에 행렬이 1개일 때 0을 리턴한다.
	- 행렬 구간에 행렬이 2개일 때 '앞 행렬의 row 값 * 뒤 행렬의 row 값 * 뒤 행렬의 column값'을 리턴한다.
	- 행렬 구간에 행렬이 3개 이상일 때는 다음 조건식의 결괏값을 리턴한다.
```java
// s: 시작 인덱스, e: 종료 인덱스
for(i를 시작 행렬부터 종료 행렬까지 반복하기)
	min = Math.min(min, D[s][i] + D[i + 1][e] + a(s 행렬의 row * i + 1 행렬의 row * e 행렬의 coulmn))
```
- 수도코드 구현하기
- 코드 구현하기

##### 문제 095 외판원의 순회 경로 짜기 (백준 2098)
- 문제 분석
	- 외판원 순회 문제는 영어로 TSP(traveling salesman problem)라고 불리고, 컴퓨터 과학 분야에서 가장 중요하게 취급되는 문제 중 하나이다.
	- N의 크기가 매우 작기 때문에 모든 순서를 완전 탐색을 수행하면 정답을 구할 수 있다.
	- **점화식 정의**
		- `D[c][v]: 현재 도시가 c, 현재까지 방문한 모든 도시 리스트가 v일 때 앞으로 남은 모든 도시를 경유하는 데 필요한 최소 비용`
	- 여기서 생각해야 할 문제는 D\[i]\[j]에서 j가 나타내는 것이 현재까지 방문한 모든 도시 리스트라는 것이다. 리스트 데이터를 j라는 변수 1개에 저장할 수 있는 방법은 bit, 이진수로 표현 가능하다.
	- 총 도시가 4개일 때를 예로 들어 방문 도시를 이진수로 표현해본다. 방문 도시를 이진수의 각 자릿수로 표현하고, 방문 시 1, 미방문 시 0의 값으로 저장한다.
		- 4번, 1번 방문 -> 이진수로 표현(1001) -> D\[i]\[9]
		- 3번, 2번 방문 -> 이진수로 표현(110) -> D\[i]\[6]
		- 4번, 3번, 2번, 1번 방문 -> 이진수로 표현(1111) -> D\[i]\[15]
- 손으로 풀어보기
	- 1) c번 도시에서 v 리스트 도시를 방문한 후 남은 모든 도시를 순회하기 위한 최소 비용은 현재 방문하지 않은 모든 도시에 대해 반복하고, 방문하지 않은 도시를 i라고 했을 때 다음과 같다. W\[c]\[i]는 도시 c에서 도시 i로 가기 위한 비용을 나타낸다.
		- `D[c][v] = Math.min(D[c][v], (D[i][v] | (1 << i)) + W[c][i])`
	- 2) W 배열을 저장한다.
	- 3) 점화식으로 정답을 구한다.
	- 4) 최솟값을 정답으로 출력한다.
		- `W[0][1] + W[1][3] + W[3][2] + W[2][0] = 10 + 10 + 9 + 6 = 35`

>[!점화식에 사용한 비트 연산식]
>----
>위에 나온 점화식에서는 그동안의 점화식과는 다르게 비트 연산을 사용한다.
>기본적인 And, Or, Shift 연산을 이해한 후 이 점화식을 적용한다.
>- 모든 도시 순회 판단 연산식
>	- `if(v == (1 << N) - 1) // 예) N = 4(도시의 개수가 4개인 경우): (1 << 4) - 1 = 16 - 1 = 15`
>	- 15를 이진수로 표현하면 1111로 표현되며 이진수의 각 자리가 모두 1이기 때문에 모든 도시를 방문한 상태이다.
>- 방문 도시 확인 연산식
>	- `if((v & (1 << i)) == 0) // 예) i = 3(3번째 도시 방문 여부 확인): 1 << 3 = 8 = 1000`
>	- v & 1000 연산을 수행하였을 때 결괏값이 0이면 3번 도시를 방문하지 않았다고 판단할 수 있다. 즉, v의 이진수 표현 시 3번째 자리가 1인 경우가 아니면 0을 리턴하며 3번째 도시를 방문하지 않았다고 판단한다.
>- 방문 도시 저장 연산식
>	- `v | (1 << i) // 예) i = 2(2번째 도시 저장): 1 << 2 = 100`
>	- v | 100 연산을 수행하면 v의 이진수 표현 시 2번째 자리를 1로 저장하게 되어 2번째 도시를 방문하였다는 사실을 저장한다.

- 수도코드 작성하기
- 코드 구현하기

##### 문제 096 가장 길게 증가하는 부분 수열 찾기 (백준 14003)
- 문제 분석
	- 가장 길게 증가하는 부분 수열(최장 증가 수열)의 점화식은 다음과 같이 비교적 간단하게 정의할 수 있다.
	- **점화식 정의**
		- `D[i]: 0 ~ i까지 i를 포함하는 가장 길게 증가하는 수열의 길이`
	- 부분 문제를 이용해 전체 문제를 풀이하려면 i의 값이 부분 문제에 핵심이 되도록 정의해야 하므로 D\[i]를 단순히 0 ~ i 까지의 최장 증가 수열의 길이가 아닌 0 ~ i 까지 i를 포함하는 최장 증가 수열의 길이로 정의하는 것이 중요하다.
	- 이 문제는 N의 최댓값이 1,000,000으로 크기 때문에 시간 복잡도를 고려해 풀이를 설계해야 한다.
- 손으로 풀어보기
	- 1) 점화식을 구한다. A\[i]를 i번째 수열의 값이라고 정의하면 D\[k]는 A\[i] > A\[k]를 만족하는 최대 길이의 집합이다. 즉, A\[i]보다 작은 값을 지니고 있는 수열의 최장 증가 수열의 길이들 중 최댓값을 찾아 해당 값에 +1을 한 값을 D\[i]에 저장하면 된다.
		- `D[i] = max({D[k]}) + 1 (k = 1 ~ i - 1)`
	- 2) 점화식을 이용해 D 배열의 값을 저장한다. 이때 자신보다 작은 값을 지니고 있는 최장 증가 수열 길이를 찾기 위해 B 배열을 만들어 현재 가장 유리한 수열을 실시간으로 저장한다.
	- 3) D 배열을 이용해 정답을 출력한다. 먼저 뒤에서부터 탐색해 최댓값(5)과 동일한 값을 가지는 최초 index의 A\[]값을 출력한다. 그리고 값을 1만큼 감소시키고 A\[]의 값이 0이 될 때까지 반복한다. 이때 시간 복잡도를 줄이기 위해 자신이 들어갈 수 있는 위치를 찾는 알고리즘을 바이너리 서치를 이용해 구현해야 한다.
- 수도코드 작성하기
- 코드 구현하기
- 

