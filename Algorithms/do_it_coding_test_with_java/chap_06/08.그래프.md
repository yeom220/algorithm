>[!그래프]
>그래프는 노드와 에지로 구성된 집합입니다. 노드는 데이터를 표현하는 단위이고 에지는 노드를 연결합니다.
>트리도 그래프의 일종입니다. 그래프는 여러 알고리즘에 많이 사용되는 자료구조이므로 코딩 테스트에서 자주 등장합니다.
### 1. 그래프의 표현
###### 에지리스트
- 에지 리스트(edge list)는 에지를 중심으로 그래프를 표현한다.
- 에지 리스트는 배열에 출발 노드, 도착 노드를 저장하여 에지를 표현한다.
- 또는 출발 노, 도착 노드, 가중치를 저장하여 가중치가 있는 에지를 표현한다.
- **에지 리스로 가중치 없는 그래프 표현하기
	- 가중치가 없는  그래프는 출발 노드와 도착 노드만 표현하므로 배열의 행은 2개이다.
	- 1에서 2로 뻗어나가는 에지는 [1, 2]로 표현한다.
	- 방향이 있는 그래프는 순서에 맞게 노드를 배열에 저장하는 방식으로 표현한다.
	- 노드를 배열에 저장하여 에지를 표현하므로 에지 리스트라 한다.
- **에지 리스트로 가중치 있는 그래프 표현하기
	- 가중치가 있는 그래프는 행을 3개로 늘려 3번째 행에 가중치를 저장한다.
	- 1에서 2로 향하는 가중치가 8인 에지는 [1, 2, 8]로 표현한다.
	- 에지 리스트는 구현하기 쉬우나 특정 노드와 관련되어 있는 에지를 탐색하기는 쉽지 않다.
	- 벨만 포드, 크루스칼(MST) 알고리즘에 사용하며, 노드 중심 알고리즘에는 잘 사용하지 않는다.
##### 인접 행렬
- 인접 행렬(adjacency matrix)은 2차원 배열을 자료구조로 이용하여 그래프를 표현한다.
- 노드 중심으로 그래프를 표현한다.
- **인접 행렬로 가중치 없는 그래프 표현하기**
	- 1에서 2를 향하는 에지를 인접 행렬은 1행 2열에 1을 저장하는 방식으로 표현한다. (가중치가 없기 때문에 1로 저장)
- **인접 행렬로 가중치 있는 그래프 표현하기**
	- 2에서 5로 향하는 에지의 가중치를 2행 5열에 저장한다.
- 구현이 쉽고 노드를 연결하는 에지의 여부와 가중치값은 배열에 직접 접근하면 바로 확인할 수 있는 것도 장점이다.
- 노드와 관련되어 있는 에지를 탐색하려면 N번 접근해야 하므로 노드 개수에 비해 에지가 적을 때는 공간 효율성이 떨어진다. 또한 노드 개수가 많은 경우 2차원 배열 선언 자체를 할 수 없는 결함도 있다. (노드가 3만개가 넘으면 자바 힙 스페이스 에러가 발생한다.)
##### 인접 리스트
- 인접 리스트(adjacency list)는 ArrayList로 그래프를 표현한다. 노드 개수만큼 ArrayList을 선언한다.
- **인접 리스트로 가중치 없는 그래프 표현하기**
	- N번 노드와 연결되어 있는 노드를 배열의 위치 N에 연결된 노드 개수만큼  배열을 연결하는 방식으로 표현한다.
	- 예를 들어 노드 1과 연결된 2, 3 노드는 ArrayList[1]에 [2, 3]을 연결하는 방식으로 표현한다.
- **인접 리스트로 가중치 있는 그래프 표현하기**
	- 가중치가 있는 경우 자료형을 클래스로 사용한다. (도착, 노드, 가중치)를 갖는 Node 클래스를 선언하여 ArralyList에 사용한다.
	- ArrayList[1]에 [(2, 8), (3, 3)]이 들어있다면, 노드 1과 2가 가중치 8 에지로, 노드 1과 3이 가중치 3 에지로 연결 되었다는 것을 표현한다. 방향성도 고려되어 있다.
	- 그래프를 구현하는 다른 방법에 비해 인접 리스트를 이용한 그래프 구현은 복잡한 편이다. 하지만 노드와 연결되어 있는 에지를 탐색하는 시간은 매우 뛰어나며, 노드 개수가 커도 공간 효율이 좋아 메모리 초과 에러도 발생하지 않는다.
	- 실제 코딩 테스트에서는 인접 리스트를 이용한 그래프 구현을 선호한다.
##### 문제 48 이분 그래프 판별하기 (백준 1707)
- 문제 분석
	- 노드의 집합을 2개로 나누는데, 인접한 노드끼리 같은 집합이 되지 않도록 적절하게 임의로 분할할 수 있다고 한다. 트리의 경우에는 항상 이분 그래프가 된다.
	- 사이클이 발생하지 않으면 탐색을 하면서 다음 노드를 이번 노드와 다른 집합으로 지정하면 되기 때문이다.
	- 단, 사이클이 발생했을 때는 이분 그래프가 불가능할 때가 있다.
	- 기존의 탐색 메커니즘에서 탐색한 노드에 다시 접근하게 됐을 때 현재 노드의 집합과 같으면 이분 그래프가 불가능하다는 것으로 판별할 수 있다.
- 손으로 풀어보기
	1. 입력된 그래프 데이터를 인접 리스트로 구현한다.
	2. 모든 노드로 각각 DFS 탐색 알고리즘을 적용해 탐색을 수행한다. DFS를 실행할 때 현재 노드에서 연결된 노드 중 이미 방문한 노드가 나와 같은 집합이면 이분 그래프가 아닌 것으로 판별한다. 이후 노드는 탐색하지 않는다.
	3. 이분 그래프 여부를 정답으로 출력한다.
	4. 테스트 수 만큼 과정 1~3을 반복한다.
- 수도코드 작성하기
```java
check(이분 그래프 체크 배열)
A(그래프 데이터 저장 인접 리스트) visited(방문 기록 저장 배열)
N(테스트 케이스)
for(N의 개수만큼 반복){
	V(노드 개수)
	E(에지 개수)
	for(V의 개수만큼 반복){
		A 인접 리스트의 각 ArrayList 초기화
	}
	for(E의 개수만큼 반복){
		A의 인접 리스트에 그래프 데이터 저장
	}
	for(V의 개수만큼 반복){
		각 노드에서 DFS 실행 -> 결과가 이분 그래프가 아니면 반복 종료
	}
	이분 그래프 여부 정답으로 출력
}
DFS {
	visited 배열에 현재 노드 방문 기록
	if(현재 노드의 연결 노드 중 방문하지 않은 노드일 때){
		현재 노드와 다른 집합으로 연결 노드 집합 저장
		DFS 실행 (재귀 형태)
	}
	else { // 이미 방문한 노드인데, 현재 나의 노드와 같은 집합이면
		이분 그래프가 아님
	}
}
```
- 코드 구현
### 2. 유니온 파인드

>[!유니온 파인드]
>유니온 파인드(union-find)는 일반적으로 여러 노드가 있을 때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 union 연산과 두 노드가 같은 집합에 속해 있는지를 확인하는 find 연산으로 구성되어 있는 알고리즘이다.
##### 유니온 파인드의 핵심 이론
- **union, find 연산**
	- union 연산
		- 각 노드가 속한 집합을 1개로 합치는 연산이다.
		- 노드 a, b가 a ¢ A, b ¢ B일 때 union(a, b)는 A U B 를 말한다.
	- find 연산
		- 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산이다.
		- 노드 a가 a ¢ A일 때 find(a)는 A 집합의 대표 노드를 반환한다.
##### 유니온 파인드의 원리 이해하기
1. 유니온 파인드를 표현하는 일반적인 방법은 1차원 배열을 이용하는 것이다. 처음에는 노드가 연결되어 있지 않으므로 각 노드가 대표 노드가 된다. 각 노드가 모두 대표 노드이므로 배열을 자신의 인덱스값으로 초기화 한다.
2. 2개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 union 연산을 수행한다.
	- union(1, 4)와 union(5, 6) 실행하여 연결한다.
		- union(1, 4)를 예로 들어 1은 대표 노드, 4는 자식 노드로 union 연산을 하므로 배열[4]의 대표 노드를 1로 설정한다. 다시 말해 자식 노드로 들어가는 노드값 4를 대표 노드값 1로 변경한 것이다. 그 결과 각각의 집합이었던 1, 4는 하나로 합쳐진다.
	- 이제 union(4, 6)으로 4와 6을 연결해 본다. 그런데 4, 6은 대표 노드가 아니다. 그래서 find 연산을 이용하여 각 노드의 대표 노드를 찾아 올라간 다음 그 대표 노드를 연결한다. 4의 대표 노드 1에 6의 대표 노드 5를 연결하여 [1, 2, 3, 1, 1, 5]가 된다.
3. find 연산은 자신이 속한 집합의 대표 노드를 찾는 연산이다. find 연산은 단순히 대표 노드를 찾는 역할만 하는 것이 아니라 그래프를 정돈하고 시간 복잡도를 향상시킨다.
	1. **find 연산의 작동 원리**
		1. 대상 노드 배열에 index값과 value값이 동일한지 확인한다.
		2. 동일하지 않으면 value값이 가리키는 index 위치로 이동한다.
		3. 이동 위치의 index값과 value값이 같을 때까지 1~2를 반복한다. (재귀 함수)
		4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드값을 루트 노드값으로 변경한다.
##### 문제 050 집합 표현하기 (백준 1717)
- 문제 분석
	- 최대 원소의 개수 1,000,000과 질의 개수 100,000이 큰 편이므로 경로 압축이 필요한 전형적인 유니온 파인드 문제입니다.
- 손으로 풀어보기
	1. 처음에는 노드가 연결돼 있지 않으므로 각 노드의 대표 노드는 자기 자신입니다. 각 노드의 값을 자기 인덱스값으로 초기화 합니다.
	2. find 연산으로 특정 노드의 대표 노드를 찾고, union 연산으로 2개의 노드를 이용해 각 대표 노드를 찾아 연결합니다. 그리고 질의한 값에 따라 결과를 반환합니다.

>[!유니온 파인드에서 자주 실수하는 부분]
>1. find 연산을 수행할 때 재귀 함수에서 나오면서 탐색한 모든 노드의 대표 노드값을 이번 연산에서 발견한 대표 노드로 변경하는 부분
>2. union 연산에서 선택된 노드끼리 연결하는 것이 아닌 선택된 노드의 대표 노드끼리 연결하는 부분

- 수도코드 작성
```java
N(원소 개수) M(질의 개수)
parent(대표 노드 저장 배열)
for(N만큼 반복){
	대표 노드를 자기 자신으로 초기화
}
for(M만큼 반복){
	if(0이면) 집합 합치기 -> union 연산
	else 같은 집합 원소인지 확인하고 결괏값 출력
}
// union 연산
union(a, b){
	a와 b의 대표 노드 찾기
	두 원소의 대표 노드끼리 연결하기
}
find(a){
	a가 대표 노드면 리턴
	아니면 a의 대표 노드값을 find(parnet[a]) 값으로 저장 -> 재귀 함수 형태
}
// checkSame -> 두 원소가 같은 집합인지 확인
checkSame(a, b){
	a와 b의 대표 노드 찾기
		두 대표 노드가 같으면 true
		아니면 false return
}
```
- 코드 구현하기
### 3. 위상 정렬
>[!위상 정렬]
>위상 정렬(topology sort)은 사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘이다.

| 기능           | 특징         | 시간 복잡도(V: 노드 수, E: 에지 수) |
| ------------ | ---------- | ------------------------ |
| 노드 간의 순서를 결정 | 사이클이 없어야 함 | O(V + E)                 |
- 위상 정렬에서는 항상 유일한 값으로 정렬되지 않는다.
- 사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없으므로 위상 정렬을 적용할 수 없다.
##### 위상 정렬의 핵심 이론
1. 진입 차수(in-degree)는 자기 자신을 가리키는 에지의 개수이다. 진입 차수 배열 D를 다음과 같이 업데이트 한다. 1에서 2, 3을 가리키고 있으므로 D[2], D[3]을 각각 1만큼 증가시킨다.
2. 진입 차수 배열에서 진입 차수가 0인 노드를 선택하고 선택된 노드를 정렬 배열에 저장한다. 그 후 인접 리스트에서 선택된 노드가 가리키는 노드들의 진입 차수를 1씩 뺀다. 이 과정을 모든 노드가 정렬될 때까지 반복한다. 진입 차수가 동일한 노드들이 있을 수 있기 때문에 위상 정렬이 늘 같은 정렬 결과를 보장하지는 않는다.
##### 문제 053 줄 세우기 (백준 2252)
- 문제 분석
	- 학생들을 노드로 생각하고, 키 순서 비교 데이터로 에지를 만든다고 생각했을 때 노드의 순서를 도출하는 가장 기본적인 문제이다.
	- 특히 답이 여러 개일 때 아무것이나 출력해도 된다는 전제는 위상 정렬의 결괏값이 항상 유일하지 않다는 알고리즘의 전제와 동일하다.
- 손으로 풀어보기
	1. 인접 리스트에 노드 데이터를 저장하고, 진입 차수 배열값을 업데이트 한다.
	2. **위상 정렬 수행 과정**
		1. 진입 차수가 0인 노드를 큐에 저장한다.
		2. 큐에서 데이터를 poll해 해당 노드를 탐색 결과에 추가하고, 해당 노드가 가리키는 노드의 진입 차수를 1씩 감소한다.
		3. 감소했을 때 진입 차수가 0이 되는 노드를 큐에 offer한다.
		4. 큐가 빌 때까지 1~3을 반복한다.
- 수도코드 작성하기
```java
N(학생 수) M(비교 횟수) A(데이터 저장 인접 리스트)
학생 수만큼 인접 리스트 초기화
진입 차수 배열 초기화
for(비교 횟수만큼 반복){
	인접 리스트 데이터 저장
	진입 차수 배열 초기 데이터 저장
}
// 위상 정렬 수행
큐 생성
for(학생 수){
	진입 차수 배열의 값이 0인 학생(노드)을 큐에 삽입하기
}
while(큐가 빌 때까지){
	현재 노드 = 큐에서 데이터 poll
	현재 노드값 출력
	for(현재 노드에서 갈 수 있는 노드의 개수){
		타깃 노드 진입 차수 배열--
		if(타깃 노드의 진입 차수가 0이면){
			큐에 타깃 노드 추가
		}
	}
}
```
- 코드 구현

##### 문제 054 게임 개발하기 (백준 1516)
- 문제 분석
	- "어떤 건물을 짓기 위해 먼저 지어야 하는 건물이 있을 수 있다"라는 문장에 주목해야 한다.
	- 각 건물을 노드라고 생각하면 그래프 형태에서 노드 순서를 정렬하는 알고리즘인 위상 정렬을 사용하는 문제라는 것을 눈치챌 수 있다.
	- 건물의 수가 최대 500, 시간 복잡도가 2초이므로 시간 제한 부담은 거의 없다.
- 손으로 풀어보기
	1. 입력 데이터를 바탕으로 자료구조를 초기화 한다. 인접 리스트로 그래프를 표현할 때는 (인접 노드, 건물 번호)를 Node로 선언하여 연결한다. 진입 차수 배열은 [0, 1, 1, 2, 1], 정답 배열은 모두 0으로 초기화 한다.
	2. 위상 정렬을 실행하면서 각 건물을 짓는 데 걸리는 최대 시간을 업데이트한다. 업데이트는 다음과 같은 방법으로 수행한다.
		1. Math.max(현재 건물(노드)에 저장된 최대 시간, 이전 건물(노드)에 저장된 최대 시간 + 현재 건물(노드)의 생산 시간)
	3. 정답 배열에 자기 건물을 짓는 데 걸리는 시간을 더한 후 정답 배열을 차례대로 출력한다.
- 수도코드 작성
```java
N(건물 종류 수), A(데이터 저장 인접 리스트)
건물의 개수만큼 인접 리스트 초기화
진입 차수 배열 초기화
자기 자신을 짓는 데 걸리는 시간 저장 배열 초기화
for(건물의 개수){
	인접 리스트 데이터 저장
	진입 차수 배열 초기 데이터 저장
	자기 자신 배열 초기화
}
// 위상 정렬 수행
큐 생성
for(건물의 개수){
	진입 차수 배열의 값이 0인 건물(노드)를 큐에 삽입하기
}
while(큐가 빌 때까지){
	현재 노드 = 큐에서 데이터 poll
	for(현재 노드에서 갈 수 있는 노드의 개수){
		타깃 노드 진입 차수 배열--
		결과 노드 업데이트 = Math.max(현재 저장된 값, 현재 출발 노드 + 비용)
		if(타깃 노드의 진입 차수가 0이면){
			우선순위 큐에 타깃 노드 추가하기
		}
	}
}
위상 정렬 결과 출력
```
- 코드 구현하기

### 04. 다익스트라
>[!다익스트라 알고리즘]
>다익스트라(dijkstra)알고르짐은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같다.

| 기능                     | 특징        | 시간 복잡도(V: 노드수, E: 에지 수) |
| ---------------------- | --------- | ----------------------- |
| 출발 노드와 모든 노드간의 최단거리 탐색 | 에지는 모두 양수 | O(ElogV)                |
##### 다익스트라 알고리즘의 핵심 이론
1. 인접 리스트로 그래프 구현하기
	- 다익스트라 알고리즘은 인접 행렬로 구현해도 좋지만 시간 복잡도 측면, N의 크기가 클 것을 대비해 인접 리스트를 선택하여 구현하는 것이 좋다.
	- 그래프의 연결을 표현하기 위해 인접 리스트에 연결한 배열의 자료형은 (노드, 가중치)와 같은 형태로 선언하여 연결한다.
2. 최단 거리 배열 초기화하기
	- 최단 거리 배열을 만들고 출발 노드는 0, 이외의 노드는 주어진 입력값의 범위보다 큰 값을 사용한다.
3. 값이 가장 작은 노드 고르기
	- 최단 거리 배열에서 현재 값이 가장 작은 노드를 골라 시작한다.
4. 최단 거리 배열 업데이트하기
	- 선택된 노드에 연결된 에지의 값을 바탕으로 다른 노드의 값을 업데이트한다.
	- 1단계에서 저장해 놓은 연결 리스트를 이용해 현재 선택된 노드의 에지들을 탐색하고 업데이트하면 된다.
	- 연결 노드의 최단 거리는 두 값 중 더 작은 값으로 업데이트한다.
	- **최단 거리 업데이트 방법**
		- Min(선택 노드의 최단 거리 배열의 값 + 에지 가중치, 연결 노드의 최단 거리 배열의 값)
5. 과정 3~4를 반복해 최단 거리 배열 완성하기
	- 모든 노드가 처리될 때까지 과정 3~4를 반복한다.
	- 과정 4에서 선택 노드가 될 때마다 다시 선택되지 않도록 방문 배열을 만들어 처리한다.
	- 모든 노드가 선택될 때까지 반복하면 최단 거리 배열이 완성된다.

>[!참고]
>다익스트라 알고리즘은 출발 노드와 그외 노드 간의 최단 거리를 구하는 알고리즘이다. 에지는 항상 양수여야 한다는 제약 조건이 있다.
>다익스트라 알고리즘이 출발 노드와 도착 노드 간의 최단 거리를 구하는 알고리즘이라고 생각하는 경향이 있는데, 실제로 완성된 배열은 출발 노드와 이외의 모든 노드 간의 최단 거리를 표현한다. 가끔 이 부분이 코딩 테스트의 문제로 나올 때가 있으므로 꼭 숙지하길 바란다.

##### 문제 056 최단 경로 구하기 (백준 1753)
- 문제 분석
	- 시작점과 다른 노드와 관련된 최단 거리를 구하는 문제로, 다익스트라 알고리즘의 가장 기본적인 형태를 구현할 수 있는지 묻는 문제이다.
- 손으로 풀어보기
	1. 인접 리스트에 노드를 저장하고 거리 배열을 초기화한다.
	2. 최초 시작점을 큐에 삽입하고, 다음 과정에 따라 다익스트라 알고리즘을 수행한다.
		1. **다익스트라 알고리즘 수행 과정**
			1. 거리 배열에서 아직 방문하지 않은 노드 중 현재 값이 가장 작은 노드를 선택한다.
			2. 해당 노드와 연결된 노드들의 최단 거릿값을 다음 공식을 이용해 업데이트 한다.
				1. Min(선택 노드의 거리 배열의 값 + 에지의 가중치, 연결 노드의 거리 배열의 값)이 업데이트된 경우 연결 노드를 큐에 삽입
			3. 큐가 빌 때까지 1~2를 반복한다.
	3. 완성된 거리 배열의 값을 출력한다.
- 수도코드 작성하기
```java
자료구조 선언하기(그래프 정보 저장, 최단 거리 저장, 노드 사용 여부 저장)
V(노드 개수)
E(에지 개수)
K(출발 노드)
거리 배열은 충분히 큰 수로 초기화
for(노드 개수){
	그래프 정보를 저장하는 인접 리스트 초기화
}
for(에지 개수){
	인접 리스트 배열에 이 에지 정보를 저장
}
다익스트라 알고리즘 수행
출발 노드는 우선순위 큐에 넣고 시작 // 자동으로 거리가 최소인 노드를 선택하게 함
while(큐가 빌 때까지){
	현재 선택된 노드가 방문된 적이 있는지 확인하기
	현재 노드를 방문 노드로 업데이트하기
	for(현재 선택 노드의 에지 개수){
		if(타깃 노드 방문 전 && 현재 선택 노드 최단 거리 + 비용 < 타깃 노드의 최단 거리){
			타깃 노드 최단 거리 업데이트
			우선순위 큐에 타깃 노드 추가	
		}
	}
}
완성된 거리 배열을 탐색해 출력
// 가중치가 있는 그래프를 담기 위한 클래스 별도 구현
Edge {
	vertext(가리키는 노드
	value(에지의 가중치)
	우선순위 큐 정렬 기준을 위해 compareTo 함수 구현
}
```
- 코드 구현

##### 문제 058 K번째 최단 경로 찾기 (백준 1854)
- 문제 분석
	- 시작점과 도착점이 주어지고 이 목적지까지 가는 K번째 최단 경로를 구하는 문제이다.
	- 도시(노드)의 수는 1,000개, 도로(에지)의 수는 2,000,000이면서 시간 제약이 2초이므로 다익스트라 알고리즘으로 접근해 보겠다.
	- **K번째 최단 경로 해결 방법**
		- 최단 경로를 표현하는 배열을 우선순위 큐 배열(크기는 K)로 변경한다. 이렇게 하면 최단 경로뿐 아니라 최단 경로 ~ K번째 최단 경로까지 표현이 가능하다.
		- 사용한 노드는 방문 배열에 확인해 두고 재사용하지 않는 부분은 삭제가 필요하다. K번째 경로를 찾기 위해서는 노드를 여러 번 쓰는 경우가 생기기 때문이다.
- 손으로 풀어보기
	1. 예제 데이터를 기반으로 그래프를 그린다. 도시는 노드로, 도로는 에지로 나타낸다.
	2. 변수를 선언하고, 그래프 데이터를 받는 부분은 모두 다익스트라 알고리즘 준비과정과 동일하다.
	3. 최단 거리 배열을 우선순위 큐 배열로 선언한다.(크기가 K인 큐)
		1. **최단 거리 배열 채우기 규칙**
			1. 현재 노드에서 저장된 경로가 K개 미만일 때 신규 경로를 추가한다.
			2. 경로가 K개일 때 현재 경로 중 최대 경로와 신규 경로를 비교해 신규 경로가 더 작을 때 업데이트한다. 우선 순위 큐를 사용하면 이 로직을 쉽게 구현 가능하다.
			3. K번째 경로를 찾기 위해서는 노드를 여러 번 쓰는 경우가 생기므로 사용한 노드는 방문 배열에 확인해 두고 재사용하지 않는 부분은 삭제한다.
	4. 최단 거리 배열을 탐색하면서 K번째 경로가 존재하면 출력하고, 존재하지 않으면 -1을 출력한다.
>[!우선순위 큐로 선언하면 편리한 점]
>이 부분에서 최단 거리 배열의 객체 형식을 우선순위 큐로 선언했기 때문에 새로운 노드가 삽입됐을 때 별도의 정렬을 해주지 않아도 자동으로 정렬돼 편리하게 구현할 수 있다.

- 수도 코드 작성
```java
N(노드 개수) M(에지 개수)
K(몇 번째 최단 경로를 구해야 하는지 나타내는 변수)
W(그래프 정보 저장 인접 행렬)
for(노드 개수 + 1){
	최단 거리 큐 배열 초기화
}
for(에지 개수){
	인접 행렬에 에지 정보 저장
}
다익스트라 알고리즘 수행
출발 노드는 우선순위 큐에 넣고 시작 // 자동으로 거리가 최소인 노드를 선택할 수 있음
while(큐가 빌 때까지){
	for(노드 개수만큼 반복하기){ // 시간 복잡도 측면에서 인접 행렬 구조가 불리함
		if(해당 노드와 현재 노드가 연결돼 있으면)
			if(최단 거리 배열 큐에 해당 노드에 관해 저장된 경로가 K개보다 작으면){
				최단 거리 큐 배열에 거리 정보 삽입하고 큐에 선택 노드를 추가하기
			}
			else if (최단 거리 큐의 마지막 값 > 이전 노드의 값 + 두 노드 사이의 애지 가중치){
				해당 노드에 최단 거리 큐에 마지막값 삭제하고 신규값으로 업데이트
				큐에 선택 노드 추가
			}
	}
}
for(노드 개수){ // 최단 거리 배열 큐를 이용해 각 노드의 K번째 경로를 출력
	우선순위 큐 크기가 K이면 큐의 값 출력, 아니면 -1 출력
}
Node{ // 가중치가 있는 그래프를 담기 위한 클래스 별도 구현
	node(가리키는 노드)
	cost(에지의 가중치)
	우선순위 큐 정렬 기준을 위해 compareTo 함수 구현
}
```
- 코드 구현

### 5. 벨만-포드
>[!벨만-포드(bellman-ford-moore)]
>벨만-포드 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같다.

| 기능                              | 특징                                                              | 시간 복잡도(V: 노드수, E: 에지수) |
| --------------------------------------- | --------------------------------------------------------- | ---------------------- |
| 특정 출발 노드에서 다른 모든 노드까지의 최단 경로 탐색 | - 음수 가중치 에지가 있어도 수행할 수 있음<br>- 전체 그래프에서 음수 사이클의 존재 여부를 판단할 수 있음 | O(VE)                  |
##### 벨만-포드의 핵심 이론
1. 에지 리스트로 그래프를 구현하고 최단 경로 배열 초기화하기
	- 벨만포드 알고리즘은 에지를 중심으로 동작하므로 그래프를 에지 리스트로 구현한다.
	-  최단 경로 배열은 출발 노드는 0, 나머지 노드는 무한대로 초기화한다.
2. 모든 에지를 확인해 정답 배열 업데이트하기
	-  최단 거리 배열에서 업데이트 반복 횟수는 노드 개수 -1이다. 노드 개수가 N이고, 음수 사이클이 없을 때 특정 두 노드의 최단 거리를 구성할 수 있는 에지의 최대 개수는 N-1이기 때문이다.
	-  특정 에지 E = (s, e, w)에서 다음 조건을 만족하면 업데이트를 진행한다.
		-  **업데이트 조건과 방법**
			-  **D[s] != ∞ 이며 D[e] > D[s] + w일 때 D[e] = D[s] + w로 배열의 값을 업데이트한다.**
	- 음수 사이클이 없을 때 N-1번 에지 사용 횟수를 반복하면 출발 노드와 모든 노드 간의 최단거리를 알려 주는 정답 배열이 완성된다.
3. 음수 사이클 유무 확인하기
	- 음수 사이클 유무를 확인하기 위해 모든 에지를 한 번씩 다시 사용해 업데이트 되는 노드가 발생하는지 확인한다.
	- 업데이트 되는 노드가 있다면 음수 사이클이 있다는 뜻이 되고, 2단계에서 도출한 정답 배열이 무의미하고 최단 거리를 찾을 수 없는 그래프라는 뜻이 된다.
	- 음수 사이클이 존재하면 이 사이클을 무한하게 돌수록 가중치가 계속 감소하므로 최단 거리를 구할 수 없다.
실제 알고리듬 코딩 테스트에서는 벨만-포드 알고리즘을 사용해 최단 거리를 구하는 문제보다 음수 사이클을 판별하는 문제가 더 빈번하게 출제된다.

##### 문제 059 타임머신으로 빨리 가기 (백준 11657)
- 문제 분석
	- 시작점에서 다른 노드와 관련된 최단 거리를 구하는데, 에지가 음수가 가능할 때는 벨만-포드 알고리즘을 사용한다.
- 손으로 풀어보기
	1. 에지 리스트에 에지 데이터를 저장한 후 거리 배열을 초기화한다. 최초 시작점에 해당하는 거리 배열값은 0으로 초기화한다.
	2. **벨만-포드 알고리즘을 수행한다.**
		1. 모든 에지와 관련된 정보를 가져온 후 다음 조건에 따라 거리 배열의 값을 업데이트 한다.
			- 출발 노드가 방문한 적이 없는 노드(출발 노드 거리 == INF)일 때 거리 배열의 값을 업데이트하지 않는다.
			- 출발 노드의 거리 배열값 + 에지 가중치 < 종료 노드의 거리 배열값일 때 종료 노드의 거리 배열값을 업데이트한다.
		2. '노드 개수 - 1'번만큼 1을 반복한다.
		3. 음수 사이클 유무를 알기 위해 모든 에지에 관해 다시 한번 1을 수행한다. 이때 한 번이라도 값이 업데이트 되면 음수 사이클이 존재한다고 판단한다.
- 수도코드 작성하기
```java
자료구조 선언하기(그래프 정보 저장, 최단 거리 저장)
N(노드 개수)
M(에지 개수)
Edges(에지 리스트 배열)
거리 배열은 충분히 큰 수로 초기화
for(에지 개수){
	에지 리스트 배열에 이 에지 정보를 저장
}
// 벨만-포드 알고리즘 수행
거래 배열에 출발 노드 0으로 초기화
for(노드 개수 - 1){
	for(에지 개수){
		현재 에지 데이터 가져오기
		if(출발 노드가 무한대가 아닌 종료 노드값 < 출발 노드값 + 에지 가중치){
			업데이트 수행 -> 종료 노드값 = 출발 노드값 + 에지 가중치
		}
	}
}
for(에지 개수){ // 음수 사이클 존재 여부 확인
	현재 에지 데이터 가져오기
	if(출발 노드가 무한대가 아닌 종료 노드값 < 출발 노드값 + 에지 가중치){
		업데이트 가능 -> 음수 사이클 존재
	}
}
음수 사이클 미존재 -> 거리 배열 출력(단, 거리 배열의 값이 무한대일 때 -1 출력)
음수 사이클 존재 -> -1 출력
// 에지를 담기 위한 클래스 별도 구현
Edge{
	start(출발 노드)
	end(종료 노드)
	value(가중치)
}
```
- 코드 구현하기

### 06. 플로이드-워셜
>[!플로이드-워셜(floyd-warshall)]
>플로이드-워셜 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같다.

| 기능                | 특징                                                      | 시간 복잡도(V: 노드수) |
| ----------------- | ------------------------------------------------------- | -------------- |
| 모든 노드 간에 최단 경로 탐색 | - 음수 가중치 에지가 있어도 수행할 수 있음<br>- 동적 계획법의 원리를 이용해 알고리즘에 접근 | O(V^3)         |
##### 플로이드-워셜의 핵심 이론
- 플로이드-워셜 알고리즘을 도출하는 가장 핵심적인 원리는 A 노드에서 B 노드까지 최단 경로를 구했다고 가정했을 때 최단 경로 위에 K 노드가 존재한다면 그것을 이루는 부분 경로 역시 최단 경로라는 것이다.
- **도출한 플로이드-워셜 점화식**
	- D\[S\]\[E\] = Math.min(D\[S\]\[E\], D\[S]\[K] + D\[K]\[E])
- **플로이드-워셜 알고리즘 구현 방법**
	1. 배열을 선언하고 초기화하기
		- D\[S]\[E]는 노드 S에서 노드 E까지의 최단 거리를 저장하는 배열이라 정의합니다.
		- S와 E의 값이 같은 칸은 0, 다른 칸은 ∞로 초기화 합니다. S == E는 자기 자신에게 가는 데 걸리는 최단 경로값을 의미하기 때문이다.
	2. 최단 거리 배열에 그래프 데이터 저장하기
		- 에지의 가중치는 W라고 했을 때 D\[S]\[E] = W로 에지의 정보를 배열에 입력한다.
		- 이로써 플로이드-워셜 알고리즘은 그래프를 인접 행렬로 표현한다는 것을 알 수 있다.
	3. 점화식으로 배열 업데이트하기
		- **플로이드-워셜 알고리즘 로직**
```java
		for 경유지 K에 관해 (1 ~ N) // N: 노드 개수
			for 출발 노드 S에 관해 (1 ~ N)
				for 도착 노드 E에 관해 (1 ~ N)
				D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E]
```
			  
- 플로이드-워셜 알고리즘은 모든 노드 간의 최단 거리를 확인해 주기 때문에 시간 복잡도가 O(V^3)으로 빠르지 않은 편이다. 따라서 플로이드-워셜 알고리즘을 사용해야 하는 문제가 나오면 일반적으로 노드의 개수 범위가 다른 그래프에 비해 적게 나타나는 것을 알 수 있다.

##### 문제 061 가장 빠른 버스 노선 구하기 (백준 11404)
- 문제 분석
	- 모든 도시에 쌍과 관련된 최솟값을 찾아야 하는 문제이다. 그래프에서 시작점을 지정하지 않고, 모든 노드와 관련된 최소 경로를 구하는 알고리즘이 바로 플로이드-워셜 알고리즘이다.
- 손으로 풀어보기
	1. 버스 비용 정보를 인접 행렬에 저장한다. 먼저 인접 행렬을 초기화하고 연결 도시가 같으면 0, 아니면 충분히 큰 수로 값을 초기화 한다. 그리고 주어진 버스 비용 데이터값을 인접 행렬에 저장한다.
	2. 플로이드-워셜 알고리즘을 수행한다.
		- `Math.min(distance[S][E], distance[S][K] + distance[K][E])`
	3. 알고리즘으로 변경된 인접 행렬을 출력한다. 인접 행렬 자체가 모든 쌍의 최단 경로를 나타내는 정답 배열이다. 정답 배열을 그대로 출력하되, 문제의 요구사항에 따라 두 도시가 도달하지 못할 때(∞)는 0, 아닐 때는 배열의 값을 출력한다.
- 수도코드 작성하기
- 코드 구현하기

### 7. 최소 신장 트리
>[!최소 신장 트리(minimum spanning tree]
>최소 신장 트리란 그래프에서 모든 노드를 연결할 때 사용된 에지들의 가중치의 합을 최소로 하는 트리입니다.

##### 최소 신장 트리의 특징
- 사이클이 포함되면 가중치의 합이 최소가 될 수 없으므로 사이클을 포함하지 않는다.
- N개의 노드가 있으면 최소 신장 트리를 구성하는 에지의 개수는 항상 N - 1개다.
##### 최소 신장 트리의 핵심 이론
1. 에지 리스트로 그래프를 구현하고 유니온 파인드 배열 초기화하기
2. 그래프 데이터를 가중치 기준으로 정렬하기
3. 가중치가 낮은 에지부터 연결 시도하기 (유니온-파인드 알고리즘 사용)
4. 전체 노드의 개수가 N개이면 연결한 에지의 개수가 N - 1이 될 때까지 과정 3을 반복한다.
5. 총 에지 비용 출력하기

##### 문제 064 최소 신장 트리 구하기 (백준 1197)
- 문제 분석
	- 최소 신장 트리를 구하는 가장 기본적인 문제이다.
- 손으로 풀어보기
	1. 에지 리스트에 에지 정보를 저장한 후 부모 노드 데이터를 초기화한다. 사이클 생성 유무를 판단하기 위한 유니온 파인드용 부모 노드도 초기화한다.
	2. 크루스칼 알고리즘을 수행한다. 사이클이 발생하면 생략하고, 발생하지 않으면 에지값을 더한다.
	3. 과정 2에서 에지를 더한 횟수가 V(노드 개수) - 1이 될 때까지 반복하고, 반복이 끝나면 에지의 가중치를 모두 더한 값을 출력한다.
- 수도코드 작성하기
- 코드 구현하기

