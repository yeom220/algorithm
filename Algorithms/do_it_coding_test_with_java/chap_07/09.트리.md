### 1. 트리 알아보기
>[!트리(tree)]
>트리는 노드와 에지로 연결된 그래프의 특수한 형태로, 주요 특징은 다음과 같다.
>- **트리의 특징**
>	- 순환 구조(cycle)를 지니고 있지 않고, 1개의 루트 노드가 존재한다.
>	- 루트 노드를 제외한 노드는 단 1개의 부모 노드를 갖는다.
>	- 트리의 부분 트리(subtree) 역시 트리의 모든 특징을 따른다.

##### 트리의 핵심 이론
- 트리의 구성 요소

| 구성 요소 | 설명                                |
| ----- | --------------------------------- |
| 노드    | 데이터의 index와 value를 표현하는 요소        |
| 에지    | 노드와 노드의 연결 관계를 나타내는 선             |
| 루트 노드 | 트리에서 가장 상위에 존재하는 노드               |
| 부모 노드 | 두 노드 사이의 관계에서 상위 노드에 해당하는 노드      |
| 자식 노드 | 두 노드 사이의 관계에서 하위 노드에 해당하는 노드      |
| 리프 노드 | 트리에서 가장 하위에 존재하는 노드(자식 노드가 없는 노드) |
| 서브 트리 | 전체 트리에 속한 작은 트리                   |
##### 문제 067 트리의 부모 찾기 (백준 11725)
- 문제 분석
	- 주어지는 데이터가 단순하게 연결돼 있는 두 노드를 알려 주는 것이므로 데이터를 저장할 때 양방향 에지로 간주하고 저장한다.
	- 인접 리스트 자료구조를 사용하면 간편하게 데이터를 저장할 수 있다.
	- 트리의 루트가 1이라고 지정돼 있기 때문에 1번 노드부터 DFS로 탐색하면서 부모 노드를 찾아 준다.
- 손으로 풀어보기
	1. 인접 리스트로 트리 데이터를 구현한다.
	2. DFS 탐색을 수행한다. 수행할 때는 부모 노드의 값을 정답 배열에 저장한다.
	3. 정답 배열의 2번 인덱스부터 값을 차례대로 출력한다.
- 수도코드 작성하기
- 코드 구현하기

### 2. 트라이
>[!트라이(trie)]
>트라이는 문자열 검색을 빠르게 실행할 수 있도록 설계한 트리 형태의 자료구조이다.

##### 트라이의 핵심 이론
- 트라이는 일반적으로 단어들을 사전의 형태로 생성한 후 트리의 부모 자식 노드 관계를 이용해 검색을 수행한다. 트라이 자료구조의 특징은 다음과 같다.
- **트라이의 특징**
	- N진 트리: 문자 종류의 개수에 따라 N이 결정된다. 예를 들어 알파벳은 26개의 문자로 이뤄져 있으므로 26진 트리로 구성된다.
	- 루트 노드는 항상 빈 문자열을 뜻하는 공백 상태를 유지한다.
- 트라이 자료구조 생성 과정
	- 먼저 루트 노드는 공백을 유지하고 apple의 각 알파벳에 해당하는 노드를 생성한다.
	- 다음으로 air를 삽임할 때는 루트 노드에서부터 검색한다. a 노드는 공백 상태가 아니므로 이동하고, i와 r은 공백 상태이므로 신규 노드를 생성한다.
	- apply를 삽입할 때도 검색 노드가 공백 상태이면 신규 노드를 생성하고, 아니면 이동하는 원리로 트라이 자료구조를 구현한다.

##### 문제 069 문자열 찾기 (백준 14425)
- 문제 분석
	- 집합 S에 속해 있는 단어들을 이용해 트라이 구조를 생성하고, 트라이 검색을 이용해 문자열 M개의 포함 여부를 카운트하는 전형적인 트라이 자료구조 문제입니다.
- 손으로 풀어보기
	1. 트라이 자료구조를 생성한다. 현재 문자열을 가리키는 위치의 노드가 공백 상태라면 신규 노드를 생성하고, 아니라면 이동한다. 문자열의 마지막에 도달하면 리프 노드라고 표시한다.
	2. 트라이 자료구조 검색으로 집합 S에 포함된 문자열을 센다. 부모-자식 관계 구조를 이용해 대상 문자열을 검색했을 때 문자열이 끝날 때까지 공백 상태가 없고, 현재 문자의 마지막 노드가 트라이의 리프 노드라면 이 문자를 집합 S에 포함된 문자열로 센다.
- 수도코드 작성하기
- 코드 구현하기

##### 3. 이진 트리
>[!이진 트리(binary tree)]
>이진 트리는 각 노드의 자식 노드(차수)의 개수가 2 이하로 구성돼 있는 트리를 말한다. 트리 영역에서 가장 많이 사용되는 형태이다.
##### 이진 트리의 핵심 이론
- 이진 트리의 종류
	- 편향 이진 트리
		- 노드들이 한쪽으로 편향돼 생성된 이진 트리
	- 포화이진 트리
		- 트리의 높이가 모두 일정하며 리프 노드가 꽉찬 이진 트리
	- 완전이진 트리
		- 마지막 레벨을 제외하고 완전하게 노드들이 채워져 있고, 마지막 레벨은 왼쪽부터 채워진 트리
##### 이진 트리의 순차 표현
- 가장 직관적이면서 편리한 트리 자료구조 형태는 '**배열**'이다.
##### 트리의 노드와 배열의 인덱스 사이 상관 관계
| 이동 목표 노드  | 인덱스 연산                 | 제약 조건(N = 노드개수)    |
| --------- | ---------------------- | ------------------ |
| 루트 노드     | index = 1              |                    |
| 부모 노드     | index = index / 2      | 현재 노드가 루트 노드가 아님   |
| 왼쪽 자식 노드  | index = index * 2      | index \* 2 ≤ N     |
| 오른쪽 자식 노드 | index = index \* 2 + 1 | index \* 2 + 1 ≤ N |
- 위의 인덱스 연산 방식은 향후 세그먼트 트리(segment tree)나 LCA(lowest common ancestor) 알고리즘에서도 기본이 되는 연산이다.

##### 문제 070 트리 순회하기 (백준 1991)
- 문제 분석
	- 요구하는 자료구조 형태만 충실히 구현하면 되는 문제이다.
	- 주어진 입력값을 트리 형태의 자료구조에 적절하게 저장하고, 그 안에서 탐색을 수행하는 로직을 구현한다.
	- 클래스로 노드를 구현하는 방식, 2차원 배열로 구현하는 방식 등 다양한 방법으로 해결할 수 있다. 여기서는 2차원 배열을 이용해 구현한다.
- 손으로 풀어보기
	1. 2차원 배열에 트리 데이터를 저장한다.
	2. 전위 순회 함수를 구현한다.
		- 전위 순회 순서: 현재 노드 -> 왼쪽 노드 -> 오른쪽 노드 순서로 탐색
		- 중위 순회 순서: 왼쪽 노드 -> 현재 노드 -> 오른쪽 노드 순서로 탐색
		- 후위 순회 순서: 왼쪽 노드 -> 오른쪽 노드 -> 현재 노드 순서로 탐색
- 수도코드 작성하기
- 코드 구현하기

### 3. 세그먼트 트리
>[!세그먼트 트리]
>주어진 데이터들의 구간 합과 데이터 업데이트를 빠르게 수행하기 위해 고안해낸 자료구조의 형태가 세그먼트 트리이다. 더 큰 범위는 '인덱스 트리'라고 불리는데, 코딩 테스트 영역에서는 큰 차이가 없다.

##### 세그먼트 트리의 핵심 이론
1. 트리 초기화하기
	1. 리프 노드의 개수가 데이터의 개수(N) 이상이 되도록 트리 배열을 만든다. 트리 배열의 크기를 구하는 방법은 `2^k ≥ N`을 만족하는 k의 최솟값을 구한 후 `2^k * 2`를 트리 배열의 크기로 정의하면 된다. `예시: N = 8, 2^3 ≥ 8이므로 배열의 크기를 2^3 * 2 = 16으로 한다.`
	2. 리프 노드에 원본 데이터를 입력한다. 이때 리프 노드의 시작 위치를 트리 배열의 인덱스로 구해야 하는데, 구하는 방식은 `2^k`를 시작 인덱스로 취하면 된다. `예시: k = 3, start index = 8`
	3. 리프 노드를 제외한 나머지 노드의 값을 채운다. (`인덱스 2^k - 1부터 1번 쪽으로 채운다.`) 채워야 하는 인덱스가 N이라고 가정하면 자신의 자식 노드를 이용해 해당 값을 채울 수 있다. 자식 노드의 인덱스는 이진 트리 형식이기 때문에 `2N, 2N + 1`이 된다.
```java
// 각 케이스 별 계산식
A[N] = A[2N] + A[2N + 1]; // 구간 합
A[N] = Math.max(A[2N], A[2N + 1]); // 최대
A[N] = Math.min(A[2N], A[2N + 1]); // 최소
```

2. 질의 값 구하기
	1. 주어진 질의 인덱스를 세그먼트 트리의 리프 노드에 해당하는 인덱스로 변경한다. 기존 샘플을 기준으로 한 인덱스값과 세그먼트 트리 배열에서의 인덱스값이 다르기 때문에 인덱스를 변경해야 한다. 인덱스 변경 방법은 다음과 같다.
	   **질의 인덱스를 세그먼트 트리 인덱스로 변경하는 방법**
	   `세그먼트 트리 index = 주어진 질의 index + 2^k - 1`
	   **질의값 구하는 과정**
	   1. `start_index % 2 == 1일 때 해당 노드를 선택한다.`
	   2. `end_index % 2 == 0일 때 해당 노드를 선택한다.`
	   3. `1~2에서 노드를 선택하지 않았다면 start_index = (start_index + 1) / 2 연산을 실행한다.`
	   4. `1~2에서 노드를 선택하지 않았다면 end_index = (end_index - 1) / 2 연산을 실행한다.`
	   5. `1~4를 반복하다가 end_index < start_index가 되면 종료한다.`
	**질의에 해당하는 노드 선택 방법**
	1. 구간 합: 선택된 노드들을 모두 더한다.
	2. 최댓값 구하기: 선택된 노드들 중 MAX값을 선택해 출력한다.
	3. 최솟값 구하기: 선택된 노드들 중 MIN값을 선택해 출력한다.
3. 데이터 업데이트 하기
	- 업데이트 방식은 자신의 부모 노드로 이동하면서 업데이트한다는 것은 동일하지만, 어떤 값으로 업데이트할 것인지에 관해서는 트리 타입별로 조금 다르다.
	- 구간 합에서는 원래 데이터와 변경 데이터의 차이만큼 부모 노드로 올라가면서 변경한다.
	- 최댓값 찾기에서는 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해서 더 큰 값으로 업데이트 한다. 업데이트가 일어나지 않으면 종료한다.
	- 최솟값 찾기에서는 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해 더 작은 값으로 업데이트 한다. 업데이트가 일어나지 않으면 종료한다.

##### 문제 071 구간 합 구하기 3 (백준 2042)
- 문제 분석
	- 이 문제는 수의 변경이 빈번히 일어나는 상황이 존재하여 합 배열로 풀 수 없다.
	- 합 배열은 자료구조의 특성상 데이터 변경에 시간이 오래 걸리는 단점이 있다.
	- 이 문제는 데이터의 변경에도 시간이 비교적 적게 걸리는 세그먼트 트리 자료구조를 이용한다.
- 손으로 풀어보기
	1. 1차원 배열을 이용해 트리의 값을 초기화한다. 트리 배열의 크기가 N = 5 이므로 2^k > N을 만족하는 k의 값은 3이고, 배열의 크기는 2^3 \* 2 = 16이 된다. 시작 인덱스는 2^3 = 8이 된다.
	2. 질의값 연산 함수와 데이터 업데이트 함수를 수행하고, 질의와 관련된 결괏값을 출력한다.
- 수도코드 작성하기
- 코드 구현하기

### 5. 최소 공통 조상
>[!최소 공통 조상(LCA: lowest common ancestor)]
>트리 그래프에서 임의의 두 노드를 선택했을 때 두 노드가 각각 자신을 포함해 거슬러 올라가면서 부모 노드를 탐색할 때 처음 공통으로 만나게 되는 부모 노드를 '최소 공통 조상'이라고 한다.

##### 최소 공통 조상의 핵심 이론
- 일반적인 최소 공통 조상 구하기
	- 트리의 높이가 크지 않을 때 최소 공통 조상을 구하는 방법
	- 루트 노드에서 탐색을 시작해 각 노드의 부모 노드와 깊이를 저장한다.(DFS 또는 BFS 수행)
	- 선택된 두 노드의 깊이가 다른 경우, 더 깊은 노드를 부모 노드로 1개씩 올려 주면서 같은 깊이로 맞춘다. 이때 두 노드가 같으면 해당 노드가 최소 공통 조상이므로 탐색을 종료한다.
	- 깊이가 같은 상태에서는 동시에 부모 노드로 올라가면서 두 노드가 같은 노드가 될 때가지 반복한다. 이때 처음 만나는 노드가 최소 공통 조상이 된다.
	- 위의 방식을 이용하면 최소 공통 조상을 구할 수 있지만, 트리의 높이가 커질 경우, 시간 제약 문제에 직면할 수 있다.
- 최소 공통 조상 빠르게 구하기
	- '최소 공통 조상 빠르게 구하기'의 핵심은 서로의 깊이를 맞춰 주거나 같아지는 노드를 찾을 때 기존에 한 단계씩 올려 주는 방식에서 2^k씩 올라가 비교하는 방식이다. 따라서 기존에 자신의 부모 노드만 저장해 놓던 방식에서 2^k번째 위치의 부모 노드까지 저장해 둬야 한다.
	- **최소 공통 조상 빠르게 구하기의 3단계**
		- **1) 부모 노드 저장 배열 만들기**
			- 부모 노드 배열을 만들기 위해서는 이 배열의 정의와 점화식을 학습해야 한다.
			- **부모 노드 배열의 정의**
			  `P[K][N] = N번 노드의 2^k번째 부모의 노드 번호`
			- **부모 노드 배열의 점화식**
			  `P[K][N] = P[K - 1][P[K - 1][N]]`
			- 점화식에서 N의 2^k번째 부모 노드는 N의 2^k-1번재 부모 노드의 2^k-1번째 부모 노드라는 의미이다.
			- 즉, K = 4라고 가정하면 N의 16번째 부모 노드는 N의 8번째 부모 노드의 8번째 부모 노드라는 뜻이다.
			- 배열에서 K는 '트리의 깊이 > 2^k'를 만족하는 최댓값이다.
		- **2) 선택된 두 노드의 깊이 맞추기**
			- P배열을 이용해 기존에 한 단계씩 맞췄던 깊이를 2^k 단위로 넘어가면서 맞춘다.
			- 만약 높이 차이가 20라고 가정하면 2^k ≤ 20을 만족하면서 k가 최대가 되는 만큼 이동하면서 높이 차이가 0이 될 때까지 반복한다. 즉, 높이 차이가 20일 경우에는 2^4(20) -> 2^2(4)와 같이 두 번 이동하면 된다.
		- **3) 최소 공통 조상 찾기**
			- 공통 조상을 찾는 작업 역시 2^k 단위로 점프하면서 맞춘다.
			- k값을 1씩 감소하면서 P배열을 이용해 최초로 두 노드의 부모가 달라지는 값을 찾는다.
			- 최초로 달라지는 K에 대한 두 노드의 부모 노드를 찾아 이동한다. 이를 K가 0이 될 때까지 반복한다.
			- 반복문이 종료된 후 이동한 2개의 노드가 같은 노드라면 해당 노드가, 다른 노드라면 바로 위의 부모 노드가 최소 공통 조상이 된다.

##### 문제 075 최소 공통 조상 구하기 2 (백준 11438)
- 문제 분석
	- 기존 LCA 문제보다 노드의 개수와 질의의 개수가 매우 커진 것을 확인할 수 있다. 때문에 '최소 공통 조상 구하기' 방식으로 이 문제를 구현하면 시간 초과가 발생한다.
	- '제곱근 형태를 이용한 빠르게 최소 공통 조상을 구하기' 방식으로 이 문제를 해결해 본다.
- 손으로 풀어보기
	1. 인접 리스트로 트리 데이터를 구현한다.
	2. 탐색 알고리즘(DFS, BFS)을 이용해 각 노드의 깊이를 구한다.
	3. 점화식을 이용해 Parent 배열(부모 노드 배열)을 구한다.
	4. 깊이가 큰 노드는 Parent 배열을 이용해 2^k 만큼 빠르게 이동시켜 깊이를 맞춘다. 깊이가 2만큼 차이(2^1)가 나므로 15번 노드를 15의 2^1번째 부모 노드인 5로 변경해 깊이를 맞춘다. 한 칸씩 오르는 것이 아닌 2의 제곱수로 빠르게 올라간다.
	5. 부모 노드로 올라가면서 최소 공통 조상을 찾는다. Parent 배열을 이용해 2^k 만큼 넘어가면서 찾는다. k는 depth의 최댓값에서 1씩 감소한다.
- 수도코드 작성하기
- 코드 구현하기