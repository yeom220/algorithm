>[!최단 경로 문제]
>최단 경로 문제는 각 간선의 가중치 합이 최소가 되는 두 정점(또는 노드) 사이의 경로를 찾는 문제다.

최단 경로는 지도 상의 한 지점에서 다른 지점으로 갈 때 가장 빠른 길을 찾는 것과 비슷한 문제다. 쉽게 말해 내비게이션에서 목적지로 이동할 때, 경로 탐색을 하면 나오는 최적의 경로 문제가 바로 최소 비용이 되는 최단 경로 문제다. 정점(Vertex)은 교차로에 해당하고 간선(Edge)은 길에 해당한다. 가중치(Weight)는 거리나 시간과 같은 이동 비용에 해당한다. 이처럼 잘 알려지고 직관적인 문제에는 단 하나의 가장 좋은 풀이 알고리즘이 있을 거라고 생각하기 쉽다. 하지만 실제로는 그래프의 종류와 특성에 따라 각각 최적화된 다양한 최단 경로 알고리즘이 존재한다. 이 중에서 아마 가장 유명한 것은 다익스트라(Dijkstra) 알고리즘일 것이다. 오컴의 면도날(Occam's Razor)처럼 단순한 알고리즘이 가장 훌륭한 알고리즘이라는 걸 증명하는 대표적인 알고리즘이기도 하다.
>[!참고] 오컴의 면도날
>어떤 현상을 설명할 때 필요 이상의 가정과 개념들은 면도날로 베어낼 필요가 있다는 권고로 쓰인다.

다익스트라 알고리즘은 항상 노드 주변의 최단 경로만을 택하는 대표적인 그리디(Greedy) 알고리즘 중 하나로, 단순할 뿐만 아니라 실행 속도 또한 빠르다. 다익스트라 알고리즘은 노드 주변을 탐색할 때 BFS를 이용하는 대표적인 알고리즘이기도 하다.
DFS는 한 사람이 미로를 찾아 헤매는 과정과 비슷한 반면, BFS는 여러명의 사람이 각기 서로 다른 갈림길로 흩어져서 길을 찾는 것과 비슷하다. 이때 각자 실뭉치를 가지고 풀어 놓았다가 되감으면서 새로운 길을 탐색한다. 길을 따라가다 갈림길이 나오면 사람들을 나눠 다시 각자 새로운 길을 탐색하고, 다시 갈림길을 만나 새로 탐색할 길이 하나로 모이면, 나뉘어 탐색하던 사람들이 다시 모여서 함께 탐색한다. 다익스트라 알고리즘은 이때 먼저 도착한 사람의 실뭉치를 사용한다. 하지만 가중치가 음수인 경우는 처리할 수 없다.
다익스트라 알고리즘은 임의의 정점을 출발 집합에 더할 때, 그 정점까지의 최단거리는 계산이 끝났다는 확신을 갖고 더한다. 만일 이후에 더 짧은 경로가 존재한다면 다익스트라 알고리즘의 논리적 기반이 무너진다. 이때는 모두 값을 더해서 양수로 변환하는 방법이 있으며, 이마저도 어렵다면 벨만-포드(Bellman-Ford) 알고리즘 같은, 음수 가중치를 계산할 수 있는 다른 알고리즘을 사용해야 한다. 같은 이유로 최장 거리를 구하는 데는 다익스트라 알고리즘을 사용할 수 없다.
다익스트라의 최초 구현에서는 시간 복잡도가 *O(V^2)* 였으나 현재는 BFS시 가장 가까운 순서를 찾을 때 우선순위 큐를 적용하여 이 경우 시간 복잡도는 *O((V+E) log V)*, 모든 정점이 출발지에서 도달이 가능하다면 최종적으로 *O(E log V)* 가 된다.

---
### 40. 네트워크 딜레이 타임
>K부터 출발해 모든 노드가 신호를 받을 수 있는 시간을 계산하라. 불가능할 경우 -1을 리턴한다. 입력값 (u, v, w)는 각각 출발지, 도착지, 소요 시간으로 구성되며, 전체 노드의 개수는 N으로 입력받는다.

###### 1. 다익스트라 알고리즘 구현
이 문제에서는 다음과 같은 2가지 사항을 판별해야 한다.
1. 모든 노드가 신호를 받는 데 걸리는 시간
2. 모든 노드에 도달할 수 있는지 여부

우선 첫 번째로 판별해야 하는, 모든 노드가 신호를 받는 데 걸리는 시간이란, 가장 오래 걸리는 노드까지의 시간이라 할 수 있다. 즉 가장 오래 걸리는 노드까지의 최단 시간을 말하며, 이는 앞서 설명한 다익스트라 알고리즘으로 추출할 수 있다. 여기서는 다익스트라 알고리즘을 직접 구현해본다.
두 번째로 모든 노드에 도달할 수 있는지 여부다. 이는 모든 노드의 다익스트라 알고리즘 계산 값이 존재하는지 유무로 판별할 수 있다. 만약 노드가 8개인데 다익스트라 알고리즘 계산은 7개밖에 할 수 없다면, 나머지 한 노드에는 도달할 수 없다는 의미다. 이 경우 모든 노드에 도달할 수 없는 경우미으로 -1을 리턴한다.
다익스트라 알고리즘을 좀 더 효율적으로 구현하기 위해 우선순위 큐를 적용하는 방식을 사용한다. 여기서는 구체적으로 파이썬에서 우선순위 큐를 최소 힙(Min Heap)으로 구현한 모듈인 `heapq`를 사용하는 형태로 구현해본다. 위키피디아에 공개되어 있는, 우선순위 큐를 이용한 다익스트라 알고리즘 수도코드를 살펴본다. 그리고 이와 동일한 알고리즘으로 실제로 실행되는 파이썬 코드로 구현해본다.
```python
# 다익스트라 알고리즘 수도코드
function Dijkstra(Graph, source):
	dist[source] <- 0

	create vertex priority queue Q

	for each vertex v in Graph:
		if v != source
			dist[v] <- INFINITY
			prev[v] <- UNDEFINED

		Q.add_with_priority(v, dist[v])
	
	while Q is not empty:
		u <- Q.extract_min()
		for each neighbor v of u:
			alt <- dist[u] + length(u, v)
			if alt < dist[v]
				dist[v] <- alt
				prev[v] <- u
				Q.decrease_priority(v, alt)
	
	return dist, prev
```

그래프에서 각 정점과 거리를 우선순위 큐에 삽입하는 부분 `Q.add_with_priority(v, dist[v])`, 그리고 우선순위 큐에서 최소 값 추출(`u <- Q.extract_min()`)을 통해 이웃을 살펴보는 (`for each neighbor v of u`) 수도코드를 확인할 수 있다. 이제 이 수도코드 알고리즘을 실제로 실행 가능한 파이썬 코드로 구현해본다. 먼저, 다음과 같이 그래프부터 구성한다.
```python
graph = collections.defaultdict(list)
for u, v, w in times:
	graph[u].append((v, w))
```

위키피디아의 수도코드는 이미 그래프가 구성된 상태라 가정하고 입력값을 받았지만, 이 문제에서 입력값은 `(u, v, w)` 아이템 목록으로 구성된 리스트 형태며, 이를 키/값 구조로 조회할 수 있는 그래프 구조(파이썬에서는 딕셔너리로 구현하는 인접 리스트)는 아니다. 따라서 먼저 그래프를 인접 리스트로 표현하는 딕셔너리부터 만들어준다. 딕셔너리 생성을 쉽게 하기 위해 존재 유무를 판별하지 않아도 항상 디폴트로 생성해주는 `collections.defaultdict`를 활용했다. 다음은 우선순위 큐를 위한 큐 변수를 정의한다.
```python
Q = [(0, K)]
dist = collections.defaultdict(int)
```

큐 변수 `Q`는 '(소요 시간, 정점)' 구조로 구성한다. 즉 시작점에서 '정점'까지의 소요 시간을 담아둘 것이다. 초깃값은 시작점 K부터이므로, 소요 시간은 0이고, 따라서 `(0, K)`가 된다. 거리를 의미하는 `dist` 변수는 아직 아무것도 셋팅하지 않는다. 수도코드를 그대로 구현했다고 했지만 `dist` 의 초깃값을 무한대로 모두 설정해두는 것과 달리, 우리의 파이썬 구현은 조금 다르다. 우선순위 큐 구현에 사용한 `heapq` 모듈의 기능상 제약 때문이다.
수도코드에는 큐에 `add_with_priority(), decrease_priority(), extract_min()`, 3번의 연산을 내리도록 구현되어 있다. 여기서 `add_with_priority()`와 `extract_min()`은 문제없지만 `decrease_priority()`가 문제다. 이 연산은 수도코드에서 우선순위를 조정하라는 의미로 쓰였는데, 우리가 사용하는 `heapq` 모듈은 우선순위 업데이트를 지원하지 않기 때문이다. 우선순위를 업데이트하려면 먼저 해당되는 키를 찾아야 하고 이는 결국 *O(n)* 시간 복잡도가 필요한 일로, `heapq` 모듈은 이 기능을 지원하지 않는다. 따라서 여기서는 수도코드를 최대한 비슷하게 구현하되, `decrease_priority()` 연산이 필요 없도록 다음과 같이 알고리즘을 살짝 변경해 구현해본다.
```python
while Q:
	time, node = heqpq.heqppop(Q)
	if node not in dist:
		dist[node] = time
		for v, w in graph[node]:
			alt = time + w
			heapq.heappush(Q, (alt, v))
```

큐 순회를 시작하자마자 최솟값을 추출하는 건 수도코드와 동일한다. 그러나 바로 for each 구문으로 이웃 노드를 순회했던 수도코드와 달리, 그 작업은 잠시 뒤에 진행하고, 먼저 dist에 node의 포함 여부부터 체크한다. 수도코드는 dist를 이미 무한대 값으로 채우고 시작했지만, 우리는 dist에 아무 값도 셋팅하지 않았기 때문에 처음에는 이 값이 비어 있을 것이고, 이 경우에만 힙에 푸시하는 형태로 조금 다르게 구현할 것이다. 이렇게 하면 큐의 우선순위를 업데이트할 필요 없이 존재 유무로만 진행할 수 있으며, dist에는 항상 최솟값이 셋팅될 것이다.
가장 먼저 입력되었던 경로가 최단 경로이며, 이후에 삽입되는 경로은 이보다 더 오래 걸리므로 모두 버린다. 마지막으로 모든 노드에 도달할 수 있는지 여부를 다음과 같이 판별한다.
```python
if len(dist) == N:
	return max(dist.values())
return -1
```

여기서는 `dist` 딕셔너리의 키 개수가 N과 동일한지 체크한다. 전체 노드 개수만큼이 모두 `dist`에 있다면 모든 노드의 최단 경로를 구했다는 의미고, 이는 모두 시작점에서 도달이 가능하다는 의미기도 하다. 만약 노드 개수가 하나라도 모자란다면 그 노드는 시작점에서 도달할 수 없다는 뜻이며, 앞서 2가지 판별 조건 중 두 번째 조건을 만족할 수 없기 때문에 -1을 리턴한다.

위키피디아의 수도코드를 참고해서 파이썬에 적합하도록 알고리즘을 살짝 변경하여 효율적으로 다익스트라 알고리즘 구현을 마무리해봤다. 참고로 수도코드의 변수 중 `prev[u]`는 이전 노드의 값이다. 이 문제는 이전 노드가 무엇인지 여부는 전혀 필요하지 않기 때문에 구현에서 제외했다.
이 파이썬 코드는 로버트 세지웍이 저술한 "알고리즘 개정4판"의 4장, '그래프'에서 최단 경로 BFS를 구현한 자바 코드와도 거의 일치한다. 소요 시간의 기입 유무 차이 정도만 있을 뿐이다.

----
