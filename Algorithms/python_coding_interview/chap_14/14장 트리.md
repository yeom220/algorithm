>[!트리] 트리
>트리는 계층형 트리 구조를 시뮬레이션 하는 추상 자료형(ADT)으로, 루트 값과 부모-자식 관계의 서브트리로 구성되며, 서로 연결된 노드의 집합니다.

중요한 트리의 속성 중 하나는 재귀로 정의된(Recursively Defined) 자기 참조(Self-Referential) 자료구조라는 점이다. 쉽게 말하면, 트리는 자식도 트리고 또 그 자식도 트리다. 즉 여러 개의 트리가 쌓아 올려져 큰 트리가 된다. 흔히 서브트리(Subtrees)로 구성된다고 표현하는데, 앞서 트리에 대한 위키피디아의 정의에도 서브트리라는 용어가 등장한다. 이러한 재귀적 특성 때문에 441페이지에서 살펴보게 될 순회에서도 트리에서는 재귀 순회가 좀 더 자연스러운 편이다.


### 트리의 각 명칭
트리는 항상 루트(Root)에서부터 시작된다. 루트는 자식(Child) 노드를 가지며, 간선(Edge)으로 연결되어 있다. 자식 노드의 개수는  차수(Degree)라고 하며, 크기(Size)는 자신을 포함한 모든 자식 노드의 개수다. 높이(Height)는 현재 위치에서부터 리프(Leaf)까지의 거리, 깊이(Depth)는 루트에서부터 현재 노드까지의 거리다. 트리는 그 자식도 트리인 서브트리 구성을 띤다고 앞서 언급한 바 있다.
레벨(Level)은 0에서부터 시작한다. 논문에 따라 1에서부터 시작하는 경우도 있으나 현재 대부분의 문서에서는 0에서부터 시작하는 것이 좀 더 일반적이며 여기서도 0부터 시작한다. 트리는 항상 단방향(Uni-Directional)이기 때문에, 간선의 화살표는 생략 가능하다. 일반적으로 방향은 위에서 아래로 향한다.


### 그래프 vs 트리
그래프와 트리의 차이점은 무엇일까? 가장 두드러지는 큰 차이점은 다음과 같다. 
*"트리는 순환 구조를 갖지 않는 그래프"*
핵심은 순환 구조(Cyclic)이 아니라는 데 있다. 트리는 특수한 형태의 그래프의 일종이며, 크게 그래프의 범주에 포함된다. 하지만 트리는 그래프와 달리 어떠한 경우에도 한번 연결된 노드가 다시 연결되는 법이 없다. 이외에도 단방향(Uni-Directional), 양방향(Bi-Directional)을 모두 가리킬 수 있는 그래프와 달리, 트리는 부모 노드에서 자식 노드를 가리키는 단방향 뿐이다. 그뿐만 아니라 트리는 하나의 부모 노드를 갖는다는 차이점이 있으며 루트 또한 하나여야 한다. 이처럼 트리와 그래프는 서로 다른 점이 많다.

**트리가 아닌 예**
1. 순환 구조: 트리는 순환 구조를 갖지 않아야 한다.
2. 부모 노드: 부모 노드는 단 하나여야 한다.
3. 여러개의 그래프: A->B, D<-C->E가 서로 연결되어 있지 않으며, 루트가 둘이므로 트리가 아니다. 루트 또한 하나여야 한다.


### 이진트리
트리 중에서도 가장 널리 사용되는 트리 자료구조는 이진 트리와 이진 탐색 트리(Binary Search Tree)(이하 BST)다. 실제로 인터뷰 시에도 가장 자주 질문을 받게 되는 기본적인 트리 형태이기도 하다. 먼저, 각 노드가 m개 이하의 자식을 갖고 있으면, m-ary 트리(다항 트리, 다진 트리)라고 한다. 여기서 `m=2`일 경우, 즉 **모든 노드의 차수가 2 이하일 때는 특별히 이진 트리(Binary Tree)** 라고 구분해서 부른다. 이진 트리는 왼쪽, 오른쪽, 최대 2개의 자식을 갖는 매우 단순한 형태로, 다진 트리에 비해 훨씬 간결할 뿐만 아니라 여러 가지 알고리즘을 구현하는 일도 좀 더 간단하게 처리할 수 있어서, 대체로 트리라고 하면 특별한 경우가 아니고서는 대부분 이진 트리를 일컫는다.
이제 이진 트리 유형(Types of Binary Trees)을 살펴본다.
- 정 이진 트리(Full Binary Tree): 모든 노드가 0개 또는 2개의 자식 노드를 갖는다.
- 완전 이진 트리(Complete Binary Tree): 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며 마지막 레벨의 모든 노드는 가장 왼쪽부터 채워져 있다.
- 포화 이진 트리(Perfect Binary Tree): 모든 노드가 2개의 자식 노드를 갖고 있으며, 모든 리프 노드가 동일한 깊이 또는 레벨을 갖는다. 문자 그대로 가장 완벽한 유형의 트리다.

----
### 42. 이진 트리의 최대 깊이
>이진 트리의 최대 깊이를 구하라.

###### 1. 반복 구조로 BFS 풀이
깊이는 어떻게 측정할 수 있을까? 여러 가지 방법이 있겠지만 여기서는 BFS(너비 우선 탐색)로 풀이해보겠다. 아울러 BFS는 재귀가 아닌 반복 구조로 풀이할 수 있다. DFS는 스택, BFS는 큐를 사용하여 구현한다. 여기서는 BFS로 풀이할 것이므로, 다음과 같이 큐를 선언하고 풀이할 준비를 한다.
```python
def maxDepth(self, root: TreeNode) -> int:
	...
	queue = collections.deque([root])
	depth = 0

	while queue:
		...
	
	return depth
```

큐를 선언하고 반복 구조도 구성하여, BFS 반복을 이용해 풀이할 구조를 잡았다. 파이썬에서 큐는 일반적인 리스트로도 모든 연산이 가능하지만, 데크 자료형을 사용하면 이중 연결 리스트로 구성되어 있기 때문에 큐와 스택 연산을 모두 자유롭게 활용 가능할 뿐만 아니라 양방향 모두 *O(1)* 에 추출할 수 있어 좋은 성능을 보인다는 점을 이미 여러 번 언급한 바 있다. 실제로도 양방향 추출이 빈번할 경우, 리트코드의 실행 속도 또한 데크가 리스트에 비해 훨씬 더 빠르다.
```python
while queue:
	depth += 1
	for _ in range(len(queue)):
		cur_root = queue.popleft()
		...
		if cur_root.has_child():
			queue.append(cur_root.child)
```

큐 변수에는 현재 깊이 `depth`에 해당하는 모든 노드가 들어 있고, `queue.popleft()`로 하나씩 끄집어 내면서 `cur_root.has_child()`로 자식 노드가 있는지 여부를 판별한 후 자식 노드를 다시 큐에 삽입한다. 참고로 여기서 `.has_child()`와 `.child`는 모두 이해를 돕기 위한 수도코드다.
그렇다면 동일한 큐에 삽입하다 보니 행여나 자식 노드가 부모 노드와 섞이진 않을까? 아마 섞일 것이다. 그러나 이 for 반복문에서는 자식 노드가 추출되는 일은 없을 것이다. 왜냐면 처음 for 문 진입 시 부모 노드의 길이 `len(queue)`만큼만 반복하도록 선언했기 때문이다. 따라서 부모 노드가 모두 추출된 이후에는 for 문을 빠져 나가게 되고, 다시 한 바퀴 돌아 `while queue` 구문에서 이번에는 다음 번 깊이의 노드 반복이 진행될 것이다.
깊이별로 노드가 추가되는 BFS 구조를 나타낼 수 있다. 이 문제 예제의 입력값이 `[3,9,20,null,null,15,7]`일 때, `depth`가 1이면 `queue`에는 `[3]`, 2이면 `[9, 20]`, 3이면 `[15, 7]`이 삽입되어 처리된다.
깊이 depth는 while 구문의 반복 횟수이므로 BFS에서 반복 횟수는 곧 높이가 된다. 이제 반복 횟수를 리턴하면 최종 결과를 구할 수 있다.

----

