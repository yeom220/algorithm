>[!트리] 트리
>트리는 계층형 트리 구조를 시뮬레이션 하는 추상 자료형(ADT)으로, 루트 값과 부모-자식 관계의 서브트리로 구성되며, 서로 연결된 노드의 집합니다.

중요한 트리의 속성 중 하나는 재귀로 정의된(Recursively Defined) 자기 참조(Self-Referential) 자료구조라는 점이다. 쉽게 말하면, 트리는 자식도 트리고 또 그 자식도 트리다. 즉 여러 개의 트리가 쌓아 올려져 큰 트리가 된다. 흔히 서브트리(Subtrees)로 구성된다고 표현하는데, 앞서 트리에 대한 위키피디아의 정의에도 서브트리라는 용어가 등장한다. 이러한 재귀적 특성 때문에 441페이지에서 살펴보게 될 순회에서도 트리에서는 재귀 순회가 좀 더 자연스러운 편이다.


### 트리의 각 명칭
트리는 항상 루트(Root)에서부터 시작된다. 루트는 자식(Child) 노드를 가지며, 간선(Edge)으로 연결되어 있다. 자식 노드의 개수는  차수(Degree)라고 하며, 크기(Size)는 자신을 포함한 모든 자식 노드의 개수다. 높이(Height)는 현재 위치에서부터 리프(Leaf)까지의 거리, 깊이(Depth)는 루트에서부터 현재 노드까지의 거리다. 트리는 그 자식도 트리인 서브트리 구성을 띤다고 앞서 언급한 바 있다.
레벨(Level)은 0에서부터 시작한다. 논문에 따라 1에서부터 시작하는 경우도 있으나 현재 대부분의 문서에서는 0에서부터 시작하는 것이 좀 더 일반적이며 여기서도 0부터 시작한다. 트리는 항상 단방향(Uni-Directional)이기 때문에, 간선의 화살표는 생략 가능하다. 일반적으로 방향은 위에서 아래로 향한다.


### 그래프 vs 트리
그래프와 트리의 차이점은 무엇일까? 가장 두드러지는 큰 차이점은 다음과 같다. 
*"트리는 순환 구조를 갖지 않는 그래프"*
핵심은 순환 구조(Cyclic)이 아니라는 데 있다. 트리는 특수한 형태의 그래프의 일종이며, 크게 그래프의 범주에 포함된다. 하지만 트리는 그래프와 달리 어떠한 경우에도 한번 연결된 노드가 다시 연결되는 법이 없다. 이외에도 단방향(Uni-Directional), 양방향(Bi-Directional)을 모두 가리킬 수 있는 그래프와 달리, 트리는 부모 노드에서 자식 노드를 가리키는 단방향 뿐이다. 그뿐만 아니라 트리는 하나의 부모 노드를 갖는다는 차이점이 있으며 루트 또한 하나여야 한다. 이처럼 트리와 그래프는 서로 다른 점이 많다.

**트리가 아닌 예**
1. 순환 구조: 트리는 순환 구조를 갖지 않아야 한다.
2. 부모 노드: 부모 노드는 단 하나여야 한다.
3. 여러개의 그래프: A->B, D<-C->E가 서로 연결되어 있지 않으며, 루트가 둘이므로 트리가 아니다. 루트 또한 하나여야 한다.


### 이진트리
트리 중에서도 가장 널리 사용되는 트리 자료구조는 이진 트리와 이진 탐색 트리(Binary Search Tree)(이하 BST)다. 실제로 인터뷰 시에도 가장 자주 질문을 받게 되는 기본적인 트리 형태이기도 하다. 먼저, 각 노드가 m개 이하의 자식을 갖고 있으면, m-ary 트리(다항 트리, 다진 트리)라고 한다. 여기서 `m=2`일 경우, 즉 **모든 노드의 차수가 2 이하일 때는 특별히 이진 트리(Binary Tree)** 라고 구분해서 부른다. 이진 트리는 왼쪽, 오른쪽, 최대 2개의 자식을 갖는 매우 단순한 형태로, 다진 트리에 비해 훨씬 간결할 뿐만 아니라 여러 가지 알고리즘을 구현하는 일도 좀 더 간단하게 처리할 수 있어서, 대체로 트리라고 하면 특별한 경우가 아니고서는 대부분 이진 트리를 일컫는다.
이제 이진 트리 유형(Types of Binary Trees)을 살펴본다.
- 정 이진 트리(Full Binary Tree): 모든 노드가 0개 또는 2개의 자식 노드를 갖는다.
- 완전 이진 트리(Complete Binary Tree): 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며 마지막 레벨의 모든 노드는 가장 왼쪽부터 채워져 있다.
- 포화 이진 트리(Perfect Binary Tree): 모든 노드가 2개의 자식 노드를 갖고 있으며, 모든 리프 노드가 동일한 깊이 또는 레벨을 갖는다. 문자 그대로 가장 완벽한 유형의 트리다.

----
### 42. 이진 트리의 최대 깊이
>이진 트리의 최대 깊이를 구하라.

###### 1. 반복 구조로 BFS 풀이
깊이는 어떻게 측정할 수 있을까? 여러 가지 방법이 있겠지만 여기서는 BFS(너비 우선 탐색)로 풀이해보겠다. 아울러 BFS는 재귀가 아닌 반복 구조로 풀이할 수 있다. DFS는 스택, BFS는 큐를 사용하여 구현한다. 여기서는 BFS로 풀이할 것이므로, 다음과 같이 큐를 선언하고 풀이할 준비를 한다.
```python
def maxDepth(self, root: TreeNode) -> int:
	...
	queue = collections.deque([root])
	depth = 0

	while queue:
		...
	
	return depth
```

큐를 선언하고 반복 구조도 구성하여, BFS 반복을 이용해 풀이할 구조를 잡았다. 파이썬에서 큐는 일반적인 리스트로도 모든 연산이 가능하지만, 데크 자료형을 사용하면 이중 연결 리스트로 구성되어 있기 때문에 큐와 스택 연산을 모두 자유롭게 활용 가능할 뿐만 아니라 양방향 모두 *O(1)* 에 추출할 수 있어 좋은 성능을 보인다는 점을 이미 여러 번 언급한 바 있다. 실제로도 양방향 추출이 빈번할 경우, 리트코드의 실행 속도 또한 데크가 리스트에 비해 훨씬 더 빠르다.
```python
while queue:
	depth += 1
	for _ in range(len(queue)):
		cur_root = queue.popleft()
		...
		if cur_root.has_child():
			queue.append(cur_root.child)
```

큐 변수에는 현재 깊이 `depth`에 해당하는 모든 노드가 들어 있고, `queue.popleft()`로 하나씩 끄집어 내면서 `cur_root.has_child()`로 자식 노드가 있는지 여부를 판별한 후 자식 노드를 다시 큐에 삽입한다. 참고로 여기서 `.has_child()`와 `.child`는 모두 이해를 돕기 위한 수도코드다.
그렇다면 동일한 큐에 삽입하다 보니 행여나 자식 노드가 부모 노드와 섞이진 않을까? 아마 섞일 것이다. 그러나 이 for 반복문에서는 자식 노드가 추출되는 일은 없을 것이다. 왜냐면 처음 for 문 진입 시 부모 노드의 길이 `len(queue)`만큼만 반복하도록 선언했기 때문이다. 따라서 부모 노드가 모두 추출된 이후에는 for 문을 빠져 나가게 되고, 다시 한 바퀴 돌아 `while queue` 구문에서 이번에는 다음 번 깊이의 노드 반복이 진행될 것이다.
깊이별로 노드가 추가되는 BFS 구조를 나타낼 수 있다. 이 문제 예제의 입력값이 `[3,9,20,null,null,15,7]`일 때, `depth`가 1이면 `queue`에는 `[3]`, 2이면 `[9, 20]`, 3이면 `[15, 7]`이 삽입되어 처리된다.
깊이 depth는 while 구문의 반복 횟수이므로 BFS에서 반복 횟수는 곧 높이가 된다. 이제 반복 횟수를 리턴하면 최종 결과를 구할 수 있다.

----
### 43. 이진 트리의 직경
>이진 트리에서 두 노드 간 가장 긴 경로의 길이를 출력하라.

###### 1. 상태값 누적 트리 DFS
가장 긴 경로를 찾는 방법은 먼저 가장 말단, 즉 리프 노드까지 탐색한 다음 부모로 거슬러 올라가면서 각각의 거리를 계산해 상태값을 업데이트 하면서 누적해 나가면 될 것 같다. 존재하지 않는 노드에도 `-1`이라는 값을 부여한다. 나중에 보면 알겠지만, 정 이진 트리(Full Binary Tree)가 아닌 대부분의 경우에는 존재하지 않는 자식 노드에 `-1`을 부여해 패널티를 주기 위함이다. 이렇게 거슬러 올라가 최종 루트에서 상태값은 2, 거리는 3이 된다. 정답은 거리인 3이다. 상태값은 리프 노드에서 현재 노드까지의 거리다. 거리는 왼쪽 자식 노드의 상태값과 오른쪽 자식 노드의 상태값의 합에 2를 더한 값이다. 다시 정리하면, 최종적으로 거리는 왼쪽 자식 노드의 리프 노드에서 현재 노드까지의 거리(상태값)와, 오른쪽 자식 노드의 리프 노드에서 현재 노드까지의 거리(상태값)의 합에 2(현재 노드와 왼쪽, 오른쪽 자식 노드와의 거리)를 더한 값과 같다. 구체적인 계산은 지금부터 풀이를 이어가보면서 살펴본다.
```python
def dfs(node: TreeNode) -> int:
	...
	left = dfs(node.left)
	right = dfs(node.right)
```

이처럼 계속 재귀 호출을 통해 왼쪽, 오른쪽의 각 리프 노드까지 DFS로 탐색한다.
```python
def dfs(node: TreeNode) -> int:
	...
	self.longest = max(self.longest, left + right + 2)
	return max(left, right) + 1
```

이후에는 2개의 값을 계산하는데, 하나는 최종 결과가 될 가장 긴 경로 `self.longest`, 나머지 하나는 앞서 얘기한 상태값 `max(left, right) + 1`을 말한다. 편의상 `a, b`로 치환해 표현해보면 다음과 같다.
```python
a = left + right + 2       # 거리
b = max(left, rigth) + 1   # 상태값
```

자식 노드가 하나도 없는 경우 `left, right`는 모두 `-1`이고, 이 경우 거리는 `0`, 상태값도 `0`이 된다. 자식 노드가 모두 존재하는 경우에는, 그리고 자식 노드가 둘 다 상태값이 `0`이라면, 거리인 a는 `2`, 상태값인 b는 `1`이 된다. 즉 거리는 왼쪽, 오른쪽 자식 사이의 경로이므로 `2`를 더하게 되고, 상태값은 양쪽 자식 중 최대 상태값과 부모까지의 거리인 `1`을 더하게 된다.

>[!문법] 중첩 함수에서 클래스 변수를 사용한 이유
>앞서 풀이에서 중첩 함수(Nested Function)를 사용할 때, 왜 `longest` 변수를 함수 내에서 선언해 사용하지 않고 바깥에 클래스 변수로 선언해서 번거롭게 `self.longest` 형태로 사용했을까?
>중첩 함수는 부모 함수의 변수를 자유롭게 읽어들일 수 있다. 그러나 중첩 함수에서 부모 함수의 변수를 재할당하게 되면 참조 ID가 변경되며 별도의 로컬 변수로 선언된다.  앞서 풀이의 경우 `self.longest = max(self.longest, left + right + 2)`라는 부분이 있다. `longest` 변수에 값을 재할당하는 부분인데 여기서는 `self.longest`를 사용했다. 왜냐면 재할당을 해야 하기 때문이다. 따라서 부모 함수의 변수를 그대로 사용할 수 없었고, 함수 바깥에서 클래스 변수로 선언 후 사용했다.
>만약 `longest`의 값이 숫자나 문자가 아니라 리스트나 딕셔너리 같은 자료형이라면 `append()`등의 메소드를 이용해 재할당 없이 조작이 가능하다. 중첩 함수 내에서도 변수의 값을 조작할 수는 있다. 그러나 숫자나 문자인 경우 불면 객체이기 때문에 중첩 함수 내에서는 값을 변경할 수 없다. 이 때문에 클래스 변수를 사용했다.

----
### 44. 가장 긴 동일 값의 경로
>동일한 값을 지닌 가장 긴 경로를 찾아라.

###### 1. 상태값 거리 계산 DFS
트리의 말단, 리프 노드까지 DFS로 탐색해 내려간 다음, 값이 일치할 경우 거리를 차곡차곡 쌓아 올려가며 백트래킹하는 형태로 풀이할 수 있다. 루트 노드에서부터 DFS로 재귀 탐색을 진행하면서 리프에 도달하면 그때부터 백트래킹하면서 거리를 누적해 나간다. 먼저, 다음과 같이 DFS 재귀 탐색을 한다.
```python
def dfs(node: TreeNode):
	...
	left = dfs(node.left)
	right = dfs(node.right)
```

이렇게 재귀 호출로 내려가면 `left, right`는 각각 리프 노드에 이르러서 값을 리턴받게 된다. 더 이상 존재하지 않는 노드까지 내려가게 되면 다음과 같은 형태로 값을 리턴한다.
```python
if node is None:
	return 0
```

존재하지 않는 노드까지 내려가게 되면 거리 `0`을 리턴한다. 이제 이 값이 점점 백트래킹 되면서 증가할 것이다. 이 문제는 동일 값(Univalue) 여부를 판별해 거리를 계산하는 문제이기 때문에, 다음과 같이 자식 노드가 동일한 값인지 확인하는 과정이 필요하다.
```python
if node.left and node.left.val == node.val:
	left += 1
else:
	left = 0
if node.right and node.right.val == node.val:
	right += 1
else:
	right = 0
```

왼쪽과 오른쪽 자식 노드를 각각 확인해서 현재 노드, 그러니까 부모 노드와 동일한 경우 각각 거리를 1 증가한다. 이제 다음과 같이 왼쪽 자식과 오른쪽 자식 노드 간 거리의 합을 결과로 한다.
```python
result = max(result, left + right)
```

합이 가장 큰 값을 최종 결과로 한다. 이제 다음번 백트래킹 시 계산을 위해 앞서 문제와 유사하게 상태값을 셋팅해서 부모 노드로 올려야 한다. 다음과 같이 부모 노드를 위해 현재까지의 거리를 리턴해준다.
```python
return max(left, right)
```

지금가지 합의 최댓값을 계산해왔기 때문에 따라서 상태값도 합인 `left + right`를 리턴해야 할 것 같다. 그러나 잠시 생각해보면, 현재 노드는 양쪽 자식 노드를 모두 연결할 수 있지만 현재 노드의 부모 노드에서는 지금의 양쪽 자식 노드를 동시에 연결할 수 없다. 단방향이므로 양쪽 자식 노드 중 어느 한쪽 자식만 택할 수 있으며, 이는 트리의 특징이기도 하다. 따라서 둘 중 큰값을 상태값으로 리턴해준다. 어차피 한 군데만 방문할 수 있다면 더 큰쪽을 방문하는게 낫기 때문이다.

----
### 45. 이진 트리 반전

###### 1. 파이썬다운 방식 (재귀 호출)
```python
def invertTree(self, root: TreeNode) -> TreeNode:
	if root:
		root.left, root.right = \
			self.invertTree(root.right), self.invertTree(root.left)
		return root
	return None
```

마지막 `return None`은 생략이 가능하다. 아무것도 리턴하지 않으면 자바나 C++는 에러를 내뱉겠지만 파이썬은 `None`을 할당하기 때문이다. 이 또한 동적 타이핑 언어인 파이썬의 강력한 기능으로, 초심자는 유의해야 할 기능 중 하나다.

###### 2. 반복 구조로 BFS
```python
def invertTree(self, root: TreeNode) -> TreeNode:
	queue = collections.deque([root])

	while queue:
		node = queue.popleft()
		# 부모 노드부터 하향식 스왑
		if node:
			node.left, node.right = node.right, node.left
			
			queue.append(node.left)
			queue.append(node.right)
	
	return root
```

먼저 삽입된 노드는 반복 구조로 계속 스왑되면서 자식 노드가 계속해서 큐에 추가되는 구조가 된다.
앞서 재귀 풀이가 가장 말단, 리프 노드까지 내려가서 백트래킹하면서 스왑하는 상향(Bottom-Up) 방식이라면 이 풀이는 부모 노드부터 스왑하면서 계속 아래로 내려가는 하향(Top-Down)방식 풀이라 할 수 있다.

###### 3. 반복 구조로 DFS
```python
def invertTree(self, root: TreeNode) -> TreeNode:
	stack = collections.deque([root])
	
	while stack:
		node = stack.pop()
		# 부모 노드부터 하향식 스왑
		if node:
			node.left, node.right = node.right, node.left
			
			stack.append(node.left)
			stack.append(node.right)
	
	return root
```

BFS로 탐색할 때는 `popleft()`로 처음 값을 추출하고, 여기서 DFS로 탐색할 때는 `pop()`으로 마지막 값을 추출했다.

###### 4. 반복 구조로 DFS 후위 순회
앞서 풀이는 전위(Pre-Order) 순회 형태로 처리했지만 다음과 같이 후위(Post-Order) 순회로 변경해도 아무런 문제가 없다. 그저 탐색 순서만 달라질 뿐이다.
```python
def invertTree(self, root: TreeNode) -> TreeNode:
	stack = collections.deque([root])
	
	while stack:
		node = stack.pop()

		if node:
			stack.append(node.left)
			stack.append(node.right)
			
			node.left, node.right = node.right, node.left  #후위 순회
	
	return root
```

| 풀이  | 방식               | 실행 시간 |
| --- | ---------------- | ----- |
| 1   | 파이썬다운 방식         | 28ms  |
| 2   | 반복 구조로 BFS       | 24ms  |
| 3   | 반복 구조로 DFS       | 24ms  |
| 4   | 반복 구조로 DFS 후위 순회 | 24ms  |

-----
### 46. 두 이진 트리 병합
>두 이진 트리를 병합하라. 중복되는 노드는 값을 합산한다.

###### 1. 재귀 탐색
두 이진 트리를 합쳐보는 문제다. 다양한 방식으로 풀이가 가능하다.
```python
def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
	if t1 and t2:
		node = TreeNode(t1.val + t2.val)
		node.left = self.mergeTrees(t1.left, t2.left)
		node.right = self.mergeTrees(t1.right, t2.right)
		
		return node
	else:
		return t1 or t2
```

각각 이진 트리의 루트부터 시작해 합쳐 나가면서 좌, 우 자식 노드 또한 병합될 수 있도록 각 트리 자식 노드를 재귀 호출한다. 만약 어느 한쪽에 노드가 존재하지 않는다면(`not (t1 and t2)`) 존재하는 노드만 리턴하고 더 이상 재귀 호출을 진행하지 않는다. 만약 양쪽 노드가 모두 존재하지 않는다면 `None`이 리턴될 것이다.

----
### 47. 이진 트리 직렬화 & 역직렬화
>이진 트리를 배열로 직렬화하고, 반대로 역직렬화하는 기능을 구현하라. 즉 다음과 같은 트리는 `[1,2,3,null,null,4,5]` 형태로 직렬화할 수 있을 것이다.

###### 1. 직렬화 & 역직렬화 구현
직렬화를 제대로 구현하기 위해서는 우선 이진 트리의 특징과 표현(Representation)에 대해 정확히 알아야 한다. '이진 트리' 데이터 구조는 논리적인 구조다. 이를 파일이나 디스크에 저장하기 위해서는 물리적인 형태로 바꿔줘야 하는데, 이를 직렬화(Serialize)라고 한다. 반대는 역직렬화(Deserialize)다. 파이썬에는 pickle이라는 직렬화 모듈을 기본으로 제공한다. 이 모듈의 이름으로 인해 파이썬 객체의 계층(Hierarchy) 구조를 바이트 스트림(Byte Stream)으로 변경하는 작업은 피클링(Pickling)이라고도 한다. 이외에도 마샬링(Marshalling), 플래트닝(Flattening) 등으로 표현하기도 한다.

**직렬화**
이 문제는 직렬화 알고리즘에 제약이 없으므로, BFS로 구현하든 DFS로 구현하든 아무런 상관이 없다. 하지만 가능하면 BFS 탐색 결과로 표현해서, 배열만 봐도 트리의 형태를 직관적으로 떠올릴 수 있도록 이해하기 쉽게 구현해본다. 아울러 간편한 계산을 위해, 배열은 1번 인덱스부터 시작되는 형태로 표현했다.
이진 트리를 BFS로 표현하면 순서대로 배치되기 때문에, DFS에 비해 매우 직관적으로 알아볼 수 있다.
트리의 비어 있는 노드들은 마찬가지로 배열에서도 공간을 비워 두었는데, 여기서는 널 대신 코드에서는 \#으로 표현하기로 한다. 이 문제의 경우 리턴 값을 문자열로 받게 했는데, 파이썬의 널인 `None`은 문자열로 만들 수 없기 때문이다. 따라서 0번 인덱스와 4, 5번은 모두 \#으로 표현한다.
```python
def serialize(self, root: TreeNode) -> str:
	...
	while queue:
		node = queue.popleft()
		if node:
			queue.append(node.left)
			queue.append(node.right)
			result.append(str(node.val))
		else:
			result.append('#')
	return result
```

`result`에는 현재 노드의 값을 추가했다. 이렇게 하면 큐에는 BFS 탐색 결과가 계속 추가되면서 마지막 노드까지 차례대로 배열로 표현될 것이다. 노드가 존재하지 않을 경우, 널 이라는 의미로 `#`을 추가한다.
이제 마지막으로 `result`는 다음과 같이 리스트가 아닌 배열로 바꿔준다.
`return ' '.join(result)`
이렇게 구현한 코드로 예제 입력값을 기준으로 직렬화한 출력 결과는 다음과 같다.
`# A B C # # D E # # # #`
뒷 부분에 `#`이 몇 개 더 붙어 있어서 기대한 결과와 조금 다르긴 하다. 그러나 특별히 문제는 없다. 각각 D, E의 왼쪽, 오른쪽 자식 노드로 존재하지 않기 때문에 `#`이 붙어 있는 것인데, 이렇게 붙어 있어도 아무런 문제가 없다.

**역직렬화**
```python
def deserialize(self, data: str) -> TreeNode:
	nodes = data.split()
	
	root = TreeNode(int(nodes[1]))
	queue = collections.deque([root])
	...
```
`split()`으로 공백 단위로 문자열을 끊어서 `nodes`라는 리스트 변수로 만든다. 그다음, 트리로 만들어줄 노드 변수 `root`부터 셋팅하고 큐 변수도 만들어준다. 이제 큐를 순회하면서 처리하면 되는데, 왼쪽 자식과 오른쪽 자식은 각각 별도의 인덱스를 부여받아 다음과 같이 `nodes`를 먼저 탐색해 나간다. 마치 런너 기법에서 빠른 런너가 먼저 노드를 탐색해 나가는 것과 유사하다.
```python
def deserialize(self, data: str) -> TreeNode:
	...
	index = 2
	while queue:
		node = queue.popleft()
		if nodes[index] is not '#':
			node.left = TreeNode(int(nodes[index]))
			queue.append(node.left)
		index += 1
		
		if nodes[index] is not '#':
			node.right = TreeNode(int(nodes[index]))
			queue.append(node.right)
		index += 1
	...
```

`#`인 경우에는 큐에 삽입하지 않고, 아무런 처리도 하지 않는다. 예를 들어 앞서 직렬화 되었던 입력값 `# A B C # # D E # # # #`은 E 이후에 더 이상 큐에 삽입되지 않으며, 빠른 런너처럼 훨씬 더 앞의 `#`은 읽어들이긴 하지만 노드의 값이 `#`이므로 아무런 처리도 하지 않을 것이다. 이렇게 끝까지 순회하고 나면 원래의 트리 구조로 복원된다. 

-----
### 48. 균형 이진 트리
>이진 트리가 높이 균형(Height-Balanced)인지 판단하라.

###### 1. 재귀 구조로 높이 차이 계산
높이 균형은 매우 중요한 개념이다. 균형이 맞아야 효율적으로 트리를 구성할 수 있으며, 탐색 또한 훨씬 더 효율적으로 처리할 수 있기 때문이다. 높이 균형을 매번 맞추는 AVL 트리(Adelson-Velsky Landis)는 대표적인 자가 균형 이진 탐색 트리이기도 하다.
여기서는 높이 균형이 맞는지 여부를 판별하는 코드를 구현해본다.
```python
def isBalanced(self, root: TreeNode) -> bool:
	def check(root):
		if not root:
			return 0
			
		left = check(root.left)
		right = check(root.right)
		...
```

재귀 호출로 리프 노드까지 내려간다. 맨 마지막 노드에 이르면 각각 `left = 0, right = 0`을 리턴하도록 구성했다. `check()` 함수의 비즈니스 로직은 다음과 같다.
```python
def check(root):
	...
	if left == -1 or right == -1 or abs(left - right) > 1:
		return -1
	return max(left, right) + 1
```

`left`와 `right`가 모두 `0`이라면, 차이가 1보다 크지 않으므로 `max(left, right) + 1`로 1을 리턴하게 된다. 이런 식으로 점점 1씩 증가하는 형태가 리턴된다. 예제에서 `false`로 처리된 입력값 `[1,2,2,3,3,null,null,4,4]`를 대상으로 표현해보면 리프 노드인 `4`는 `1`, 그 부모 노드인 `3`은 `2`, 이런 식으로 높이에 따라 1씩 점점 증가하는 형태를 띤다. 하지만 루트 `1`의 오른쪽 자식 노드인 `2`는 더 이상 자식이 없으므로 값은 `1`을 받게 된다. 그 왼쪽, 즉 형제 노드는 `3`이므로 높이 차이가 1을 초과하므로, `-1`을 리턴받는다. 즉 루트는 `-1`이 된다. 이렇게 한번 `-1`이 되면 더 이상 회복되지 않는다. 만약 부모 노드가 또 있다 해도 그 오른쪽 노드는 어떠한 경우에도 `1` 이상의 값을 갖게 될 것이므로 계속해서 높이 차이가 1을 초과한다. 때문에 마찬가지로 `-1`을 리턴받는다. 즉 양쪽 자식 노드 중 어느 하나가 `-1`이 되는 경우에는 계속해서 `-1`을 리턴하게 되며, 각 서브트리의 높이 차이가 한 번이라도 1을 초과하는 경우 `-1`이 할당되며 계속해서 부모 노드로 `-1`을 리턴한다. 최종적으로 `False`를 리턴하게 된다.

----
### 49. 최소 높이 트리
>노드 개수와 무방향 그래프를 입력받아 트리가 최소 높이가 되는 루트의 목록을 리턴하라.

###### 1. 단계별 리프 노드 제거
최소 높이를 구성하려면 가장 가운데에 있는 값이 루트여야 한다. 이 말은 리프노드를 하나씩 제거해 나가면서 남아 있는 값을 찾으면 이 값이 가장 가운데에 있는 값이 될 것이고, 이 값을 루트로 했을 때 최소 높이를 구성할 수 있다는 뜻이기도 하다. 문제에 제시된 입력값은 너무 단순하므로 `[[1,3], [2,3], [3,4], [3,5], [4,6], [6,10], [5, 7], [5,8], [8,9]]` 정도로 해서 좀 더 복잡한 그래프를 구성해본다.
입력값을 그래프로 구성하고 리프 노드를 제거해본다. `[1,2,7,9,10]`인 리프 노드를 한 번 제거했다. 아직 몇 번 더 제거해야 될 것 같다. `[6,8]`인 두 번째 리프 노드를 제거했다. `[4,5]` 리프 노드를 세번째 제거했고 결과는 하나가 남았다. 최종 결과는 3이고, 3을 루트로 했을 때 최소 높이 트리를 구성할 수 있을 것이다. 이제 이 과정을 코드로 구현해 본다.
```python
def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
	...
	graph = collections.defaultdict(list)
	for i, j in edges:
		graph[i].append(j)
		graph[j].append(i)
```

이 문제에서 그래프는 무방향(Undirected)이므로, 트리의 부모와 자식은 양쪽 노드 모두 번갈아 가능하다. 따라서 양쪽 모두 `graph`라는 이름의 그래프 딕셔너리 변수에 양방향으로 삽입하여 구성한다.
```python
leaves = []
for i in range(n + 1):
	if len(graph[i]) == 1:
		leaves.append(i)
```

리프 노드를 찾아서 `leaves`에 추가한다. 리프 노드는 그래프에서 해당 키의 값이 1개뿐인 것을 말한다.
입력값 `[[1,3], [2,3], [3,4], [3,5], [4,6], [6,10], [5, 7], [5,8], [8,9]]` 을 기준으로 딕셔너리로 표현한 그래프의 값은 이런 형태가 되고, 이 중에서 값이 1개 뿐인 `[1,2,10,7,9]`가 첫 번째 리프 노드로 `leaves` 리스트 변수에 담기게 된다. 이제 다음과 같이 루트가 남을 때까지 반복해서 계속 제거한다.
```python
while n > 2:
	n -= len(leaves)
	new_leaves = []
	for leaf in leaves:
		neighbor = graph[leaf].pop()
		graph[neighbor].remove(leaf)
		
		if len(graph[neighbor]) == 1:
			new_leaves.append(neighbor)
	
	leaves = new_leaves
```

`n`은 전체 노드의 개수이므로 여기서 `leaves`, 즉 리프 노드의 개수만큼 계속 빼나가면서 최종 2개 이하가 남을 때까지 반복한다. 마지막에 남은 값이 홀수 개일 때는 루트가 최종 1개가 되지만, 짝수 개일 때는 2개가 될 수 있다. 따라서 `while` 반복문은 2개까지는 계속 반복된다. 리프 노드는 반복하면서 제거한다. 그래프 딕셔너리에서 `pop()`으로 제거하고, 연결된 값도 찾아서 제거한다. 즉 무방향 그래프라 그래프를 각각 두 번씩 만들었으므로 제거 또한 두 번씩 진행한다. 이제 마찬가지로 값이 1개뿐일 때는 리프 노드라는 의미이므로, 새로운 리프 노드를 `new_leaves`로 구성하여 교체한다. 계속 반복하면서 `leaves`에 최종적으로 2개 이하의 노드가 남게 되었을 때, 이 노드들이 루트가 되며 최종 결과로 리턴한다.

>[!이진 탐색 트리(BST)]
>앞서 이진 트리는 정렬 여부와 관계 없이 모든 노드가 둘 이하의 자식을 갖는 단순한 트리 형태를 말했다. 그렇다면 이진 탐색 트리(Binary Search Tree)란 무엇일까? 이진 '탐색' 트리란 정렬된 트리를 말하는데, 노드의 왼쪽 서브 트리에는 그 노드의 값보다 작은 값들을 지닌 노드들로 이뤄져 있는 반면, 노드의 오른쪽 서브트리에는 그 노드의 값과 같거나 큰 값들을 지닌 노드들로 이루어져 있는 트리를 뜻한다. 이렇게 왼쪽과 오른쪽의 값들이 각각 값의 크기에 따라 정렬되어 있는 트리를 이진 탐색 트리라 한다. 이 트리의 가장 훌륭한 점은 탐색 시 시간 복잡도가 *O(log n)* 이라는 점이다.
>로그는 정말 마법과도 같은 수식인데 1억 개의 아이템도 단 27번이면 모두 찾아낼 수 있다. 이산수학에서도 매번 등장하는 수학 함수이기도 하며, 심지어 카드 마술에까지 이진 탐색이(트리가 아닌 이진 탐색(Binary Search)만을 일컬을 때는 흔히 '이진 검색' 이라고도 부른다) 등장한다. 이처럼 마술 같은 힘을 보이는 로그의 강력함을 잘 표현한 트리가 바로 이진 탐색 트리다.
>BST는 랜덤하게 생성해도 대부분의 경우 균형이 잘 맞는 아름다운 형태로 트리를 표현할 수 있지만, 운이 나쁘면 트리의 모양이 균형을 제대로 이루지 못할 수 있다. 균형이 많이 깨지면 탐색시에 *O(log n)* 이 아니라 *O(n)* 에 근접한 시간이 소요될 수 있다. 운이 나쁘게 비효율적으로 구성된 BST는 연결 리스트와 다르지 않다. 값을 찾기 위해서는 루트부터 맨 끝까지 차례대로 모두 탐색해야 하므로 전혀 효율적이지 않다. 강력한 로그 계산을 기반으로 하는 이진 탐색 트리의 장점을 전혀 살릴 수 없다. 따라서 이런 트리는 균형을 맞춰 줄 필요가 있다. 그래서 고안해낸 것이 바로 '자가 균형 이진 탐색 트리' 다.
>
>**자가 균형 이진 탐색 트리**
>>자가 균형(또는 높이 균형) 이진 탐색 트리는 삽입, 삭제 시 자동으로 높이를 작게 유지하는 노드 기반의 이진 탐색 트리다.
>
>자가 균형 이진 탐색 트리(Self-Balancing Binary Search Tree)는 최악의 경우에도 이진 트리의 균형이 잘 맞도록 유지한다. 즉 높이를 가능한 한 낮게 유지하는 것이 중요하다는 얘기다. 불균형과 균형의 차이는 크게 높이로 구분할 수 있다. 루트의 높이로 불균형과 균형을 구분할 수 있다.
>만약 노드가 100만개 있다고 가정할 때, 불균형할 경우에는 가장 끝에 위치한 아이템을 찾기 위해 100만번의 연산이 필요하다. 균형이 잡혀 있을 경우에는 균형이 완벽히 잡혀 있다고 가정할 때 최대 19번(`log2(1,000,000)`)이면 어떤 값이든 반드시 찾아내는 게 가능하다.
>이처럼 불균형과 균형의 성능 차이는 꽤 크다. 따라서 트리의 균형, 즉 높이의 균형을 맞추는 작업은 매우 중요하다. 이와 같이 높이 균형을 맞춰주는 자가 균형 이진 탐색 트리의 대표적인 형태로는 AVL 트리와 레드-블랙 트리 등이 있으며, 특히 레드-블랙 트리는 높은 효율성으로 인해 실무에서도 매우 빈번하게 쓰이는 트리 형태이기도 하다. 자바의 해시맵 또한 효율적인 저장 구조를 위해 해시 테이블의 개별 체이닝(Separate Chaining) 시 연결 리스트와 함께 레드-블랙 트리를 병행해 저장하는 구조로 구현되어 있다.

----
### 50. 정렬된 배열의 이진 탐색 트리 변환
>오름차순으로 정렬된 배열을 높이 균형(Height Balanced) 이진 탐색 트리로 변환하라.

###### 1. 이진 검색 결과로 트리 구성
이 문제를 제대로 풀이하기 위해서는 먼저 이진 탐색 트리, BST의 특징에 대해 정확하게 파악하고 있어야 한다. BST는 이진 검색의 마법을 적용한 이진 트리고, 따라서 BST를 만들기 위해서는 정렬된 배열을 이전 검색으로 계속 쪼개 나가기만 하면 된다. 당연한 얘기지만 정렬되어 있지 않으면 사용할 수 없다. 이진 검색 자체가 정렬된 배열에서는 어떤 값이든지 간에 *log(n)* 에 찾아낼 수 있는 마법이고, 동일한 이름의 BST 또한 당연히 정렬된 배열을 기준으로 한다.
예제에서 제시된 입력값 외에 완전 이진 트리(Complete Binary Tree) 형태가 될 수 있도록 `-7, 7` 두 값을 추가해 좀 더 이해가 쉽도록 구성해봤다. 여기서는 정확히 한 번의 이진 검색 결과가 각각의 노드로 구성된다. 즉 `0`이 가장 먼저, 그다음은 `-7, 7, ...` 이런 식으로 구성되면서 내려간다. 이진 검색을 할 때마다 그 값이 노드로 구성됨을 알 수 있다.
```python
def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
	...
	mid = len(nums) // 2
	
	node = TreeNode(nums[mid])
	node.left = self.sortedArrayToBST(nums[:mid])
	node.right = self.sortedArrayToBST(nums[mid + 1:])
	...
```

정확히 중앙값을 갖도록 내림값을 리턴하는 `//` 연산자를 사용했다. 즉 `lens(nums)`가 3이라면, 2를 나눈 결과인 `1.5`에서 내림하여 `1`이 된다. 인덱스는 0부터 시작하기 때문에 1은 `[0, 1, 2]`에서 정확히 중앙값이 된다. 왼쪽 자식은 남은 절반을 재귀 호출로 계속 처리하고, 오른쪽 자식 또한 마찬가지로 처리한다.
파이썬의 슬라이스 기능을 이용하면 매우 간단하게 코드로 구현할 수 있으며, 절반씩 분할해 처리되는 분할 정복 구조로 처리된다. 끝까지 처리되면 배열은 정확히 높이 균형 BST가 될 것이다.

-----
### 51. 이진 탐색 트리(BST)를 더 큰 수 합계 트리로
>BST의 각 노드를 현재값보다 더 큰 값을 가진 모든 노드의 합으로 만들어라.

###### 1. 중위 순회로 노드 값 누적
자신보다 같거나 큰 값을 구하려면 자기 자신을 포함한 우측 자식 노드의 합을 구하면 된다. BST의 우측 자식 노드는 항상 부모 노드보다 큰 값이기 때문이다. `root`를 입력받았을 때 먼저 맨 오른쪽까지 내려가고, 그다음 부모 노드, 다시 왼쪽 노드순으로 이동하면서 자신의 값을 포함해 누적한다. '오른쪽-부모-왼쪽' 순으로 이어지며, 오른쪽 자식부터 운행하는 중위 순회(In-order)에 해당됨을 알 수 있다.
```python
def bstToGst(self, root: TreeNode) -> TreeNode:
	...
	self.bstToGst(root.right)
	self.val += root.val
	root.val = self.val
	self.bstToGst(root.left)
```

`self.val`은 지금까지 누적된 값이고, `root.val`은 현재 노드의 값이다. 즉 중위 순회를 하면서 현재 노드의 값을 자기 자신을 포함한 지금까지의 누적된 값과 합한다.
최초 `self.val`은 클래스 멤버 변수로 선언하고 `0`이 되도록 직관적으로 선언했다. 아울러 `root`가 있을 때만 처리되게 했으며, `root.val`을 조작한 이후에는 다시 `root`를 리턴한다. 사실 리턴을 하지 않아도 관계 없다. 이 코드에서 보듯이, 재귀 호출 시 리턴 값은 사용하지 않기 때문이다.
또한 파이썬은 모든 변수가 참조이기 때문에, 객체 내부의 값을 변경하면 해당 객체를 가리키는 모든 변수는 자연스럽게 따라서 값이 변한다. 그러나 이 문제는 리트코드의 동작 방식으로 추측컨대, 리트코드에서는 아마 최초 호출 시 `root = solution.bstToGst(root)`와 같은 형태로 리턴 값을 받아오도록 구현되어 있을 것이다. 이때 리턴 값을 돌려주지 않으면 `root`는 `None`이 되어 버린다. 리트코드에서 리턴 값을 주지 않으면 정답이 출력되지 않는 것도 그 때문일 것이다. 따라서 반드시 `return root`를 명시한다.

-----
### 52. 이진 탐색 트리(BST) 합의 범위
>이진 탐색 트리가 주어졌을 때 L 이상 R 이하의 값을 지닌 노드의 합을 구하라.

##### 1. 재귀 구조 DFS로 브루트 포스 탐색
이 문제는 DFS로 전체를 탐색한 다음, 노드의 값이 L과 R 사이일 때만 값을 부여하고, 아닐 경우에는 0을 취해 계속 더해 나가면 쉽게 구할 수 있다. 그러나 이 방식은 모든 노드를 탐색하는 브루트 포스 풀이다. 좀 더 최적화를 진행해본다.

###### 2. DFS 가지치기로 필요한 노드 탐색
이번에는 DFS로 불필요한 노드는 가지치기를 통해 최적화를 진행해본다. DFS로 탐색하되 L, R의 조건에 해당되지 않는 가지(Branch)를 쳐내는(Pruning) 형태로 탐색에서 배제하도록 다음과 같이 구현해본다.
```python
def dfs(node: TreeNode) -> int:
	...
	if node.val < L:
		return dfs(node.right)
	elif node.val > R:
		return dfs(node.left)
```

이진 탐색 트리는 왼쪽이 항상 작고, 오른쪽이 항상 크다. 즉 현재 노드 `root`가 L보다 작을 경우, 더 이상 왼쪽 가지는 탐색할 필요가 없기 때문에 오른쪽만 탐색하도록 재귀 호출을 리턴한다. 마찬가지로 R보다 클 경우, 오른쪽은 더 이상 탐색할 필요가 없으므로 왼쪽만 탐색하도록 재귀 호출을 리턴한다. 이렇게 불필요한 탐색을 줄여 최적화할 수 있다. 이 경우 불필요한 탐색은 배제하게 되므로 탐색 효율이 매우 높다. 필요한 노드만 탐색하여 해당 노드의 값들을 더해 나가게 된다.

###### 3. 반복 구조 DFS로 필요한 노드 탐색
대부분의 재귀 풀이는 반복으로 변경할 수 있다. 이 문제 또한 다음과 같이 반복으로 풀이할 수 있다. 일반적으로 반복 풀이가 재귀 풀이에 비해 좀 더 직관적으로 이해가 쉽다.
유효한 노드만 스택에 계속 집어 넣으면서, L과 R 사이의 값인 경우 값을 더해나간다. 유효한 노드만 삽입하기 때문에 앞서 풀이인 가지치기와 탐색 범위가 유사하며, 스택이므로 DFS와 동일한 탐색 구조를 띤다.

###### 4. 반복 구조 BFS로 필요한 노드 탐색
BFS로 탐색해도 동일하다. 여기서는 스택을 단순히 큐 형태로 바꾸기만 하면, BFS를 구현할 수 있다. 원래는 파이썬의 데크를 사용해야 성능을 높일 수 있지만, 여기서는 편의상 간단히 리스트를 그냥 `pop(0)`로 처리하는 정도로 BFS를 구현하고, 마찬가지로 동일하게 정답을 풀이할 수 있다.

| 풀이  | 방식                   | 실행시간  |
| --- | -------------------- | ----- |
| 1   | 재귀 구조 DFS로 브루트 포스 탐색 | 288ms |
| 2   | DFS 가지치기로 필요한 노드 탐색  | 224ms |
| 3   | 반복 구조 DFS로 필요한 노드 탐색 | 220ms |
| 4   | 반복 구조 BFS로 필요한 노드 탐색 | 232ms |
이 문제는 애초에 테스트케이스의 입력값이 크지 않은 것 같다. 입력값이 매우 클 경우 브루트 포스와 가지치기의 속도 차이가 훨씬 더 커야 하는데, 생각보다 그다지 크지 않다. 마찬가지로 반복 BFS 구현에서 `pop(0)`은 *O(n)* 이기 때문에 DFS 구현과 속도 차이가 많이 나야 하는데(`pop()`은 *O(1)* 이다), 그리 차이가 나지 않는다. 그나마 약간의 성능 차이는 확인할 수 있지만, 만약 입력값이 매우 크다면 확연히 다른 성능 차이를 확인할 수 있을 것이다.

-----
### 53. 이진 탐색 트리 노드 간 최소 거리
>두 노드 간 값의 차이가 가장 작은 노드의 값의 차이를 출력하라.

###### 1. 재귀 구조로 중위 순회
값의 차이가 가장 작은 노드를 찾으려면 어디와 어디 노드를 비교해야 하는지 생각해본다. BST의 왼쪽 자식은 항상 루트보다 작고, 오른쪽 자식은 항상 루트보다 크다.
```python
def f():
	if root.left:
		f(root.left)
	
	result = min()
	
	if root.right:
		f(root.right)
```

이 형태가 중위 순회의 기본 뼈대가 될 것이다. 

###### 2. 반복 구조로 중위 순회
이번에는 동일한 알고리즘을 반복 구조로 구현해본다. 반복으로 풀이하면 재귀보다 훨씬 직관적이어서 이해하기도 쉽고 풀이 또한 쉬운 편이다. 이전 풀이인 재귀 구조와 비교 순서는 동일하다. 여기에 더한 추가 장점은 재귀일 때는 `prev`와 `result`를 클래스 멤버 변수로 선언했지만, 반복구조에서는 한 함수 내에서 처리할 수 있기 때문에 함수 내 변수로 선언이 가능하다는 점이다.
DFS 풀이인 만큼 스택을 사용했고, 오른쪽 자식 노드를 택하기 전에 비교하는 형태로 재귀와 동일하게 중위 순회로 풀이했다. 재귀와 달리 클래스 변수를 사용하지 않아도 되므로, 변수 값의 변화를 추적하기가 쉽고 좀 더 직관적이다.

| 풀이  | 방식           | 실행 시간 |
| --- | ------------ | ----- |
| 1   | 재귀 구조로 중위 순회 | 48ms  |
| 2   | 반복 구조로 중위 순회 | 44ms  |

-----
### 트리 순회

>[!트리 순회]
>트리 순회란 그래프 순회의 한 형태로 트리 자료구조에서 각 노드를 정확히 한 번 방문하는 과정을 말한다.

그래프 순회와 마찬가지로 트리 순회(Tree Traversals) 또한 DFS 또는 BFS로 탐색하는데, 특히 이진 트리에서 DFS는 노드의 방문 순서에 따라 다음과 같이 크게 3가지 방식으로 구분된다.
1. 전위(Pre-Order) 순회(NLR)
2. 중위(In-Order) 순회(LNR)
3. 후위(Post-Order) 순회(LRN)

순회 방식의 영문 두문자어를 구성하는 3가지 문자 L, R, N 중 L은 현재 노드의 왼쪽 서브트리, R은 현재 노드의 오른쪽 서브트리, N은 현재 노드 자신을 의미한다. 즉 전위 순회는 NLR이므로 현재 노드를 먼저 순회한 다음 왼쪽과 오른쪽 서브트리를 순회하고, 중위 순회는 LNR이므로 왼쪽 서브트리를 순회한 다음 현재 노드, 후위 순회는 LRN이므로 왼쪽과 오른쪽 서브트리를 순회한 다음 현재 노드를 순회한다.
이제 각 순회 방식을 코드를 통해 좀 더 구체적으로 살펴본다. 트리의 순회 방식은 재귀 또는 반복, 모두 구현이 가능하지만 트리의 재귀적 속성으로 인해 재귀 쪽이 훨씬 더 구현이 간단하다. 전위 순회의 재귀 구현 수도코드는 아래와 같다.
```python
// DFS 전위 순회의 재귀 구현 수도코드
preorder(node)
	if (node == null)
		return
	visit(node)
	preorder(node.left)
	preorder(node.right)
```

반면, 전위 순회의 반복 구현 수도코드는 아래와 같다.
```python
// DFS 전위 순회의 반복 구현 수도코드
iterativePreorder(node)
	if (node == null)
		return
	s <- empty stack
	s.push(node)
	while (not s.isEmpty())
		node <- s.pop()
		visit(node)
		
		if node.right != null
			s.push(node.right)
		if node.left != null
			s.push(node.left)
```

재귀 구현과 반복 구현은 수도코드의 구성이나 직관성에서 많은 차이를 보인다. 트리의 재귀적인 특성 탓에, 재귀 구현이 훨씬 더 간단하고 직관적이다. 따라서 여기서도 모두 재귀로 구현하여 실행 가능한 코드를 작성해본다. 먼저 연결 리스트를 담을 `Node` 클래스를 정의하고 트리의 전체 입력값을 `root` 변수로 다음과 같이 정의해본다.
```python
class Node:
	def __init__(self, val, left=None, right=None):
		self.val = val
		self.left = left
		self.right = right

root = Node('F',
		   Node('B',
			   Node('A'),
			   Node('D',
				   Node('C'), Node('E'))
			   ),
		   Node('G',
			   None,
			   Node('I', Node('H))
			   )
		   )
```

이제 각각의 순회 방식을 구현해본다.

**전위순회 (NLR)**
```python
def preorder(node):
	if node is None:
		return
	print(node.val)
	preorder(node.left)
	preorder(node.right)
```

재귀로 구현하면 코드가 매우 간결하고 보기 쉽다. 실행 결과는 다음과 같다.
```python
>>> preorder(root)
F, B, A, D, C, E, G, I, H
```

**중위 순회 (LNR)**
```python
def inorder(node):
	if node is None:
		return
	inorder(node.left)
	print(node.val)
	inorder(node.right)
```

어떤 차이인지 금방 알아차릴 수 있을 것이다. 마찬가지로 실행 결과는 다음과 같다.
```python
>>> inorder(root)
A, B, C, D, E, F, G, H, I
```

**후위 순회 (LRN)**
```python
def postorder(node):
	if node is None:
		return
	postorder(node.left)
	postorder(node.right)
	print(node.val)
```

실행 결과는 다음과 같다.
```python
>>> postorder(root)
A, C, E, D, B, H, I, G, F
```

여기까지 트리의 순회 방식을 각각 살펴봤다. 재귀로 구현하면 매우 직관적이므로 각각의 순회가 어떤 구조로 구현되는지 어렵지 않게 이해할 수 있을 것이다. 이제 순회의 특징을 이용한 문제를 한번 풀이해본다.

-----
### 54. 전위, 중위 순회 결과로 이진 트리 구축
>트리의 전위, 중위 순회 결과를 입력값으로 받아 이진 트리를 구축하라.

###### 1. 전위 순회 결과로 중위 순회 분할 정복
순회에는 크게 전위, 중위, 후위 순회가 있으며 이 셋 중 2가지만 있어도 이진 트리를 복원할 수 있다. 이 문제는 바로 여기서 2가지 결과인 전위와 중위 결과를 받아 이진 트리를 만들어 보는 문제다. 그럼 전위와 중위는 과연 어떤 관계가 있을까. 예제의 입력값이 너무 단순하므로, 트리 그림을 1부터 9까지 좀 더 복잡한 형태로 새로 구성해봤다. 이 그림에서 전위, 중위 순회 결과를 유심히 살펴본다. 전위의 첫 번째 값은 부모 노드다. 즉 전위 순회의 첫 번째 결과는 정확히 중위 순회 결과를 왼쪽과 오른쪽으로 분할시키는 역할을 한다. 중위 순회의 분할 정복(Divide and Conquer) 문제로 바꾸는 것이다. 두 번째로 왼쪽 노드의 `2`는 중위 순회 결과를 정확히 반으로 가르고, 각각 왼쪽 자식은 `4`, 오른쪽 자식은 `5`로 마무리 한다. 오른쪽의 경우 3이 첫 번째 값인데, 마침 중위 순회에서는 맨 오른쪽에 위치해 있다. 이 말은 3의 오른쪽 자식 노드는 존재하지 않는다는 얘기다. 이제 남아 있는 노드들을 이후에도 계속 분할을 시도하면, 이 그림처럼 트리 형태로 최종적으로 구성할 수 있다.
```python
index = inorder.index(preorder.pop(0))
```

먼저, 전위 순회 첫 번째 결과를 가져와 중위 순회를 분할하는 인덱스로 한다.
```python
node = TreeNode(inorder[index])
node.left = self.buildTree(preorder, inorder[0:index])
node.right = self.buildTree(preorder, inorder[index + 1:])
```

이 값을 현재 노드로 구성하고, 이를 기준으로 중위 순회 결과를 쪼개서 왼쪽, 오른쪽으로 각각 마무리될 때 분할 정복 구조로 재귀 호출하면, 트리를 구성할 수 있다.
여기서 전위 순회 결과는 `pop(0)`으로 값을 꺼내온다. 즉 큐 연산이며, 파이썬에서는 데크(Deque)로 구현할 수 있다. 여기서는 입력값 리스트를 특별히 다른 자료형으로 변환하지 않고 그대로 사용한다. 파이썬의 리스트는 `pop()`에도 인덱스를 별도로 지정할 수 있어서, 사실상 스택과 큐의 모든 역할을 수행할 수 있다. 하지만 파이썬의 리스트에서 `pop(0)`은 시간 복잡도가 *O(n)* 이므로 주의가 필요하다.
