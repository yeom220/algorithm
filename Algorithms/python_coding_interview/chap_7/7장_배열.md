>배열은 값 또는 변수 엘리먼트의 집합으로 구성된 구조로, 하나 이상의 인덱스 또는 키로 식별된다.

>[!참고: 메모리와 포인터]
>32비트 머신의 포인터는 32비트며, 64비트 머신의 포인터는 64비트다. 포인터는 메모리 영역을 1바이트 단위로 가리키는 주소인데, 과거 32비트 머신은 메모리 주소를 0에서 2^32-1 까지 밖에 표현할 수 없었고, 최대 약 4GB까지만 지정할 수 있었다. 따라서 메모리를 4GB 이상 인식할 수 없는 문제가 있었는데, 최근에 64비트 시스템들은 2^64, 약 16EB라는 엄청난 크기의 가상 메모리를 가리킬 수 있어 한동안은 충분하다고 볼 수 있다.
##### 7. 두수의 합
>덧셈하여 타겟을 만들 수 있는 배열의 두 숫자 인덱스를 리턴하라.

| 풀이  | 방식                | 실행 시간   |
| --- | ----------------- | ------- |
| 1   | 브루트 포스로 계산        | 5,284ms |
| 2   | in을 이용한 탐색        | 864ms   |
| 3   | 첫 번째 수를 뺀 결과 키 조회 | 48ms    |
| 4   | 조회 구조 개선          | 44ms    |
| 5   | 투 표인터 이용          | 풀이 불가   |
| 6   | 고(Go) 구현          | 8ms     |
##### 8.빗물 트래핑
>높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라.

| 풀이  | 방식            | 실행 시간 |
| --- | ------------- | ----- |
| 1   | 투 포인터를 최대로 이동 | 52ms  |
| 2   | 스택 쌓기         | 56ms  |
##### 9.세 수의 합
>배열을 입력받아 합으로 0을 만들 수 있는 3개의 엘리먼트를 출력하라.

| 풀이  | 방식          | 실행 시간 |
| --- | ----------- | ----- |
| 1   | 브루트 포스로 계산  | 타임아웃  |
| 2   | 투 포인터로 합 계산 | 884ms |
>[!참고: 투 포인터]
>투 포인터는 여러 가지 방식이 있지만, 대개는 시작점과 끝점 또는 왼쪽 포인터와 오른쪽 포인터 두 지점을 기준으로 하는 문제 풀이 전략을 뜻한다. 범위를 좁혀 나가기 위해서는, 일반적으로 배열이 정렬되어 있을 때 좀 더 유용하다. 투 포인터는 주로 정렬된 배열을 대상으로 하며, 2개의 포인터가 좌우로 자유롭게 움직이며 문제를 풀이한다.
##### 10.배열 파티션 1
>n개의 페어를 이용한 min(a, b)의 합으로 만들 수 있는 가장 큰 수를 출력하라.


