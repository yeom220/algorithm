>[!정렬]
>정렬 알고리즘은 목록의 요소를 특정 순서대로 넣는 알고리즘이다. 대개 숫자식 순서(Numerical Order)와 사전식 순서(Lexicographical Order)로 정렬한다.

정렬(Sorting) 알고리즘은 간단하고 익숙할 뿐만 아니라 여러모로 유용하다. 그러나 효율적으로 해결하기가 쉽지 않기 때문에, 컴퓨터과학 초기에 정렬은 많은 연구가 필요한 매력적인 주제 중 하나였다. 뿐만 아니라 빅오, 분할 정복, 힙, 이진 트리, 시간과 공간의 트레이드오프 등 여러 가지 컴퓨터과학의 핵심 주제를 아우르기 때문에, 정렬은 알고리즘에 본격적으로 입문하기에도 매우 좋은 주제이기도 하다.

### 버블 정렬
사실 버블 정렬은 전혀 중요한 알고리즘이 아니다. 정렬 자체가 실무와는 다소 거리가 있기도 하지만 그중에서도 버블 정렬은 더욱 거리가 먼 알고리즘이다. 전혀 중요하지 않다. 왜 중요하지 않다고 이야기했는지 설명해보겠다.
```python
# 버블 정렬 수도코드
Bubblesort(A)
	for i from 1 to A.length
		for j from 0 to A.length - 1
			if A[j] > A[j + 1]
				swap a[j] with a[j + 1]
```

수도코드를 보니 금방 알아차릴 것 같다. 이 알고리즘은 n번의 라운드로 이뤄져 있으며, 각 라운드마다 배열의 아이템을 한 번씩 쭉 모두 살펴본다. 연달아 있는 아이템 2개의 순서가 잘못되어 있는 것을 발견하면, 두 아이템을 맞바꾼다. 배열 전체를 쭉 살펴보는 것을 n번 하기 때문에 시간 복잡도는 항상 *O(n^2)* 이다. 이보다 더 비효율적일수는 없으며 구현 가능한 가장 느린 정렬 알고리즘이다.
물론 스왑이 이뤄지지 않았는지 여부를 확인해 n^2 보다 좀 더 최적화할 수 있지만, 그럼에도 다른 정렬 알고리즘과는 여전히 성능 차이가 있다. 그래서 앞서, 중요하지 않은 알고리즘이라 거듭 강조한 것이다.
```python
def bubblesort(A):
	for i in range(1, len(A)):
		for j in range(0, len(A) - 1):
			if A[j] > A[j + 1]:
				A[j], A[j + 1] = A[j + 1], A[j]
```

수도코드를 파이썬 코드로 직접 구현해봤다. `i`와 `j`를 비교하는 순서는 앞에서부터 할 수 있고 뒤에서부터 할 수도 있다. Introduction to Algorithms 책에서는 뒤에서부터 비교하도록 수도코드를 제시하고 있으나 여기서는 앞에서부터 비교를 진행했다. 큰 차이는 없다.


### 병합 정렬
병합 정렬(Merge Sort)은 컴퓨터과학 역사상 최고의 천재라 일컬어지는 존 폰 노이만이 1945년에 고안한 알고리즘으로, 분할 정복(Divide and Conquer)의 진수를 보여주는 알고리즘이다. 최선과 최악 모두 *O(nlogn)* 인 사실상 완전한 *세터(nlogn)* 으로 일정한 알고리즘이며, 대부분의 경우 퀵 정렬보다는 느리지만 일정한 실행 속도뿐만 아니라 무엇보다도 안정 정렬(Stable Sort)이라는 점에서 여전히 상용 라이브러리에 많이 쓰이고 있다. 곧 풀어볼 58번 문제에서도, 병합 정렬의 고른 성능 덕분에 퀵 정렬로도 풀리지 않던 문제가 병합 정렬로는 잘 풀리는 경우를 확인하게 될 것이다.
더 이상 쪼갤 수 없을 때까지 계속해서 분할한 후, 분할이 끝나면 정렬하면서 정복해 나간다.


### 퀵 정렬
퀵 정렬(Quick Sort)은 영국의 컴퓨터과학자 토니 호어가 1959년에 고안한 알고리즘으로, 피벗을 기준으로 좌우를 나누는 특징 때문에 파티션 교환 정렬(Partition-Exchange Sort)이라고도 불린다. 병합 정렬과 마찬가지로 분할 정복 알고리즘이며 여기에 피벗(Pivot)이라는 개념을 통해 피벗보다 작으면 왼쪽, 크면 오른쪽과 같은 방식으로 파티셔닝하면서 쪼개 나간다. 여러 가지 변형과 개선 버전이 있는데 여기서는 N.Lomuto가 구현한 파티션 계획(Partition Scheme)을 살펴본다.
로무토 파티션이란 항상 맨 오른쪽의 피벗을 택하는 단순한 방식으로, 토니 호어가 고안한 최초의 퀵 정렬 알고리즘보다도 훨씬 더 간결하고 이해하기 쉽기 때문에 퀵 정렬을 소개할 때는 항상 맨 처음에 언급되며 Introduction to Algorithms에서도 '퀵 정렬' 맨 처음에 등장하는 가장 기본적인 방식이기도 하다. 수도코드를 기준으로 살펴본다.
```python
# 퀵 정렬 수도코드
Quicksort(A, lo, hi)
	if lo < hi then
		pivot := partition(A, lo, hi)
		Quicksort(A, lo, pivot - 1)
		Quicksort(A, pivot + 1, hi)
```

이 수도코드는 퀵 정렬의 메인 함수에서부터 시작한다. 파티션을 나누고 각각 재귀 호출하는 전형적인 분할 정복 구조를 띤다. 이 수도코드를 실제 동작 가능한 파이썬 코드로 구현해보면 다음과 같다.
```python
def quicksort(A, lo, hi):
...
	if lo < hi:
		pivot = partition(lo, hi)
		quicksort(A, lo, pivot - 1)
		quicksort(A, pivot + 1, hi)	
```

이제 파티션을 나누는 함수의 수도코드를 살펴본다.
```python
partition(A, lo, hi)
	pivot := A[hi]
	i := lo
	for j := lo to hi do
		if A[j] < pivot then
			swap A[i] with A[j]
			i := i + 1
	swap A[i] with A[hi]
	return i
```

이 코드는 앞서 언급한 퀵 소트의 가장 간단한 분할 알고리즘인 로무토 파티션 수도코드로, 로무토 파티션은 맨 오른쪽을 피벗으로 정하는 가장 단순한 방식이다. 이를 파이썬 코드로 구현하면 다음과 같다. 수도코드와 기본적인 알고리즘은 동일하며, 변수명만 `i`, `j`에서 `leff`, `right`로, 좀 더 직관적으로 수정했다.
```python
def partition(lo, hi):
	pivot = A[hi]
	left = lo
	for right in range(lo, hi):
		if A[right] < pivot:
			A[left], A[right] = A[right], A[left]
			left += 1
	A[left], A[hi] = A[hi], A[left]
	return left
```

여기서 피벗은 맨 오른쪽 값을 기준으로 하며, 이를 기준으로 2개의 포인터가 이동해서 오른쪽 포인터의 값이 피벗보다 작다면 서로 스왑하는 형태로 진행된다. 오른쪽 `right` 포인터가 이동하면서 피벗의 값이 오른쪽 값보다 더 클 때, 왼쪽과 오른쪽의 스왑이 진행된다. 스왑 이후에는 왼쪽 `left` 포인터가 함께 이동한다. 여기서 피벗의 값은 4이므로, 오른쪽 포인터가 끝에 도달하게 되면 4 미만인 값은 왼쪽으로, 4 이상인 값은 오른쪽에 위치하게 된다. 그리고 왼쪽 포인터의 위치로 피벗 아이템이 이동한다. 즉 4를 기준을 작은 값은 왼쪽에, 큰 값은 오른쪽으로 분할되어 있고, 피벗이 그 중앙으로 이동하는 모습을 확인할 수 있다. 이렇게 계속 분할하면서 정복을 진행하여 코드 기준으로 `lo < hi`를 만족하지 않을 때까지, 즉 서로 위치가 역전할 때까지 계속 재귀로 반복되면서 정렬이 완료된다. 중첩 함수를 이용해 파이썬답게 구현해 좀 더 깔끔하게 정리한 전체 코드는 다음과 같다.
```python
def quicksort(A, lo, hi):
	def partition(lo, hi):
		pivot = A[hi]
		left = lo
		for right in range(lo, hi):
			if A[right] < pivot:
				A[left], A[right] = A[right], A[left]
				left += 1
		A[left], A[hi] = A[hi], A[left]
		return left

	if lo < hi:
		pivot = partition(lo, hi)
		quicksort(A, lo, pivot - 1)
		quicksort(A, pivot + 1, hi)
```

퀵 정렬은 그 이름처럼 매우 빠르며 굉장히 효율적인 알고리즘이다. 그러나 최악의 경우에는 *O(n^2)* 이 된다. 만약 이미 정렬된 배열이 입력값으로 들어왔다고 가정해보자. 이 경우 피벗은 계속 오른쪽에 위치하게 되므로 파티셔닝이 전혀 이뤄지지 않는다. 이때 n번의 라운드에 걸쳐 결국 전체를 비교하기 때문에, 버블 정렬과 다를 바 없는 최악의 성능을 보이게 된다. 항상 일정한 성능을 보이는 병합 정렬과 달리, 퀵 정렬은 이처럼 입력값에 따라 성능 편차가 심한 편이다. 하지만 피벗을 선택하는 알고리즘을 개선해 퀵 정렬을 좀 더 최적화하는 등 이미 다양한 연구 결과가 많이 나와 있기도 하다.


### 안정 정렬 vs 불안정 정렬
>[!안정 정렬]
>안정 정렬(Stable Sort) 알고리즘은 중복된 값을 입력 순서와 동일하게 정렬한다.

퀵 정렬의 또 다른 문제점은 안정 정렬이 아니라는 점이다. 예를 들어 다음 그림 17-5와 같이, 지역별 발송 시각을 시간 순으로 정렬한 택배 발송 로그가 있다고 가정해보자.
안정 정렬의 경우에는 기존의 시간 순으로 정렬했던 순서는 지역명으로 재정렬하더라도 기존 순서가 그대로 유지된 상태에서 정렬이 이뤄진다. 그러나 불안정 정렬의 경우에는 시간 순으로 정렬한 값을 지역명으로 재정렬하면 기존의 정렬 순서는 무시된 채 모두 뒤죽박죽 뒤섞이고 만다.
이처럼 입력값이 유지되는 안정 정렬 알고리즘이 유지되지 않는 불안정 정렬 알고리즘보다 훨씬 더 유용하리라는 점은 쉽게 예상할 수 있을 것이다.
대표적으로 병합 정렬은 안정 정렬이며, 심지어 버블 정렬 또한 안정 정렬이다. 반면 퀵 정렬은 불안정 정렬이다. 게다가 입력값에 따라 버블 정렬 만큼이나 느려질 수 있다. 그야말로 최고의 알고리즘으로 칭송받던 퀵 정렬이 경우에 따라서는 최악의 알고리즘이 될 수도 있다. 이처럼 고르지 않은 성능 탓에 실무에서는 병합 정렬이 여전히 활발히 쓰이고 있으며, 파이썬의 기본 정렬 알고리즘으로는 병합 정렬과 삽입 정렬을 휴리스틱하게 조합한 팀소트(Timsort)를 사용한다.

----
