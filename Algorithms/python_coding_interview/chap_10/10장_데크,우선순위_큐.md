### 데크
>[!데크(Deque)]
>데크는 더블 엔드디 큐(Double-Ended Queue)의 줄임말로, 글자 그대로 양쪽 끝을 모두 추출할 수 있는, 큐를 일반화한 형태의 추상 자료형(ADT)이다.

- 데크는 양쪽에서 삭제와 삽입을 모두 처리할 수 있으며, 스택과 큐의 특징을 모두 갖고 있다. 이 추상 자료형의 구현은 배열이나 연결 리스트 모두 가능하지만, 특별히 이중 연결 리스트(Doubly Linked List)로 구현하는 편이 가장 잘 어울린다.
- 이중 연결 리스트로 구현하게 되면, 양쪽으로 head와 tail이라는 이름의 두 포인터를 갖고 있다가 새로운 아이템이 추가될 때마다 앞쪽 또는 뒤쪽으로 연결시켜 주기만 하면 된다. 연결 후에는 포인터를 이동하면 된다.
- 파이썬은 데크 자료형을 다음과 같이 collections 모듈에서 deque라는 이름으로 지원한다.

### 26. 원형 데크 디자인 (리트코드 641)
>다음 연산을 제공하는 원형 데크를 디자인하라.
>- MyCircularDeque(k)
>- insertFront()
>- insertLast()
>- deleteFront()
>- deleteLast()
>- getFront()
>- getRear()
>- isEmpty()
>- isFull()

- 1. 이중 연결 리스트를 이용한 데크 구현
	- 실제 파이썬의 데크 구현체이기도 한 이중 연결 리스트로 구현해본다. 또한 이 데크 구현 문제의 경우 원형 큐 구현 문제와 달리, 맨 앞에 노드를 추가하는 `insertFront()` 연산도 있다. 일반적으로 배열로는 맨 앞에 요소를 추가하는 작업은 시간 복잡도가 *O(n)* 이기 때문에 구현이 쉽지 않다. 그러나 연결 리스트는 맨 앞에 노드를 추가하는 작업이 그리 어렵지 않다.
	- 우리가 구현하려는 데크는 CPython의 구현과 유사하게 왼쪽, 오른쪽 인덱스 역할을 하는 head, tail을 정의하고, 최대 길이 정보를 k로 설정한다. 여기에 추가로, 현재 길이 정보를 담는 변수가 될 len을 `self.len = 0`으로 따로 정의해둔다.
	- 앞쪽에 노드를 추가하는 연산 `insertFront()`를 구현한다.
	- 새로운 노드 삽입시 최대 길이에 도달했을 때는 False를 리턴하고, 이외에는 `_add()` 메소드를 이용해 head 위치에 노드를 삽입한다.
	- 뒤쪽에 노드를 추가하는 연산 `insertLast()`를 구현한다.
	- 뒤쪽에 추가하는 연산도 같지만, 한 가지 다른 점은 head가 아닌 `tail.left`에 삽입한다는 점이다.
	- 실제 삽입을 수행하는 내부 함수를 구현한다. 내부에서만 사용한다는 의미로 PEP 8 명명 규칙 기준에 따라 `_` 하나로 시작하도록 메소드 명을 `_add()`로 정했다.
	- 이중 연결 리스트의 삽입 메소드인 `_add()`는 여러 단계의 다소 복잡한 구현 과정을 거친다.
	  이미 있는 노드를 찢어내고 그 사이에 새로운 노드 `new`를 삽입하는 형태가 된다.
	- 삭제 또한 크게 다르지 않다. 앞쪽 삭제는 `head`의 노드를 뒤쪽 삭제는 `tail` 위치의 노드를 처리한다.
>[!참고]
>원형 데크를 연결 리스트로 구현해봤다. 그런데 사실 원형 데크를 이중 연결 리스트로 구현하게 되면 원형의 이점을 전혀 살릴 수 없게 된다. 이 문제는 데크를 소개하면서 이중 연결 리스트로 구현이 가능하다는 것을 보여주기 위한 구현일 뿐, 실제로 원형의 이점을 살리기 위해서라면 배열로 풀이해야 한다.
  원형으로 구현하는 이유는 뒤쪽으로 요소를 채우다가 공간이 다 차게되면 `tail`과 `head`를 연결해 앞쪽의 빈 공간을 활용하려는 의도인데, 연결 리스트는 애초에 빈 공간이라는 개념이 존재하지 않기 때문에 원형은 아무런 의미가 없다. 또한 데크의 연산은 맨 처음과 맨 끝의 값을 추출할 뿐이며 맨 끝의 다음 값을 추출하는지 등의 연산은 존재하지 않기 때문에, 서로 연결되어 있을 필요 또한 없다.

### 우선순위 큐
>[!우선순위 큐]
>우선순위 큐는 큐 또는 스택과 같은 추상 차료형과 유사하지만 추가로 각 요소의 '우선순위'와 연관되어 있다.

- 우선순위 큐는 어떠한 특정 조건에 따라 우선순위가 가장 높은 요소가 추출되는 자료형이다. 대표적으로 최댓값 추출을 들 수 있는데, 예를 들어 큐에 `[1, 4, 5, 3, 2]`가 들어 있고 최댓값을 추출하는 우선순위 큐가 있다고 가장한다. 이 경우 항상 남아 있는 요소들의 최댓값이 우선순위에 따라 추출되어 `5, 4, 3, 2, 1` 순으로 추출된다.
  이는 정렬 알고리즘을 사용하면 우선순위 큐를 만들 수 있다는 의미이기도 하다. n개의 요소를 정렬하는 데 *S(n)* 의 시간이 든다고 할때, 새 요소를 삽입하거나 요소를 삭제하는 데는 *O(S(n))* 의 시간이 걸린다. 반면 내림차순으로 정렬했을 때 최댓값을 가져오는 데는 맨 앞의 값을 가져오기만 하면 되므로 *O(1)* 로 가능하다. 대개 정렬에는 *O(n log n)* 이 필요하기 때문에 *O(S(n))* 은 *O(n log n)* 정도가 든다. 그러나 실제로는 이처럼 단순 정렬보다는 힙 정렬 등의 좀 더 효율적인 방법을 활용한다.
- 이외에도 최단 경로를 탐색하는 다익스트라 알고리즘 등 우선순위 큐는 다양한 분아에 활용되며 힙 자료구조와도 관련이 깊다.

### 27. k개 정렬 리스트 병합 (리트코드 23)
>k개의 정렬된 리스트를 1개의 정렬된 리스트로 병합하라.

- 1. 우선순위 큐를 이용한 리스트 병합
	- 우선순위 큐는 힙과 관련이 깊다. 특히 파이썬에서는 대부분의 우선순위 큐 풀이에 거의 항상 heapq 모듈을 사용한다.
```python
for lst in lists:
	heapq.heappush(heap, (lst.val, lst))	
```    

- 이 코드는 각 연결 리스트의 루트를 힙에 저장하게 된다. 파이썬의 `heapq` 모듈은 최소 힙(Min Heap)을 지원하며, 따라서 `lst.val` 이 작은 순서대로 `pop()` 할 수 있다. 그런데 이렇게 저장하면 `TypeError: '<' not supported between instances of 'ListNode' and 'ListNode'` 에러가 발생한다. 이 에러 메시지는 '중복된 값을 넣을 수 없다' 라는 뜻이다.
- 이 문제의 예제로 제시한 입력값은 3개의 연결 리스트 중 첫 번째와 두 번째의 루트가 각각 1로 동일하다. 이렇게 동일한 값은 `heappush()` 함수에서 에러를 발생하기 때문에 중복된 값을 구분할 수 있는 추가 인자가 필요하다. 오로지 에러를 방지하기 위한 용도로 연결 리스트의 순서를 적절히 삽입해본다. 코드는 다음과 같이 수정한다.
```python
for i in range(len(lists)):
	...
	heapq.heappush(heap, (list[i].val, i, lists[i]))
```

- `heappop()`으로 값을 추출하면 가장 작은 노드의 연결 리스트부터 차례대로 나오게 되며, 이 값을 결과가 될 노드 `result`에 하나씩 추가한다. 아울러 k개의 연결 리스트가 모두 힙에 계속 들어 있어야 그중에서 가장 작은 노드가 항상 차례대로 나올 수 있으므로 추출한 연결 리스트의 그다음 노드는 다시 힙에 추가한다.
```python
while heap:
	node = heapq.heappop(heap)
	idx = node[1]
	result.next = node[2]

	result = result.next
	if result.next:
		heapq.heappush(heap, (result.next.val, idx, result.next))
```

- 이렇게 힙에 아무 값도 남지 않을 때까지 반복하면 result에는 작은 노드부터 차례대로 연결된다.

>[!PriorityQueue vs heapq]
>파이썬에서 우선순위 큐는 queue 모듈의 PriorityQueue 클래스를 이용해 사용할 수 있다.
>PriorityQueue라는 이름 또한 뜻을 그대로 나타내므로 직관적이라 좋아 보인다. 그러나 앞서 설명과 같이 우선순위 큐는 힙을 사용해 주로 구현하며, 파이썬의 PriorityQueue 조차 내부적으로는 heapq를 사용하도록 구현되어 있다. CPython에서 PriorityQueue 클래스는 파이썬 코드로 다음과 같이 선언되어 있다.
>```python
># cpython/Lib/queue.py
>class PriorityQueue(Queue):
>	...
>	def \_put(self, item):
>		heappush(self.queue, item)
>	def \_get(self, item):
>		return heappop(self.queue)
>```
>코드에서 보듯이, `PriorityQueue`의 `_get()`, `_put()`은 모두 `heapq` 모듈의 `heappop()`과 `heappush()`를 그대로 이용하므로 사실상 둘은 동일하다. 그렇다면 차이점은 무엇일까? 차이점은 여기에 스레드 세이프(Thread-Safe)(멀티 스레드에도 안전한 프로그래밍 개념. 만약 스레드 세이프 하지 않은 경우 1번 스레드의 값이 2번 스레드에서 변경될 수 있어 문제가 발생한다.) 클래스라는 점이며, `heapq` 모듈은 스레드 세이프를 보장하지 않는다.
>파이썬은 GIL의 특성상 멀티 스레딩이 거의 의마가 없기 때문에 대부분 멀티 프로세싱으로 활용한다는 점을 생각해보면, `PriorityQueue` 모듈의 멀티 스레딩 지원은 사실 큰 의미는 없다. 또한 스레드 세이프를 보장한다는 얘기는 내부적으로 락킹(Locking)을 제공한다는 의미이므로 락킹 오버헤드(Locking Overhead)가 발생해 성능에 영향을 끼친다. 따라서 굳이 멀티 스레드로 구현할 게 아니라면 `PriorityQueue` 모듈은 사용할 필요가 없다.
>실무에서도 우선순위 큐는 대부분 `heapq`로 구현하고 있으며, 이 책에 등장하는 모든 우선순위 큐를 사용하는 문제 풀이 또한 `heapq`를 사용해 풀이한다.

>[!파이썬 저역 인터프리터 락(GIL)]
>아마도 '파이썬은 왜 느린가?'를 애기할 때 가장 자주 듣게 되는 얘기가 전역 인터프리터 락(Global Interpreter Lock, 이하 GIL)이 아닐까 싶다. 파이썬 최초의 공식 구현체인 CPython은 개발 초기에 번거로운 동시성 관리를 편리하게 하고 스레드 세이프하지 않은 CPython의 메모리 관리를 쉽게 하기 위해, GIL로 파이썬 객체에 대한 접근을 제한하는 형태로 설계했다.
>GIL은 전역 인터프리터 락의 약어로서, 하나의 스레드가 자원을 독점하는 형태로 실행된다. CPython 개발이 시작된 것이 1994년이었으니, CPU가 하나던 당시에는 충분히 그런 선택을 할 만했고, GIL 디자인에는 아무런 문제가 없었다. 하지만 지금처럼 멀티 코어가 당연한 세상에서, 하나의 스레드가 자원을 독점하는 형태로 실행되는 제약은 매우 치명적이다.
>최근 들어 `PriorityQueue` 모듈을 비롯해, 한계를 극복하기 위한 다양한 시도를 하고 있지만 이미 과거부터 GIL에 의존하는 형태로 구현된 기능들이 대부분을 차지하고 있어, 이러한 제약을 극복하기가 쉽지 않다. 여러 차례GIL을 걷어내려는 시도가 있어 왔지만 지금까지도 GIL은 파이썬의 주요 특징으로 남아 있다.





