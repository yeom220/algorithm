>[!비선형 자료구조]
>데이터 요소가 순차적(Sequential)으로 또는 선형으로 배열되지 않는 자료구조를 비선형(Non-Linear) 자료구조라고 한다. 비선형 자료구조는 선형과 달리 멀티 레벨로 구성된다. 트리를 떠올리면 이해가 쉬운데, 이 때문에 탐색이 복잡하고 선형에 비해 구현하기도 다소 번잡한 편이지만, 메모리를 좀 더 효율적으로 활용할 수 있다는 장점이 있다. 대표적으로는 그래프를 예로 들 수 있으며, 그래프의 범주에 포함되는 트리 또한 비선형 자료구조다.
>

>[!그래프]
>수학에서, 좀 더 구체적으로 그래프 이론에서 그래프란 객체의 일부 쌍(pair)들이 '연관되어' 있는 객체 집합 구조를 말한다.

### 오일러 경로
오일러의 스케치를 현대식 그래프 구조에 따라 A부터 D까지를 정점(Vertex), a부터 g까지는 간선(Edge)으로 구성된 그래프라는 수학적 구조를 찾아볼 수 있다.
오일러는 모든 정점이 짝수 개의 차수(Degree)를 갖는다면 모든 다리를 한 번씩만 건너서 도달하는 것이 성립한다고 말했다. 칼 히어홀저가 이를 수학적으로 증명해낸다. 이를 '오일러의 정리(Euler's Theorem)'라 부른다. 아울러 모든 간선을 한 번씩 방문하는 유한 그래프(Finite Graph)를 일컬어 오일러 경로(Eulerian Trail/Eulerian Path)라 부른다.

### 해밀턴 경로
>해밀턴 경로는 각 정점을 한 번씩 방문하는 무향 또는 유향 그래프 경로를 말한다.

해밀턴 경로(Hamiltonian Path)와 오일러 경로의 차이점을 들자면, 오일러 경로는 간선을 기준으로 하고 해밀턴 경로는 정점을 기준으로 한다는 점이다. 그러나 이러한 단순한 차이에도 불구하고 놀랍게도 해밀턴 경로를 찾는 문제는 최적 알고리즘이 없는 대표적인 NP-완전(Complete) 문제다. (NP 문제 중 NP-난해(hard))인 문제를 NP-완전 문제라 부른다.)

원래의 출발점으로 돌아오는 경로는 특별히 해밀턴 순환이라 하는데, 이중에서도 특히 최단 거리를 찾는 문제는 알고리즘 분야에서는 외판원 문제(Travelling Salesman Problem)로도 유명하다. 외판원 문제란 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 문제, 즉 최단 거리인 해밀턴 순환을 찾는 문제이며, NP-난해 문제로 이론 컴퓨터과학 분야의 매우 중요한 문제 중 하나이기도 하다.
외판원 문제를 좀 더 살펴보자. 미국의 각 도시를 한 번씩 방문한다고 했을 때, 어떤 순서로 방문해야 가장 짧은 거리가 될까? 만약 도시가 20개라고 할 때 이 문제의 정답을 찾기 위해 다녀야 하는 총 경로의 수는 20!(`20! = 2,432,902,008,176,640,000`)다. 그러니까 약 240경 번의 경로를 다녀봐야 가장 짧은 경로를 찾을 수 있다. 문제는 단순하지만 정답은 실로 엄청나다.

>[!NP복잡도]
>NP는 비결정론적 튜링 기계(NTM)로 다항 시간 안에 풀 수 있는 판정 문제의 집합으로, NP는 비결정론적 다항시간(Non-deterministic Polynomial time)의 약자다.
>NP에 속하는 문제는 결정론적 튜링 기계로 다항 시간에 검증이 가능하고, 그 역도 성립한다. 또한 결정론적 튜링 기계로 다항 시간안에  풀 수 있는 문제는 비결정론적 튜링 기계로도 다항 시간안에 풀 수 있으므로, P 집합은 NP 집합의 부분집합이다. 이때 P가 NP의 진부분집합(Proper Subset)인지, 혹은 P와 NP가 같은지에 대해서는 아직 알려지지 않았다. 이 문제는 P-NP 문제로 불리우며 컴퓨터과학 분야의 대표적인 미해결 문제 중 하나다. 클레이 수학 연구소에서 발표한 7개의 밀레니엄 문제(미해결 문제) 중 하나이며 해결하는 사람에게 100만 달러의 상금이 걸려 있기도 하다.
>그런데 앞서 설명을 보면서 다소 혼동되는 부분이 한 군데 있을 것이다. 왜 해밀턴 경로 문제와 외판원 문제의 NP 문제가 다를까? 먼저, 혼동될 수 있으니 3가지 문제의 구분부터 다시 한번 살펴본다.
>- 해밀턴 경로: 한 번만 방문하는 경로
>- 해밀턴 순환: 한 번만 방문하여 출발지로 돌아오는 경로
>- 외판원 문제: 한 번만 방문하여 출발지로 돌아오는 경로 중 가장 짧은 경로
>따라서 이 세 문제는 '해밀턴 경로 > 해밀턴 순환 > 외판원 문제'의 포함 관계를 이룬다. 이제 해밀턴 경로와 외판원 문제, 2가지 문제를 다시 한번 정의해보자.
>1. 해밀턴 경로가 존재하는가?
>2. 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾아라.(최단 거리 해밀턴 순환을 찾아라.)
>
>이제, 이 두 문제에 어떤 차이가 있는지 판별할 수 있는가?
>다음으로 NP-완전 문제의 조건은 다음과 같다.
>- NP 문제다.
>- NP-난해 문제다.
>
>앞서 P-NP 문제는 컴퓨터과학 분야의 대표적인 미해결 문제 중 하나라고 했는데, 이에 따라 *P != NP* 인 경우와 *P == NP* 의 NP-완전, NP-난해 문제 집합에 대한 관계다. 참고로 *P != NP* 일 것이라고 많은 사람들이 추측만 할 뿐이며 아직 증명되지 않았다. 어느 경우이든 NP이면서 NP-난해 문제인 경우를 NP-완전 문제라 한다.
>앞서 1번 문제는 결정 문제(Decision Problem)로 다항 시간에 정답을 검증할 수 있다. 즉 NP 문제이며, NP-난해 문제다. NP-완전 문제의 조건에 부합하며 따라서 1번 문제는 NP-완전 문제다. 그러나 2번 문제는 결정 문제가 아니므로 NP 문제가 아닐 수 있다. 증명할 수 있는 NP-난해 문제이지만 NP 문제가 아닐 수 있으므로 NP-완전 문제가 아니다. 따라서 2번은 NP-난해 문제다.

외판원 문제는 다이나믹 프로그래밍 기법을 활용하면 좀 더 최적화할 수 있다. 이 경우 *O(n^2 2^n)* 로 최적화할 수 있는데, 앞서 n=20인 경우 419,430,400 로 여전히 엄청난 수치이긴 하지만 240경 번이었던 이전에 비해서는 훨씬 더 빠르게 계산할 수 있다.

### 그래프 순회
>그래프 순회란 그래프 탐색(Search)이라고도 불리우며 그래프의 각 정점을 방문하는 과정을 말한다.

그래프의 각 정점을 방문하는 그래프 순회(Graph Traversals)에는 크게 깊이 우선 탐색(Depth-First Search)과 너비 우선 탐색(Breadth-First Search)의 2가지 알고리즘이 있다. DFS는 일반적으로 BFS에 비해 더 널리 쓰인다. 코딩 테스트 시에도 대부분의 그래프 탐색은 DFS로 구현하게 될 것이다.
DFS는 주로 스택으로 구현하거나 재귀로 구현하며, 이후에 살펴볼 백트래킹을 통해 뛰어난 효용을 보인다. 반면, BFS는 주로 큐로 구현하며, 그래프의 최단 경로를 구하는 문제 등에 사용된다. 다익스트라 알고리즘으로 최단 경로를 찾는 문제에서 BFS로 구현하는 코드를 살펴보게 될 것이다.

그래프를 표현하는 방법에는 크게 인접 행렬(Adjacency Matrix)와 인접 리스트(Adjacency List)의 2가지 방법이 있다. 인접 리스트는 출발 노드를 키로, 도착 노드를 값으로 표현할 수 있다. 도착 노드는 여러 개가 될 수 있으므로 리스트 형태가 된다. 파이썬의 딕셔너리 자료형으로 다음과 같이 나타낼 수 있다.
```python
graph = {
	 1: [2, 3, 4],
	 2: [5],
	 3: [5],
	 4: [],
	 5: [6, 7],
	 6: [],
	 7: [3],
}
```
이 딕셔너리를 입력값으로 해서 각각 DFS, BFS를 구현해보고 어떤 결과가 나오는지 살펴본다.

### DFS(깊이 우선 탐색)
>일반적으로 DFS는 스택으로 구현하며, 재귀를 이용하면 좀 더 간단하게 구현할 수 있다.

**재귀 구조로 구현**
재귀를 이용한 DFS를 구현해본다. 먼저, 위키피디아에 제시된 수도코드는 다음과 같다.
```python
# 재귀를 이용한 DFS 구현 수도코드
DFS(G, v)
	label v as discovered
	for all directed edges from v to w that are in G.adjacentEdges(v) do
		if vertex w is not laveled as discovered then
			recursively call DFS(G, w)
```
이 수도코드에는 정점 `v`의 모든 인접 유향(Directed) 간선들을 반복하라고 표기되어 있다.
이 수도코드의 알고리즘을 동일하게 파이썬 코드로 구현해보면 다음과 같다.
```python
def recursive_dfs(v, discovered=[]):
	discovered.append(v)
	for w in graph[v]:
		if not w in discovered:
			discovered = recursive_dfs(w, discovered)
	return discovered
```
방문했던 정점, 즉 `discovered`를 계속 누적된 결과로 만들기 위해 리턴하는 형태만 받아오도록 처리했을 뿐 다른 부분들은, 수도코드와 맞춰서 작성해봤다. 위의 그래프를 입력값으로 한 탐색 결과는 다음과 같다.
```python
>>> f'recursive dfs: {recursive_dfs(1)}'
'recursive dfs: [1, 2, 5, 6, 7, 3, 4]'
```

**스택을 이용한 반복 구조로 구현**
```python
# 반복을 이용한 DFS 구현 수도코드
DFS-iterative(G, v)
	let S be a stack
	S.push(v)
	while S is not empty do
		v = S.pop()
		if v is not labeled as discovered then
			label v as discovered
			for all edges from v to w in G.adjacentEdges(v) do
				S.push(w)
```
스택을 이용해 모든 인접 간선을 추출하고 다시 도착점인 정점을 스택에 삽입하는 구조로 구현되어 있다. 파이썬 코드로 구현하면 다음과 같다.
```python
def iterative_dfs(start_v):
	discoverd = []
	stack = [start_v]
	while stack:
		v = stack.pop()
		if v not in discovered:
			discovered.append(v)
			for w in graph[v]:
				stack.append(w)
	return discovered
```
이와 같은 반복 구현은, 앞서 코드가 길고 빈틈없어 보이는 재귀 구현에 비해 우아함은 떨어지지만, 좀 더 직관적이라 이해하기는 훨씬 더 쉽다. 실행 속도 또한 더 빠른 편이다. 대부분의 경우 재귀 구현은 반복으로, 반복 구현은 재귀로 바꿔서 알고리즘을 구현 할 수 있다. 위의 그래프를 입력값으로 한 탐색 결과는 다음과 같다.
```python
>>> f'iterative dfs: {iterative_dfs(1)}'
'iterative dfs: [1, 4, 3, 5, 7, 6, 2]'
```

똑같은 DFS인데 순서가 다르다. 어떤 차이가 있을까? 재귀 DFS는 사전식 순서(Lexicographical Order)로 방문한 데 반해 반복 DFS는 역순으로 방문했다. 스택으로 구현하다 보니 가장 마지막에 삽입된 노드부터 꺼내서 반복하게 되고 이 경우 인접 노드에서 가장 최근에 담긴 노드, 즉 가장 마지막부터 방문하기 때문이다. 인접 노드를 한꺼번에 추가하는 형태이기 때문에, 자칫 BFS가 아닌가 하고 헷갈릴 수 있지만 깊이 우선으로 탐색한다는 점에서 DFS가 맞다. 만약 BFS라면 \[..., 4, 3, 5, ...] 순서가 아니라 \[..., 4, 3, 2, ...] 순서가 되어야 할 것이다.

### BFS(너비 우선 탐색)
>BFS는 DFS보다 쓰임새는 적지만 최단 경로를 찾는 다익스트라 알고리즘 등에 매우 유용하게 쓰인다.

**큐를 이용한 반복 구조로 구현**
BFS를 반복 구조로 구현할 때는 큐를 이용한다. 수도코드는 다음과 같다.
```python
# 큐를 이용한 BFS 수도코드
BFS(G, start_v)
	let Q be a queue
	label start_v as discovered
	Q.enqueue(start_v)
	while Q is not empty do
		v := Q.dequeue()
		if v is the goal then
			return v
		for all edges from v to w in G.adjacentEdges(v) do
			if w is not labeled as discovered then
				lavel w as discoverd
				w.parent := v
				Q.enqueue(w)
```
모든 인접 간선을 추출하고 도착점인 정점을 큐에 삽입하는 수도코드다. 이를 파이썬 코드로 구현하면 다음과 같다.
```python
def iterative_bfs(start_v):
	discovered = [start_v]
	queue = [start_v]
	while queue:
		v = queue.pop(0)
		for w in graph[v]:
			if w not in discovered:
				discovered.append(w)
				queue.append(w)
	return discovered
```
리스트 자료형을 사용했지만 `pop(0)`과 같은 큐의 연산만을 사용했다. 좀 더 최적화를 위해서는 데크 같은 자료형을 사용해 보는 것을 고민해볼 수 있다. 그래프를 입력값으로 한 탐색결과는 다음과 같다
```python
>>> f'iterative bfs:{iterative_bfs(1)}'
'iterative bfs: [1, 2, 3, 4, 5, 6, 7]'
```
BFS의 경우 단계별 차례인 숫자 순으로 실행됐으며, 1부터 순서대로 각각의 인접 노드를 우선으로 방문하는 너비 우선 탐색이 잘 실행됐음을 확인할 수 있다.

**재귀 구현 불가**
BFS를 재귀로 풀이해볼 수 있을까?
사실 많은 이가 혼동하는 부분인데 BFS는 재귀로 동작하지 않는다. 큐를 이용하는 반복 구현만 가능하다. 이 부분을 혼동하면 풀이에 어려움을 겪을 수 있다.

### 백트래킹
>백트래킹(Backtracking)은 해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단되는 즉시 후보를 포기(백트랙 Backtrack)해 정답을 찾아가는 범용적인 알고리즘으로 제약 충족 문제(Constraint Satisfaction Problems)에 특히 유용하다.

백트래킹은 탐색을 하다가 더 갈 수 없으면 왔던 길을 되돌아가 다른 길을 찾는다는 데서 유래했다. 백트래킹은 DFS와 같은 방식으로 탐색하는 모든 방법을 뜻하며, DFS는 백트래킹의 골격을 이루는 알고리즘이다. 백트래킹은 주로 재귀로 구현하며, 알고리즘마다 DFS 변형이 조금씩 일어나지만 기본적으로 모두 DFS의 범주에 속한다. 백트래킹은 가보고 되돌아오고를 반복한다. 운이 좋으면 시행착오를 덜 거치고 목적지에 도착할 수 있지만 최악의 경우에는 모든 경우를 다 거친 다음에 도착할 수 있다. 이 때문에 브루트 포스와 유사하다. 하지만 한번 방문 후 가능성이 없는 경우에는 즉시 후보를 포기한다는 점에서 매번 같은 경로를 방문하는 브루트 포스보다는 훨씬 우아한 방식이라 할 수 있다.
브루트 포스로 전체 트리를 탐색한다면 매우 긴 시간이 소요된다. 하지만 DFS로 탐색을 시도하고, 가능성이 없는 후보는 즉시 포기하고 백트래킹한다면 트리의 불필요한 거의 대부분을 버릴 수 있다. 이를 트리의 가지치기(Pruning)라고 하며, 이처럼 불필요한 부분을 일찍 포기한다면 탐색을 최적화할 수 있기 때문에, 가지치기는 트리의 탐색 최적화 문제와도 관련이 깊다.

### 제약 충족 문제
백트래킹은 제약 충족 문제(Constraint Satisfaction Problems)를 풀이하는 데 필수적인 알고리즘이다. 앞서 살펴본 가지치기를 통해 제약 충족 문제를 최적화 하기 때문이다.
>제약 충족 문제란 수많은 제약 조건(Constraints)을 충족하는 상태(States)를 찾아내는 수학 문제를 일컫는다.

특히 제약 충족 문제는 인공지능이나 경영 과학 분야에서 심도 있게 연구되고 있으며, 합리적인 시간내에 문제를 풀기 위해 휴리스틱과 조합 탐색 같은 개념을 함께 결합해 문제를 풀이한다. 제약 충족 문제는 대표적으로 스도쿠(Sudoku)처럼 1에서 9까지 숫자를 한 번만 넣는(제약 조건 충족) 정답(상태)을 찾아내는 모든 문제 유형을 말한다. 스도쿠를 잘 풀이하려면 백트래킹을 하면서 가지치기를 통해 최적화하는 형태로 풀이할 수 있다.
스도쿠 외에도 십자말 풀이, 8퀸 문제, 4색 문제 같은 퍼즐 문제와 배낭 문제, 문자열 파싱, 조합 최적화 문제 등이 모두 제약 충족 문제에 속한다.

----
### 32. 섬의 개수
>1을 육지로, 0을 물로 가정한 2D 그리드 맵이 주어졌을때, 섬의 개수를 계산하라.
>(연결되어 있는 1의 덩어리 개수를 구하라.)

###### 1. DFS로 그래프 탐색
이 문제는 쾨니히스베르크의 다리 문제처럼 반드시 그래프 모양이 아니더라도 그래프형으로 변환해서 풀이할 수 있음을 확인해보는 좋은 문제다. 입력값이 정확히 그래프는 아니지만 사실상 동서남북이 모두 연결된 그래프로 가정하고 동일한 형태로 처리할 수 있으며, 네 방향 각각 DFS 재귀를 이용해 탐색을 끝마치면 1이 증가하는 형태로 육지의 개수를 파악할 수 있다.

먼저, 행렬 입력값인 grid의 행, 열 단위로 육지(1)인 곳을 찾아 진행하다가 육지를 발견하면 그때부터 `self.dfs()`를 호출해 탐색을 시작한다.
DFS 탐색을 하는 `dfs()` 함수는 동서남북을 모두 탐색하면서 재귀호출한다. 함수 상단에는 육지가 아닌 곳은 `return`으로 종료 조건을 설정해둔다. 이렇게 재귀 호출이 백트래킹으로 모두 빠져 나오면 섬 하나를 발견한 것으로 간주한다. 이때 이미 방문했던 곳은 1이 아닌 값으로 마킹한다. 즉 육지(1)를 더 이상 육지가 아닌 것으로 만든다. 그래야 다음에 다시 계산하는 경우가 생기지 않는다. 일종의 가지치기다. 간혹 또 다른 행렬을 생성해 그곳에 방문했던 경로를 저장하는 형태로 풀이하는 경우가 있는데, 이 문제는 그렇게 풀이할 필요가 없다. 곰곰이 생각해보면 현재의 행렬에 방문한 경로를 표시해두는 것으로도 충분하기 때문이다. 아울러 별도의 행렬을 생성할 경우 공간 복잡도가 *O(n)* 이 되기 때문에 공간의 활용 또한 비효율적이다.

dfs() 함수를 빠져 나온 후에는 해당 위치에서 탐색할 수 있는 모든 육지를 탐색한 것이므로, 카운트를 1 증가시킨다. 이제 입력값이 비어 있는 경우에 대해 예외처리를 포함한다.

>[!중첩 함수]
>중첩 함수(Nested Function)란 함수 내에 위치한 또 다른 함수로, 바깥에 위치한 함수들과 달리 부모 함수의 변수를 자유롭게 읽을 수 있다는 장점이 있다. 실무에서 자주 쓰이는 편은 아니지만 단일 함수로 해결해야 하는 경우가 잦은 코딩 테스트에서는 매우 자주 쓰이는 기능이다. 이 책에서도 대부분의 문제 풀이는 중첩 함수를 적극적으로 활용해 풀이한다. 중첩 함수가 부모 함수의 변수를 공유하는 예제는 다음과 같다.
> ```python
>def outer_function(t: str):
>	text: str = t
>
>	def inner_function():
>		print(text)
>		
>	inner_function()
>	
>outer_function('Hello!')
>----
>Hello!
>```
>
>여기서 `outer_function()`은 `inner_function()`을 호출했고, 아무런 파라미터도 넘기지 않았지만 부모 함수의 `text` 변수를 자유롭게 읽어들여 그 값인 `Hello!`를 출력했다. 이처럼 매번 파라미터를 전달하지 않아도 되기 때문에 구현이 깔끔해진다는 장점이 있다. 아울러 가변 객체인 경우 `append()`, `pop()`등 여러 가지 연산으로 조작도 가능하다. 그러나 재할당(=)이 일어날 경우 참조 ID가 변경되어 별도의 로컬 변수로 선언되므로 이 부분은 주의가 필요하다.
>
>**연산자 조작**
>중첩 함수에서 부모 함수에서 선언한 변수를 연산자로 조작하는 경우를 살펴본다.
>```python
>def outer_function(a: List[int]):
>	b: List[int] = a
>	print(id(b), b)
>	
>	def inner_function1():
>		b.append(4)
>		print(id(b), b)
>		
>	def inner_function2():
>		print(id(b), b)
>		
>	inner_function1()
>	inner_function2()
>	
>outer_function([1,2,3])
>-------
>4598336160 [1, 2, 3]
>4598336160 [1, 2, 3, 4]
>4598336160 [1, 2, 3, 4]
>```
>
>리스트는 가변 객체이며, 이처럼 중첩 함수내에서 `b.append(4)`와 같은 형태로 `append()` 메소드를 사용해 변수를 조작할 수 있다. 이렇게 조작된 값은 부모 함수에서도 그대로 동일하게 적용된다.
>
>**재할당**
>이번에는 재할당으로 참조 ID가 변경되는 경우를 살펴보자.
>```python
>def outer_function(t: str):
>	text: str = t
>	print(id(text), text)
>	
>	def inner_function1():
>		text = 'World!'
>		print(id(text), text)
>
>	def inner_function2():
>		print(id(text), text)
>		
>	inner_function1()
>	inner_function2()
>	
>outer_function('Hello!')
>-------
>4599124144 Hello!
>4599130288 World!
>4599124144 Hello!
>```
>
>여기서는 불변 객체인 문자형을 예로 들었다. 문자열은 불변 객체이기 때문에 조작할 수 없다. 값을 변경하려면 `text = 'World!'`와 같은 형태로 새롭게 재할당할 수밖에 없다. `=`연산자로 변수를 새롭게 할당하는 경우, 기존에 `4599124144`이었던 ID 값이 `4599130288`로 변경됨을 확인할 수 있다. 즉 참조 ID가 변경되어 서로 다른 변수가 된다. 중첩 함수인 경우에는 함수 내에서만 사용 가능한 새로운 로컬 변수로 선언되며, 여기서 수정된 값, 즉 재할당된 값은 부모 함수에서는 반영되지 않으므로 주의가 필요하다.

-----
### 33. 전화 번호 문자 조합
>2에서 9까지 숫자가 주어졌을 때 전화 번호로 조합 가능한 모든 문자를 출력하라.

###### 1. 모든 조합 탐색
이 문제는 전체를 탐색하여 풀이할 수 있다. 항상 전체를 탐색해야 하고 가지치기 등으로 최적화할 수 있는 문제는 아니기 때문에 어떻게 풀이하든 결과는 비슷하다. 가능한 경우의 수를 모두 조합하는 형태로 전체를 탐색한 후 백트래킹 하면서 결과를 조합할 수 있다.
`digits`은 입력값이며, 각 자릿수에 해당하는 키판 배열을 DFS로 탐색하면 결과가 완성된다. 
`dic`은 키판 배열이다. 입력값을 자릿수로 쪼개어 반복하고, 숫자에 해당하는 모든 문자열을 반복하면서 마찬가지로 문자 단위로 재귀 탐색한다. `dfs()`함수는 자릿수가 동일할 때까지 재귀 호출을 반복하다 끝까지 탐색하면 결과를 추가하고 리턴한다. 이렇게 하면 모든 경우의 수를 DFS로 탐색하고 백트래킹으로 결과를 조합하면서 리턴하게 된다.

----
### 34. 순열
>서로 다른 정수를 입력받아 가능한 모든 순열을 리턴하라.

###### 1. DFS를 활용한 순열 생성
순열의 수 수식은 `3! / (3 - 3)!`이 되고, 분모는 1이므로 분자의 팩토리얼(factorial)만 계산하면 순열의 수는 6이 된다. 실제로 문제의 출력에는 6개의 결과가 있다. 이처럼 개수를 구하는 건 어렵지 않다. 그러나 이 문제는 모든 결과를 생성해내야 하는데 생성하는 문제일 때, 경우의 수만 계산하는것에 비해서는 다소 까다로운 편이다. 순열이란 결국 모든 가능한 경우를 그래프 형태로 나열한 결과라고 할 수 있기 때문에 그래프로 표현할 수 있다. 그래프의 모든 리프 노드가 순열의 최종 결과다. 가만히 살펴보면 레벨이 증가할수록 자식 노드의 개수는 점점 작아진다. 처음에는 자식노드가 3개 였다가 2개, 1개 순으로, 이는 순열의 수식이기도한 `3 * 2 * 1` 형태이기도 하다. 이제 dfs 탐색 함수를 만들어본다.
```python
def dfs(elements):
	# 리프 노드일 때 결과 추가
	if len(elements) == 0:
		results.append(prev_elements[:])
	
	# 순열 생성 재귀 호출
	for e in elements:
		next_elements = elements[:]
		next_elements.remove(e)
		
		prev_elements.append(e)
		dfs(next_elements)
		prev_elements.pop()
```

이전 값을 하나씩 덧붙여 계속 재귀 호출을 진행하다 리프 노드에 도달한 경우, 결과를 하나씩 담는다. 이때 중요한 부분은 결과를 추가할 때 `prev_elements[:]`로 처리해야 한다는 점이다. 파이썬은 모든 객체를 참조하는 형태로 처리되므로 만약 `results.append(prev_elements)`를 하게 되면 결과 값이 추가되는 게 아닌 `prev_elements`에 대한 참조가 추가되며, 이 경우 참조된 값이 변경될 경우 같이 바뀌게 된다. 따라서 반드시 값을 복사하는 형태로 참조 관계를 갖지 않도록 처리해야 한다. `[:]`로 처리하는 방법 외에도 `copy()`를 하거나, 복잡한 리스트는 `deepcopy()`로 처리하는 방법도 있다. 이 부분만 주의해 순열 생성을 계속 재귀 호출하면 풀이를 완성할 수 있다.

###### 2. itertools 모듈 사용
파이썬에는 itertools라는 모듈이 있다. itertools 모듈은 반복자 생성에 최적화된 효율적인 기능들을 제공하므로, 실무에서는 알고리즘으로 직접 구현하기보다는 가능하다면 itertools 모듈을 사용하는 편이 낫다. 이미 잘 구현된 라이브러리라 직접 구현함에 따른 버그 발생 가능성이 낮고, 무엇보다 효율적으로 설계된 C 라이브러리라 속도에도 이점이 있다. 전체 코드를 살펴보면 다음과 같다.
```python
def permute(self, nums: List[int]) -> List[List[int]]:
	return list(itertools.permutations(nums))
```

이 문제는 어이 없을 정도로 쉽게 풀이가 가능하다. 게다가 리트코드에서 36밀리초에 실행되는데, 이 정도면 상위 5%이내에 드는 매우 빠른 속도다. 파이썬 코드로 아무리 효율적인 알고리즘을 작성한다 해도 이보다 빨리 실행되기는 힘들 것이다. 딱 한가지 걸리는 부분은, 이 함수의 결과가 리스트 내 튜플(Tuple)이라는 점이다. `permutations()` 함수가 튜플 모음을 반환하기 때문이다. 리트코드 문제에서는 리스트를 반환하도록 요구하기 때문에 실제로는 전체 코드에서 다음과 같이 변환해서 처리해야 한다.
``` python
def permute(self, nums: List[int]) -> List[List[int]]:
	return list(map(list, itertools.permutations(nums)))
```

| 풀이  | 방식              | 실행 시간 |
| --- | --------------- | ----- |
| 1   | DFS를 활용한 순열 생성  | 40ms  |
| 2   | itertools 모듈 사용 | 36ms  |

>[!문법] 객체 복사
>파이썬의 중요한 특징 중 하나는 모든 것이 객체라는 점이다. 심지어 숫자, 문자까지도 모두 객체다. 숫자, 문자가 리스트, 딕셔너리 같은 객체와의 차이점이라면 불변 객체라는 차이뿐이다. 그러다 보니 별도로 값을 복사하지 않는 한, 변수에 값을 할당하는 모든 행위는 값 객체에 대한 참조가 된다. 이 말은 참조가 가리키는 원래의 값을 변경하면 모든 참조, 즉 모든 변수의 값 또한 함께 변경된다는 말이기도 하다. 이 같은 특징은 C에서 포인터를 자주 사용해온 오래된 개발자거나 C++에서 참조를 경험해본 개발자에게는 익숙하지만 대부분의 사람들에게는 생소할 것이고, 이 같은 파이썬의 특징은 충분히 숙지할 필요가 있다.
>그렇다면 참조가 되지 않도록 값 자체를 복사하려면 어떻게 해야 할까? 가장 간단한 방법은 `[:]`로 처리하는 방법이다.
> ```python
> >>> a = [1, 2, 3]
> >>> b = a
> >>> c = a[:]
> >>> id(a), id(b), id(c)
> (4362781552, 4362781552, 4361580048)
> ```
> 
> `[:]`로 처리한 변수 c는 다른 ID를 갖는 것을 확인할 수 있다. 참조로 처리된 변수 b는 a와 동일한 ID를 갖지만 변수 c는 값 자체가 복사되어 새로운 객체가 되었다. 이외에도 좀 더 직관적으로 처리하는 방법은 다음과 같이 명시적으로 `copy()` 메소드를 사용하는 방법이다.
> ```python
> >>> d = a.copy()
> >>> id(a), id(b), id(c), id(d)
> (4362781552, 4362781552, 4361580048, 4363974768)
> ```
> 
> 이 경우 변수 d 또한 다른 ID를 갖는다. 값이 복사되어 새로운 객체가 되었음을 확인할 수 있다. 이처럼 단순한 리스트는 `[:]` 또는  `copy()` 로도 충분하지만, 복잡한 리스트의 경우 다음과 같이 `copy.deepcopy()`로 처리해야 한다. 그렇게 하면 복잡하게 중첩된 리스트도 문제 없이 복사된다.
> ```python
> >>> import copy
> >>> a = [1, 2, [3, 5], 4]
> >>> b = copy.deepcopy(a)
> >>> id(a), id(b), b
> (4480589512, 4481610824, [1, 2, [3, 5], 4])
> ```

----
### 35. 조합
>전체 수 n을 입력받아 k개의 조합(Combination)을 리턴하라.

###### 1. DFS로 k개 조합 생성

조합의 수를 구하는 수식은 `n! / k!(n-k)!`이며, 이 문제 예제 입력값의 경우 `4! / 2!(4-2)! = 6`으로, 6개의 결과가 있다. 순열의 경우 자기 자신을 제외하고 모든 요소를 `next_elements`로 처리했으나, 이와 달리 조합의 경우 자기 자신뿐만 아니라 앞의 모든 요소를 배제하고 `next_elemnets`를 구성한다.
```python
def dfs(elements, start: int, k: int):
	if k == 0:
		results.append(elements[:])
	
	for i in range(start, n + 1):
		elements.append(i)
		dfs(elements, i + 1, k - 1)
		elements.pop()
```

여기서는 1부터 순서대로 for 문으로 반복하되, 재귀 호출할 때 넘겨주는 값은 자기 자신 이전의 모든 값을 고정하여 넘긴다. 따라서 남아 있는 값끼리 나머지 조합을 수행하게 되며, `k=0`이 되면 결과에 삽입한다.

34번 순열 문제와 이 문제는 서로 비슷한 면이 있지만, 순열과 조합이 다르듯 구현 방식에도 차이가 있다. 무엇보다 이 문제는 모든 순열을 생성하는 34번 문제와 달리 k개의 조합만을 생성해야 한다는 제약 조건이 추가된 문제다. 따라서 `dfs()`함수에서 `k` 값을 별도로 전달받아 1씩 줄여난가며 재귀 호출하는 구조로, `k`가 0이 되면 바로 빠져나가는 로직이 추가되어 있다.

###### 2. itertools 모듈 사용
이 문제도 itertools를 이용해 한 줄 풀이가 가능하다.
```python
def combine(self, n: int, k: int) -> List[List[int]]:
	return list(itertools.combinations(range(1, n + 1), k))
```

온라인 코딩 테스트 시에는 이처럼 한 줄로 풀이해도 아무런 문제가 없으며 오히려 훨씬 빠르게 동작하고 또한 쉽게 풀이할 수 있으므로, 별다른 제약이 없다면 이렇게 풀이하는 법을 더 추천한다.

| 풀이  | 방식              | 실행 시간 |
| --- | --------------- | ----- |
| 1   | DFS로 k개 조햅 생성   | 536ms |
| 2   | itertools 모듈 사용 | 76ms  |
순열과 달리 이번 조합 문제의 경우 DFS와 모듈의 성능 차이가 꽤 큰 편이다. 모듈 자체의 성능이 좋은 것도 있지만 사실 이번에는 이해하기 쉽도록 구현하려다 보니 DFS 풀이를 다소 비효율적으로 구현하기도 했다. 이 풀이와는 달리 k와 n을 뒤집어서 k - 1을 재귀 호출하는 형태로 하면 탐색 범위를 훨씬 더 좁혀 나갈 수 있는 방법이 있는데, 이렇게 하면 아마 모듈과 비슷한 속도가 나올것 같다. 조합 문제의 좀 더 효율적인 풀이 알고리즘을 꼭 한번 찾아서 확인해보기 바란다.

>[!참고] 순열과 조합
>경우의 수를 구할 때, 모든 경우의 수를 하나씩 세기보다는 공식을 이용하면 더 빠르게 계산할 수 있다. 이때 식으로 이용할 수 있는 것이 순열과 조합이다.
>수식을 살펴보기 전에 먼저 간단한 예를 들어보자. 다음과 같이 `[A,B,C,D,E]` 5장의 카드에서 3장의 카드를 골라 순서대로 나열해 '세 자리로 된 문자'를 만드는 경우의 수는 몇 가지나 될까?
>
>첫 번째는 5장의 카드가 모두 들어갈 수 있다. 두 번째는 첫 번째에 들어간 카드를 제외한 4장이 들어갈 수 있다. 마지막으로 세 번째는 3장이 들어갈 수 있다. 따라서, 구하려는 경우의 수는 곱의 법칙(Product Rule)에 따라 5 \* 4 \* 3 = 60이 된다. 이것이 바로 순열이며 수식으로 정리하면 다음과 같다.
>`nPr = n! / (n - r)!` 
>
>그렇다면 조합은 무엇이며 어떻게 계산할까? 조합이란 순열과 달리 순서에 상관하지 않는 경우를 말한다. 즉 순열은 순서를 보지만 조합은 순서를 보지 않는다. 5장의 카드에서 3장을 골라내는 문제의 경우 `[A,B,C]` 3장으로 구성된 카드는 순열과 달리, 조합에서는 `[A,B,C],[A,C,B],[B,A,C].[B,C,A],[C,A,B],[C,B,A]` 총 6가지 경우를 모두 동일한 것으로 간주한다. 따라서 조합의 개수는 앞서 순열의 전체 개수에서 동일한 카드로 볼 수 있는 경우의 수인 `r!`으로 나눈 `nPr / r!`과 동일하다. 조합을 수식으로 풀어서 정리하면 다음과 같다.
>`nCr = n! / r!(n - r)!`
>
>이것이 바로 순열과 조합이며 이를 응용할 수 있는 분야는 무궁무진하다.

----
### 36. 조합의 합
>숫자 집합 candidates를 조합하여 합이 target이 되는 원소를 나열하라. 각 원소는 중복으로 나열 가능하다.

###### 1. DFS로 중복 조합 그래프 탐색
합 target을 만들 수 있는 모든 번호 조합을 찾는 문제인데, 앞서 순열 문제와 유사하게 DFS와 백트래킹으로 풀이할 수 있다. 모든 중복 조합에서 찾아야 하기 때문에, 항상 부모의 값부터 시작하는 그래프로 구성할 수 있다. 만약 조합이 아니라 순열을 찾는 문제라면 자식 노드는 항상 처음부터 시작해야 해서 훨씬 더 많은 계산이 필요할 것이다. 그러나 조합은 각각의 노드가 자기 자신부터 하위 원소까지의 나열로만 정리할 수 있다.
```python
def dfs(csum, index, path):
	...
	for i in range(index, len(candidates)):
		dfs(csum - candidates[i], i, path + [candidates[i]])
```
DFS로 재귀 호출하되, `dfs()` 함수의 첫 번째 파라미터는 합을 갱신해나갈 csum, 두 번째 파라미터는 순서(자신을 포함하는), 세 번째 파라미터는 지금까지의 탐색 경로로 정한다. 그런데 이 탐색 코드는 종료 조건이 없으며, 자기 자신을 포함하기 때문에 무한히 탐색하게 될 것이다. 따라서 종료 조건이 필요하다. 종료 조건은 다음 2가지 경우로 정한다.
- 1) `csum < 0`(마이너스인 경우): 목표 값을 초과한 경우로 탐색을 종료한다.
- 2) `csum == 0`: csum의 초기값은 target이며, 따라서 csum의 0은 target과 일치하는 정답이므로 결과 리스트에 추가하고 탐색을 종료한다.

이런 경우에 다음과 같이 종료하게 되면 가지치기가 되어 더 이상 불필요한 탐색은 하지 않게 될 것이다.
```python
def dfs(csum, index, path):
	if csum < 0:
		return
	if csum == 0:
		result.append(path)
		return
```

나머지 경우는 계속해서 탐색을 시도한다. 종료 조건을 만족하지 못할 경우에는 계속해서 DFS를 시도한다. 그런데 만약 입력값에 0이 포함되어 있다면 어떻게 될까? 종료 조건을 만족할 수 없기 때문에 무한히 깊이 탐색을 시도하게 된다. 리트코드의 테스트 케이스에는 0이 포함되어 있지 않아 이런 경우는 발생하지 않지만 실제로는 입력값 0에 대한 예외 처리도 필요하다. 만약 이 문제를 조합이 아닌 순열 문제로 풀이해본다면 어떻게 될까?
완성된 전체 코드에서 `dfs()`를 호출하는 부분에서 다음과 같이 `i`가 아닌 `0`을 기입하면 된다. 그렇게 하면 항상 첫 번째 값부터 탐색을 시도하기 때문에 순열로 풀이할 수 있을 것이다.
`dfs(csum - candidates[i], 0, path + [candidates[i]]`

---
### 37. 부분 집합
>모든 부분 집합을 리턴하라.

###### 1. 트리의 모든 DFS 결과
이 문제는 트리를 구성하고 트리를 DFS하는 문제로 풀이할 수 있다. 입력값이 `[1,2,3]`일 때 간단한 트리를 구성한다면 이를 DFS하여 원하는 결과를 출력할 수 있다.
```python
def dfs(index, path):
	...
	for i in range(index, len(nums)):
		dfs(i + 1, path + [nums[i]])
```

경로 path를 만들어 나가면서 인덱스를 1씩 증가하는 형태로 깊이 탐색한다. 별도의 종료 조건 없이 탐색이 끝나면 저절로 함수가 종료되게 한다. 그렇다면 결과는 언제 만들게 될까? 생각해보면 부분 집합은 모든 탐색의 경로가 결국 정답이 되므로, 다음과 같이 탐색할 때마다 매번 결과를 추가하면 된다.
```python
def dfs(index, path):
	...
	result.append(path)
```

----
### 38. 일정 재구성
>\[from, to]로 구성된 항공권 목록을 이용해 JFK에서 출발하는 여행 일정을 구성하라.
>여러 일정이 있는 경우 사전 어휘순으로 방문한다.

###### 1. DFS로 일정그래프 구성
여행 일정을 그래프로 구성하면 DFS로 문제를 풀이할 수 있다. 여기서 한 가지 주의할 점은, 중복된 일정인 경우 어휘순으로 방문한다는 점이다. 예를 들어 \["ATL", "JFK"], \["ATL", "SFO"] 인 경우 J가 S보다 빠르므로 JFK를 먼저 방문한다. 먼저 그래프를 구성하는 작업이 필요하다.
```python
graph = collections.defaultdict(list)
for a, b in tickets:
	graph[a].append(b)
for a in graph:
	graph[a].sort()
```

어휘 순으로 방문해야 하기 때문에 일단 그래프를 구성한 후에 다시 꺼내 정렬하는 방식을 택했다. 이 경우 두 번째 예제 입력값 `[["JFK", "SFO"], ["JFK", "ATL"], ["SFO", "ATL"], ["ATL", "JFK"], ["ATL", "SFO"]]`일 때 그래프 형태는 다음과 같다.
```python
defaultdict(list,
		   {'ATL': ['JFK', 'SFO'], 'JFK': ['ATL', 'SFO'], 'SFO': ['ATL']})
```

이처럼 그래프를 순서대로 구성하기 위해 매번 `sort()`를 호출했다. 그러나 이렇게 매번하지 않고 애초에 `tickets`를 한번만 정렬해도 결과는 동일하다. 파이썬의 `sorted()` 함수로 딱 한 번만 정렬하는 형태로 다음과 같이 개선해본다.
```python
graph = collections.defaultdict(list)
for a, b in sorted(tickets):
	graph[a].append(b)
```

처음에 비해 for 문도 한 번으로 줄고 코드도 많이 깔끔해졌다. 이제 그래프에서 하나씩 꺼낼 차례다. `pop()`으로 재귀 호출하면서 모두 꺼내 결과에 추가한다. 결과 리스트에는 역순으로 담기게 될 것이며, `pop()`으로 처리했기 때문에 그래프에서는 해당 경로는 사라지게 되어 재방문하게 되지는 않을 것이다.
```python
def dfs(a):
	while graph[a]:
	dfs(graph[a].pop(0))
	route.append(a)
```

여기서 중요한 점은 어휘 순으로 방문해야 한다는 점이다. 따라서 어휘 순으로 그래프를 생성했기 때문에 `pop(0)`으로 첫 번째 값을 읽어야 한다. 굳이 따지자면 큐의 연산을 수행한다. 마지막에는 다시 뒤집어서 어휘 순으로 맨 처음 읽어들였던 값이 처음이 되게 한다.
```python
def findItinerary(self, tickets: List[List[str]]) -> List[str]:
	graph = collections.defaultdict(list)
	# 그래프 순서대로 구성
	for a, b in sorted(tickets):
		graph[a].append(b)

	route = []
	def dfs(a):
		# 첫 번째 값을 읽어 어휘 순 방문
		while graph[a]:
			dfs(graph[a].pop(0))
		route.append(a)
	
	dfs('JFK')
	#다시 뒤집어 어휘 순 결과로
	return route[::-1]
```

###### 2. 스택 연산으로 큐 연산 최적화 시도
앞서 풀이에서 큐의 연산을 수행한다고 언급한 바 있다. 파이썬 리스트의 경우 파라미터를 지정하지 않은 값, 그러니까 마지막 값을 꺼내는 `pop()`연산은 *O(1)* 이지만, 첫 번째 값을 꺼내는 `pop(0)`연산은 *O(n)* 이다. 따라서 좀 더 효율적인 구현을 위해서는 `pop()`으로, 즉 스택의 연산으로 처리될 수 있도록 개선이 필요하다.
```python
for a, b in sorted(tickets, reverse=True):
	graph[a].append(b)
...
def dfs(a):
	while graph[a]:
		dfs(graph[a].pop())
	...
```

이처럼 애당초 그래프를 역순으로 구성하면 추출 시에는 `pop()`으로 처리가 가능하다. 이렇게 하면 추출 시 시간 복잡도를 *O(1)* 으로 개선할 수 있다. 그러나 실제로 리트코드에서 성능 차이는 거의 없었다. 아마도 전체 딕셔너리가 아닌 각 키별 리스트의 입력값은 그리 크지 않기 때문으로 추정된다. 그러나 리스트가 매우 클 경우 `pop()`, `pop(0)`의 성능 차이는 *O(1)* 과 *O(n)* 으로 클 수 있기 때문에 주의가 필요하다.
```python
def findItinerary(self, tickets: List[List[str]]) -> List[str]:
	graph = collections.defaultdict(list)
	# 그래프를 뒤집어서 구성
	for a, b in sorted(tickets, reverse=True):
		graph[a].append(b)

	route = []
	def dfs(a):
		# 마지막 값을 읽어 어휘 순 방문
		while graph[a]:
			dfs(graph[a].pop())
		route.append(a)
	
	dfs('JFK')
	#다시 뒤집어 어휘 순 결과로
	return route[::-1]
```

###### 3. 일정 그래프 반복
이번에는 재귀가 아닌 동일한 구조를 반복으로 풀이해본다. 대부분의 재귀 문제는 반복으로 치환할 수 있으며, 스택으로 풀이가 가능하다. 먼저, 그래프를 구성하는 부분은 동일하다. 동일한 형태로 그래프를 구성하되, 끄집어낼 때 재귀가 아닌 스택을 이용한 반복으로 처리한다.
출발지는 항상 JFK이므로, 가장 먼저 JFK가 오게 되고, 다음은 ATL이 어휘순으로 먼저 방문한다. ATL에서 어휘순 첫 번째 위치는 JFK이며, 다시 JFK로 돌아갔을 때 지난번에 이미 ATL을 방문했기 때문에 다음 방문지인 SFO를 가게 된다. 한번 방문 했던 곳을 다시 방문하지 않으려면, 별도로 마킹하여 다음번에 방분하지 않거나 아예 스택의 `pop()`으로 값을 제거하는 방법이 있는데, 여기서는 스택을 이용하므로 `pop()`으로 아예 값을 제거한다.
```python
stack = ['JFK']
while stack:
	while graph[stack[-1]]:
		stack.append(graph[stack[-1]].pop(0))
```

그래프에 값이 있다면 `pop(0)`으로 맨 처음의 값을 추출하여 스택 변수 `stack`에 넣게 했다. 큐의 연산이다. 이렇게 하면 그래프의 값들은 점점 제거될 것이며 마지막 방문지가 남지 않을 때까지 while 문이 계속 돌면서 순서대로 처리가 된다. 이 예제는 경로가 끊어지는 경우가 없기 때문에 스택에 모든 경로가 한 번에 담긴다. 그런데 만약 경로가 끊어지는 경우가 있다면 스택에 모든 경로가 한 번에 담길 수 없다. 예를 들어 입력값이 `[["JFK", "KUL"], ["JFK", "NRT"], ["NRT", "JFK"]]`라면 그래프는 다음과 같다.
```python
defaultdict(list, {'JFK': ['KUL', 'NRT'], 'NRT': ['JFK']})
```
이 경우 JFK -> KUL에서 더이상 진행할 수 없게 된다. 따라서 스택의 값을 다시 `pop()`하여 거꾸로 풀어낼 수 있는 또 다른 변수가 필요하다.
```python
route, stack = [], ['JFK']
while stack:
	while graph[stack[-1]]:
		stack.append(graph[stack[-1]].pop(0))
	route.append(stack.pop())
```

DFS 재귀 풀이와 달리 반복으로 풀이하려면 이처럼 한 번 더 풀어낼 수 있는 변수가 필요하다. 여기서는 최종 결과가 되는 변수이므로 DFS 재귀 풀이와 동일한 `route`로 변수명을 정했고, 여기에 스택을 `pop()`하여 담게 했다. 즉 경로가 풀리면서 거꾸로 담기게 될 것이다. 따라서 마찬가지로, 최종 결과는 다시 뒤집어야 한다. 어쨌든 앞서 막혔던 부분인 JFK -> KUL에서 결과 변수 `route`에 `pop()`하여 KUL부터 담게 되고, JFK에서 다시 탐색을 시도해 NRT를 탐색하게 된다. NRT는 JFK로 이동하므로, 최종 결과는 다시 뒤집어서 JFK -> NRT -> JFK -> KUL이 된다.
```python
def findItinerary(self, tickets: List[List[str]]) -> List[str]:
	graph = collections.defaultdict(list)
	# 그래프 순서대로 구성
	for a, b in sorted(tickets):
		graph[a].append(b)

	route, stack = [], ['JFK']
	while stack:
		# 반복으로 스택을 구성하되 막히는 부분에서 풀어내는 처리
		while graph[stack[-1]]:
			stack.append(graph[stack[-1]].pop(0))
		route.append(stack.pop())

	# 다시 뒤집어 어휘 순 결과로
	return route[::-1]
```

| 풀이  | 방식                  | 실행 시간 |
| --- | ------------------- | ----- |
| 1   | DFS로 일정 그래프 구성      | 80ms  |
| 2   | 스택 연산으로 큐 연산 최적화 시도 | 76ms  |
| 3   | 일정 그래프 반복           | 84ms  |

이 문제의 경우 재귀, 스택 연산, 반복 모두 속도차이가 거의 없다. 이 중에서도 재귀와 반복에 집중해서 좀 더 살펴보자면, 재귀는 좀 더 깔끔하게 풀이가 가능하고, 반복은 의식의 흐름대로 자연스럽게 풀이가 가능하다는 차이가 있다. 어느 쪽이든 좋은 풀이 방법이므로, 선호하는 방식으로 풀이하면 된다.

----
### 39. 코스 스케줄
>0을 완료하기 위해서는 1을 끝내야 한다는 것을 \[0,1] 쌍으로 표현하는 n개의 코스가 있다. 코스 개수 n과 이 쌍들을 입력으로 받았을 때 모든 코스가 완료 가능한지 판별하라.

###### 1. DFS로 순환 구조 판별
이 문제는 그래프가 순환 구조인지를 판별하는 문제로 풀이할 수 있다. 순환 구조라면 계속 뱅글뱅글 맴돌게 될 것이고, 해당 코스는 처리할 수 없기 때문이다. 따라서 순환 판별 알고리즘을 차례대로 구현해본다.
```python
graph = collections.defaultdict(list)
for x, y in prerequisites:
	graph[x].append(y)
```

먼저 여기서는 페어들의 목록인 prerequisites 변수를 풀어서 그래프로 표현한다. 페어의 첫 번째 값을 x, 두 번째 값을 y로 하되 y는 복수 개로 구성할 수 있게 한다. 이렇게 하면 'x': \['y1', 'y2'] 같은 구조가 될 것이다.
```python
traced = set()
...
for x in graph:
	if not dfs(x):
		return Fasle

return True
```

순환 구조를 판별하기 위해 앞서 이미 방문했던 노드를 `traced` 변수에 저장한다. 이미 방문했던 곳을 중복 방문하게 된다면 순환 구조로 간주할 수 있고, 이 경우 False를 리턴하고 종료할 수 있다. traced는 중복값을 갖지 않으므로 set() 집합 자료형으로 정한다. 아울러 순환구조를 찾기 위한 탐색은 다음과 같이 DFS로 진행한다.
```python
def dfs(i):
	if i in traced:
		return False
	
	traced.add(i)
	for y in graph[i]:
		fi not dfs(y):
			return False
	traced.remove(i)
	return True
```

여기서 DFS 함수인 `dfs()`에서는 현재 노드가 이미 방문했던 노드 집합인 `traced`에 존재한다면 순환 구조이므로 `False`를 리턴한다. `False`는 계속 상위로 리턴되어 최종 결과도 `False`를 리턴하게 될 것이다. 탐색은 재귀로 진행하되, 해당 노드를 이용한 모든 탐색이 끝나게 된다면 `traced.remove(i)`로 방문했던 내역을 반드시 삭제해야 한다. 그렇지 않으면 형제 노드가 방문한 노드까지 남게 되어, 자식 노드 입장에서는 순환이 아닌데 순환이라고 잘못 판단할 수 있기 때문이다.
입력값이 `[[0, 1], [0, 2], [1, 2]]`일 때 이 그래프는 순환이 존재하지 않으므로 결과는 `True`가 되어야 한다. 그러나 만약 이미 방문한 노드를 삭제하지 않고 그대로 둔다면 1번 경로로 탐색할 때 방문했던 노드들이 그대로 남게 될것이고(즉 \[0,1,2]), 2번 경로로 탐색할때 2 노드가 이미 방문했던 노드라고 잘못 판단할 것이다. 1번 경로와 2번 경로는 형제 노드 간의 탐색이기 때문에 서로 관련성이 없어야 하므로 1번 경로로 탐색이 끝난 이후에는 `traced.remove(i)`로 1, 2 노드가 모두 삭제되어야 한다.

###### 2. 가지치기를 이용한 최적화
앞서 DFS 풀이는 순환이 발견될 때까지 모든 자식 노드를 탐색하는 구조로 되어 있다. 만약 순환이 아니더라도 복잡하게 서로 호출하는 구조로 그래프가 구성되어 있다면, 불필요하게 동일한 그래프를 여러 번 탐색하게 될 수도 있다. 따라서 한 번 방문했던 그래프는 두 번 이상 방문하지 않도록 무조건 `True`로 리턴하는 구조로 개선한다면, 탐색 시간을 획기적으로 줄일 수 있을 것이다. 그리고 원래 DFS는 이런 식으로 가지치기하도록 구현하는 게 올바른 구현 방법이다. 
```python
visited = set()
def dfs(i):
	if i in traced:
		retrun False
	if i in visited:
		return True
	...
	return True
```

이처럼 한 번 방문했던 노드를 저장하기 위한 `visited`라는 별도의 `set()` 집합 변수를 만든다. 이미 방문했던 노드라면 더이상 진행하지 않고 `True`를 리턴한다. 여기서 `visited`는 모든 탐색이 끝난 후에 노드를 추가하는 형태로 구현한다. 만약 탐색 도중 순환 구조가 발견된다면 `False`를 리턴하면서 `visited` 추가는 하지 않음은 물론, 모든 함수를 빠져나가며 종료하게 될 것이다. 이렇게 한 번 방문한 노드는 더 이상 탐색하지 않는 형태, 즉 가지치기로 최적화한다.

| 풀이  | 방식            | 실행 시간 |
| --- | ------------- | ----- |
| 1   | DFS로 순환 구조 판별 | 920ms |
| 2   | 가지치기를 이용한 최적화 | 96ms  |

>[!파이썬] defaultdict 순회 문제
>앞서 39번의 문제 풀이에서 다음과 같이 그래프를 순회하면 된다고 설명한 바 있다.
>`for x in graph:`
>그러나 전체 코드에서는, DFS 호출을 위한 for 문 코드가 조금 다른 형태로 구현되어 있다.
>`for x in list(graph):`
>`graph` 변수 앞을 `list()`로 감쌌는데, 이는 `RuntimeError: dictionary changed size during iteration` 에러가 발생했기 때문이다. 에러 메시지에서는 `graph` 딕셔너리가 순회 중에 변경됐다고 지적한다. for 구문에서 반복하는 `graph` 딕셔너리 변수는 최초 생성 후 변경된 적이 없는데 왜 이런 에러가 발생할까? 그런데 곰곰이 살펴보면 `graph`를 다음과 같은 형태로 생성한 적이 있다.
>`graph = collections.defaultdict(list)`
>`collections` 모듈의 `defaultdict`를 사용해 키가 없는 딕셔너리에 대해서 빈 값 조회시 널 오류가 발생하지 않도록 처리한 바 있는데, 문제는 여기에 있다. 여기서 사용한 `defaultdict`가 존재하지 않는 키를 조회할 때 오류를 내지 않기 위해 항상 디폴트를 생성하는 구조로 되어 있다는 점이다. 따라서 다음과 같은 반복문에서 `graph` 값이 변경된다는 오류가 발생한다.
>```python
>for x in graph:
>	...
>-------------------
>RuntimeError: dictionary changed size during iteration
>```
>
>해당 반복문이 제대로 실행되려면 `graph` 변수를 `defaultdict()`에서 분리해서 고정시킬 필요가 있다. 이 부분은 파이썬 2와 3의 해결 방법이 다른데, 이 책의 기준인 파이썬 3.7+의 해결 방식을 보면 `list()`로 묶어서 해결하라는 답변을 스택오버플로에서 찾을 수 있다. 즉 새로운 복사본을 만들라는 얘기다. 새로운 복사본의 여부는 다음과 같이 간단히 ID 조회로 확인할 수 있다.
>```python
>>>> id(graph)
>4511667296
>>>> id(list(graph))
>4511666816
>```
>
>원래 `graph`의 ID는 4511667296이지만 `list()`로 묶을 경우 새로운 복사본이 생성되면서 다른 ID를 갖게 된다. 따라서 for 문에서도 다음과 같이 반복문을 수정해주면 에러 없이 정상적으로 실행 된다.
>`for x in list(graph)`
>이런 문제는 좀처럼 해결책을 찾기가 쉽지 않다. 무엇보다 문제를 해결하는 데 많은 시간이 소모되기 때문에, 시간 제한이 있는 온라인 코딩 테스트에서 이런 문제를 맞닥뜨리면 매우 당황하게 된다. 이 같은 에러는 알고리즘과도 전혀 관련이 없는, 언어와 컴파일러의 특징에 가까운 에러이기 때문에 여기서 시간을 많이 소모하게 되면 억울할 정도로 손해를 볼 수 있다. 그렇지만 온라인 코딩 테스트는 풀이 결과로만 판단하기 때문에, 온라인 코딩 테스트에 임하기 전에는 풀이하고자 하는 언어와 컴파일러에 대해 충분히 숙지하여 이런 문제를 최소화해야 한다. 적어도 파이썬으로 풀이하기로 마음 먹었다면 파이썬의 버전별 특징과 파이썬의 공식 인터프리터인 CPython의 동작 원리에 대해 충분히 익혀둬야 한다.

----
