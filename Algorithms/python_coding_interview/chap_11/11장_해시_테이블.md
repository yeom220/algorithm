>[!해시 테이블]
>해시 테이블 또는 해시 맵은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형(ADT)을 구현하는 자료구조다.

해시 테이블의 가장 큰 특징은 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 *O(1)* 이라는 점이다. 덕분에 데이터 양에 관계 없이 빠른 성능을 기대할 수 있다는 장점이 있다.

### 해시
>[!해시]
>해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수를 말한다.

해시 테이블의 핵심은 해시 함수다. 여기서 입력값은 ABC, 1324BC, AF32B로 각각 3글자, 6글자, 5글자이지만, 화살표로 표시한 특정 함수를 통과하면 2바이트의 고정 크기 값으로 매핑된다. 여기서 화살표 역할을 하는 함수가 바로 해시 함수이다.
```
ABC -> A1
1324BC -> CB
AF32B -> D5
```
해시 테이블을 인덱싱하기 위해 이처럼 해시 함수를 사용하는 것을 해싱(Hashing)이라 하며, 해싱은 정보를 가능한 한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법 중 하나다. 해싱은 최적의 검색이 필요한 분야에 사용되며, 심볼 테이블(일반적으로 해시 테이블로 구현) 등의 자료구조를 구현하기에도 적합하다. 이외에도 해시 함수는 체크섬(Checksum), 손실 압축, 무작위화 함수(Randomization Function), 암호 등과도 관련이 깊으며 때로는 서로 혼용되기도 한다.
성능 좋은 해시 함수들의 특징은 다음과 같다.
- 해시 함수 값 충돌의 최소화
- 쉽고 빠른 연산
- 해시 테이블 전체에 해시 값이 균일하게 분포
- 사용할 키의 모든 정보를 이용하여 해싱
- 해시 테이블 사용 효율이 높을것

>생일 문제

생각보다 충돌은 쉽게 일어난다. 흔한 예로 생일 문제를 들 수 있다. 생일의 가짓수는 365개(윤년 제외)이므로, 여러 사람이 모였을 때 생일이 같은 2명이 존재할 확률을 얼핏 생각해보면 비둘기집 원리(Pigeonhole Principle)에 따라 366명 이상이 모여야 일어나는 일 같다. 하지만 실제로는 23명만 모여도 50%를 넘고, 57명이 모이면 그때부터는 99%를 넘어선다.
일반적인 상식(잘못된 상식)과는 달리, 충돌은 생각보다 쉽게 일어나므로 충돌을 최소화하는 일은 무엇보다 중요하다.

>[!비둘기집 원리]
>비둘기집 원리란, n개 아이템을 m개 컨테이너에 넣을 때, n>m이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리를 말한다.

왜 충돌은 일어날 수밖에 없을까? 비둘기집 원리는 충돌의 원리를 잘 설명한다. 비둘기집 원리에 따라 9개의 공간이 있는 곳에 10개의 아이템이 들어온다면 반드시 1번 이상은 충돌이 발생하게 된다. 좋은 해시 함수라면 충돌을 최소화하여 단 1번의 충돌만 일어나게 하겠지만, 좋지 않은 해시 함수의 경우 심하면 9번 모두 충돌해서, 10개의 공간 중 1개 밖에 사용하지 못할 수도 있다. 여러 번 충돌한다는 것은 그만큼 추가 연산을 필요로 하기 때문에 가급적 충돌은 최소화하는 것이 좋다.

>[!로드 팩터]
>로드 팩터(Load Factor)란 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것이다.
>`load factor = n/k`

로드 팩터 비율에 따라서 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지를 결정한다. 또한 이 값은 해시함수가 키들을 잘 분산해 주는지를 말하는 효율성 측정에도 사용된다. 자바 10에서는 해시맵의 디폴트 로드 팩터를 0.75로 정했으며 '시간과 공간 비용의 적절한 절충안'이라고 얘기한다. 일반적으로 로드 팩터가 증가할수록 해시 테이블의 성능은 점점 감소하게 되며, 자바 10의 경우 0.75를 넘어설 경우 동적 배열처럼 해시 테이블의 공간을 재할당한다.

>해시 함수

해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것을 해싱(Hashing)이라고 한다. 해싱에는 다양한 알고리즘이 있으며, 최상의 분포를 제공하는 방법은 데이터에 따라 제각각이다. 여기서는 가장 단순하면서도 널리 쓰이는 정수형 해싱 기법인 모듈로 연산을 이용한 나눈셈 방식(Modulo-Division Method) 하나만 살펴본다. 수식은 다음과 같이 정리할 수 있다.
`h(x) = x mod m`
h(x)는 입력값  x의 해시 함수를 통해 생성된 결과다. m은 해시 테이블의 크기로, 일반벅으ㅡ로 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋다. h(x)는 이 값의 모듈로 연산의 결과로, 매우 단순한 방법이지만 실무에서는 이미 많은 키 세트가 충분히 랜덤한 상태고, 키 세트가 어떤 큰 소수에 의해 순환 구조가 될 확률은 낮기 때문에 실제로는 잘 동작한다. x는 어떤 간단한 규칙을 통해 만들어낸 충분히 랜덤한 상태의 키의 값이다. '이펙티브 자바'의 저자 조슈아 블로크는 자바를 설계할 때, 값 x를 다음과 같이 다항식의 결과로 정의했다.
`P(x) = s[0] * x^(n-1) + s[1] * x^(n-2) + ... + s[n-1]`
여기서 x는 31로 하는 거듭제곱 P(31)의 연산으로 정의했다고 밝힌 바 있다.

>충돌

아무리 좋은 해시 함수라도 충돌(Collision)은 발생하게 된다. 충돌이 발생할 경우 어떤 식으로 처리하게 되는지 살펴본다.

>개별 체이닝(Separate Chaining)

해시는 키를 해싱한 결과며, '윤아'와 '서현'을 해싱한 결과는 충돌한다고 가정한다.

| 키   | 값   | 해시  | 충돌 여부 |
| --- | --- | --- | ----- |
| 윤아  | 15  | 2   | 충돌    |
| 유리  | 47  | 1   |       |
| 서현  | 17  | 2   | 충돌    |
| 수영  | 7   | 4   |       |
해시 테이블의 기본 방식이기도 한 개별 체이닝은 충돌 발생 시, 연결 리스트로 연결하는 방식이다. 충돌이 발생한 '윤아'와 '서현'은 '윤아'의 다음 아이템이 '서현'인 형태로 서로 연결 리스트로 연결되었다. 이처럼 기본적인 자료구조와 임의로 정한 간단한 알고리즘만 있으면 되므로, 개별 체이닝 방식은 인기가 높다. 원래 해시 테이블 구조의 원형이기도 하며 가장 전통적인 방식으로, 흔히 해시 테이블이라고 하면 바로 이 방식을 말한다.
**간단한 원리 요약**
1. 키의 해시 값을 계산한다.
2. 해시 값을 이용해 배열의 인덱스를 구한다.
3. 같은 인덱스가 있다면 연결 리스트로 연결한다.
잘 구현한 경우 대부분의 탐색은 *O(1)* 이지만 최악의 경우, 즉 모든 해시 충돌이 발생했다고 가정할 경우에는 *O(n)* 이 된다. 자바 8에서는 연결 리스트 구조를 좀 더 최적화해서, 데이터의 개수가 많아지면 레드-블랙 트리에 저장하는 형태로 병행해 사용하기도 했다.

>오픈 어드레싱(Open Addressing)

오픈 어드레싱 방식은 충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식이다. 사실상 무한정 저장할 수 있는 체이닝 방식과 달리, 오픈 어드레싱 방식은 전체 슬롯의 개수 이상은 저장할 수 없다. 충돌이 일어나면 테이블 공간 내에서 탐사(Probing)를 통해 빈 공간을 찾아 해결하며, 이 때문에 개별 체이닝 방식과 달리, 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.
여러 가지 오픈 어드레싱 방식 중에서 가장 간단한 방식인 선형 탐사(Linear Probing)방식은 충돌이 발생할 경우 해당 위치부터 순차적으로 탐사를 하나씩 진행한다. 특정 위치가 선점되어 있으면 바로 그 다음 위치를 확인하는 식이다. 이렇게 탐사를 진행하다가 비어 있는 공간을 발견하면 삽입하게 된다. 선형 탐사 방식은 구현 방법이 간단하면서도, 의외로 전체적인 성능이 좋은 편이기도 하다.
선형 탐사의 한 가지 문제점은 해시 테이블에 저장되는 데이터들이 고르게 분포되지 않고 뭉치는 경향이 있다는 점이다. 해시 테이블 여기저기에 연속된 데이터 그룹이 생기는 이러한 현상을 클러스터링(Clustering)이라 하는데, 클러스터들이 점점 커지게 되면 인근 클러스터들과 서로 합쳐지는 일이 발생한다. 그렇게 되면 해시 테이블의 특정 위치에는 데이터가 몰리게 되고, 다른 위치에는 상대적으로 데이터가 거의 없는 상태가 될 수 있다. 이러한 클러스터링 현상은 탐사 시간을 오래 걸리게 하며, 전체적으로 해싱 효율을 떨어 뜨리는 원인이 된다.

오픈 어드레싱 방식은 버킷 사이즈보다 큰 경우 삽입할 수 없다. 따라서 기준이 되는 로드 팩터 비율을 넘어서게 되면, 그로스 팩터(Growth Factor)의 비율에 따라 더 큰 크기의 또 다른 버킷을 생성한 후 여기에 새롭게 복사하는 리해싱(Rehashing) 작업이 일어난다. 이는 동적 배열에서 공간이 가득 찰 경우, 더블링으로 새롭게 복사해서 옮겨가는 과정과 유사하다.

>언어별 해시 테이블 구현 방식

리스트와 함께 파이썬에서 가장 흔하게 쓰이는 자료형인 딕셔너리는 해시 테이블로 구현되어 있다. 파이썬의 해시 테이블은 충돌 시 오픈 어드레싱 방식으로 구현되어 있다. CPython 구현에는 다음과 같은 주석이 적혀 있다.
**`체이닝 시 malloc 으로 메모리를 할당하는 오버헤드가 높아 오픈 어드레싱을 택했다.`**
파이썬의 코어 개발에 관여했던 앤드큐 커클링은 파이썬이 체이닝을 사용하지 않는 이유를 설명한 바 있는데, 연결 리스트를 만들기 위해서는 추가 메모리 할당이 필요하고, 추가 메모리 할당은 상대적으로 느린 작업이기 때문에 택하지 않았다고 기술했다.
오픈 어드레싱의 한 방식인 선형 탐사 방식은 일반적으로 체이닝에 비해 성능이 더 좋다. 그러나 슬롯의 80% 이상이 차게 되면 급격한 성능 저하가 일어나며, 체이닝과 달리 전체 슬롯의 전체 개수 이상, 즉 로드 팩터 1 이상은 저장할 수 없다. 빈 공간을 탐사하는 선형 탐사 방식은 공간이 찰수록 탐사에 점점 더 오랜 시간이 걸리며, 가득 차게 될 경우 더 이상 빈 공간을 찾을 수 없기 때문이다. 따라서 최근의 루비나 파이썬 같은 모던(Modern) 언어들은 오픈 어드레싱 방식을 택해 성능을 높이는 대신, 로드 팩터를 작게 잡아 성능 저하 문제를 해결한다. 파이썬의 로드 팩터는 0.66으로 자바보다 작으며 루비는 0.5로 훨씬 더 작다.
*각 언어별 해시 테이블 구현*

| 언어                 | 방식      |
| ------------------ | ------- |
| C++(GCC libstdc++) | 개별 체이닝  |
| 자바                 | 개별 체이닝  |
| 고(Go)              | 개별 체이닝  |
| 루비                 | 오픈 어드레싱 |
| 파이썬                | 오픈 어드레싱 |

----
### 28. 해시맵 디자인 (리트코드 706)
>다음의 기능을 제공하는 해시맵을 디자인하라.
>- put(key, value): 키, 값을 해시맵에 삽입. 만약 이미 존재하는 키라면 업데이트.
>- get(key): 키에 해당하는 값을 조회. 만약 키가 존재하지 않는다면 -1 리턴.
>- remove(key): 키에 해당하는 키, 값을 해시맵에서 삭제.

- 1) 개별 체이닝 방식을 이용한 해시 테이블 구현
	- 초기화 메서드 구현
		- 기본 사이즈는 1,000개 정도로 적당히 설정하고, 각 ListNode를 담게 될 기본 자료형을 선언한다. 편리하게 구현하기 위해 존재하지 않는 키를 조회할 경우 자동으로 디폴트를 생성해주는 collections.defaultdict를 사용했다.
	- put() 구현
		- 편의상 모든 키를 정수형으로 지정했다. 따라서 size의 개수만큼 모듈로 연산을 한 나머지를 해시값으로 정하는 매우 단순한 형태로 처리한다. 이처럼 모듈로 연산을 통한 해싱은 해시 테이블의 가장 기본적인 해싱 방식이기도 하다. 이제 해싱한 결과인 index는 해시 테이블의 인덱스가 될 것이다.
		- 해당 인덱스에 아무것도 없다면 키, 값을 삽입하고 바로 종료한다. 여기서, `self.table[index] is None`으로 비교하지 않고 `self.table[index].value is None`으로 `value`의 존재 유무를 비교한 이유는 `self.table`이 `defaultdict` 이기 때문이다. `defaultdict`는 존재하지 않는 인덱스로 조회를 시도할 경우 에러를 발생하지 않고 바로 디폴트 객체를 생성한다. 여기서는 `defaultdict(ListNode)`로 선언했기 때문에 바로 빈 `ListNode`를 생성할 것이다.
		  `ListNode()` 클래스의 생성 함수 `__init__()`을 살펴보면, `key=None, value=None`을 초깃값으로 정했기 때문에, 각각이 `None`인 `ListNode`가 조회 즉시 생성될 것이다.
		- 해당 인덱스에 노드가 존재하는 경우, 즉, 해시 충돌(Hash Collision)이 발생한 경우인데, 개별 체이닝 방식으로 충돌을 해결한다. 즉 연결리스트로 이어나갈 것이다. p는 인덱스의 첫 번째 값이며 여기서부터 p.next를 계속 탐색한다. 종료 조건은 2가지 경우인데, 첫 번째는 이미 키가 존재할 경우 값을 업데이트하고 빠져나가는 경우고, 두 번째는 `p.next is None`이라면 아무것도 하지 않고 루프를 빠져나가는 경우다. 만약 후자를 처리하지 않는다면 `p = p.next`로 인해 `p`는 `None`이 되기 때문에 `p.next = ListNode(key, value)`에서 에러가 발생할 것이다.
		  에러 없이 정상적으로 진행되면 이 코드에서 `p.next`에 새 노드가 생성되면서 연결된다. 기존에 존재하지 않았던 키라면 맨 마지막에 새로운 노드가 연결될 것이다. 여기까지가 개별 체이닝 방식의 해시 테이블 삽입 원리다.
	- get() 구현
		- 모듈로 연산으로 인덱스를 결정하고, 해당 인덱스에 아무것도 없다면 `-1`을 리턴한다. 이 경우는 해당하는 노드는 물론, 아직 어떠한 키도 이 값으로 해싱되지 않은 경우다.
		- 해싱 결과에 하나 이상의 노드가 존재한다면, `p.next`로 탐색하면서 일치하는 키를 찾는다. 찾게 되면 값을 리턴하고, 찾지 못한다면 루프를 빠져나오면서 마찬가지로 `-1`을 리턴한다.
	- remove() 구현
		- 인덱스를 구한 다음 아무것도 없다면, 잘못된 키를 삭제 시도한 경우이므로 그냥 리턴한다. 값이 있을 때는 2가지 케이스로 나눠서 처리한다.
		- **1) 인덱스의 첫 번째 노드일 때 삭제 처리**
			- 인덱스의 첫 번째 노드일 때, `p.next is None`이라면 유일한 노드를 삭제하는 경우이므로 원래는 모두 없애야 한다. 그러나 여기서는 `ListNode()`로 빈 노드를 할당하게 했다. `self.table`은 `defaultdict(ListNode)`이기 때문에 매번 빈 노드를 생성하기 때문이다. 만약 여기서 `self.table[index] = None`을 할당한다면 앞서 추가, 조회 함수에서 `self.table[index].value is None`으로 비교를 시도할 때 에러가 발생할 것이다.
		- **2) 연결 리스트인 노드일 때 삭제 처리**
			- `prev`는 이전 노드, `p`는 현재 노드로, 계속 `p.next`로 탐색하다가 일치하는 노드를 찾게 되면, 이전 노드의 다음을 현재 노드의 다음으로 연결한다. 즉 현재 노드를 아무런 연결 고리가 없도록 끊어 버린다. 가만히 살펴보면 약간의 버그 가능성이 엿보인다. 만약 루프에 들어서자마자 일치하는 키를 발견하게 되면 `prev.next = p.next`가 동일한 부분이 될 것이다. 그러나 이런 경우는 발생하지 않는다. 왜냐하면 처음부터 일치하는 경우는 이미 1)에서 처리가 되기 때문이다. 따라서 여기서는 반드시 한 번 이상 반복한 후에야 일치하는 경우가 생길 것이다.
---
### 29. 보석과 돌
>J는 보석이며, S는 갖고 있는 돌이다. S에는 보석이 몇 개나 있을까? 대소문자는 구분한다.

###### 1. 해시 테이블을 이용한 풀이
이 문제는 갖고 있는 돌 S의 각각의 개수를 모두 헤아린 다음, J의 각 요소를 키로 하는 각 개수를 합산하면 풀이할 수 있다.
- 해시 테이블 생성
	- `freqs`라는 해시 테이블을 선언하나. 그리고 들의 모음인 S를 문자 단위로 하나씩 분리해 반복한다. 만약 처음 등장한 문자라면 1을 선언하고, 기존에 있던 문자라면 1을 더한다. 각 문자별 빈도 수가 저장된다. 이제 이 중에서 보석을 나타내는 J의 문자를 꺼내어 해당 문자의 빈도 수를 합하면 최종 결과가 된다.
###### 2. defaultdict를 이용한 비교 생략
default dict를 사용하면 코드 줄 수를 훨씬 더 줄일 수 있다. 키가 존재하는지 여부를 매번 판별할 필요가 없기 때문에 이처럼 바로 계산할 수 있고, 코드 수도 많이 줄어들어 깔끔해졌다.

###### 3. Counter로 계산 생략
Counter를 사용하면 코드를 더욱 짧게 줄일 수 있다. 각 개수를 계산하는 부분까지 자동으로 처리할 수 있기 때문이다. 아울러 Counter는 존재하지 않는 키의 경우 `KeyError`를 발생하는 게 아니라 `0`을 출력해 주기 때문에, `defaultdict`와 마찬가지로 에러에 대한 예외 처리를 할 필요가 없다. 단순히 J에 포함된 문자의 개수를 계산하기만 하면 된다.

###### 4. 파이썬다운 방식(리스트 컴프리헨션)
이 문제는 파이썬다운 방식(Pythonic Way)으로 단 한 줄로 계산할 수 있다.
```python
return sum(s in J for s in S)
```
리스트 컴프리헨션 작동 방식
```python
>>> [s for s in S]   #S = ['a', 'A', 'A', 'b', 'b']
`['a', 'A', 'A', 'b', 'b']`
```
이렇게 하면 각 문자를 하나씩 출력하는 리스트 컴프리헨션 이다.
```python
>>> [s in J for s in S]   #S = ['a', 'A', 'A', 'b', 'b'], J = ['a', 'A']
`[True, True, True, False, False]`
```
여기에 약간의 비교 구문을 추가해 `S`의 문자 `s`가 `J`에 포함되어 있는지 여부를 출력할 수 있다. `['a', 'A', 'A', 'b', 'b']`에서 첫 번째와 두 번째, 세 번째에 각각 `J`의 `a`와 `A`가 포함되어 있으므로 `True`, 나머지는 모두 `False`다. 이제 이 값을 다읍과 같이 `sum()`으로 합산한다.
```python
>>> sum([s in J for s in S])
3
```
결과는 `True`의 개수로, 3이 된다. 여기서 리스트 컴프리헨션을 의미하는 앞뒤의 대괄호 `[]`는 다음과 같이 제거할 수 있다.
```python
>>> sum(s in J for s in S)
3
```
위 4가지 풀이 방식은 실행속도가 동일하다.

| 풀이  | 방식                     | 실행 시간 | 코드 줄 수 |
| --- | ---------------------- | ----- | ------ |
| 1   | 해시 테이블을 이용한 풀이         | 32ms  | 14줄    |
| 2   | defaultdict를 이용한 비교 생략 | 28ms  | 10줄    |
| 3   | Counter로 계산 생략         | 32ms  | 7줄     |
| 4   | 파이썬다운 방식               | 28ms  | 1줄     |

----
### 30. 중복 문자 없는 가장 긴 부분 문자열
>중복 문자가 없는 가장 긴 부분 문자열의 길이를 리턴하라.

###### 1. 슬라이딩 윈도우와 투 포인터로 사이즈 조절
입력값이 `s = "abcabcbb"`인 경우를 살펴본다. 슬라이딩 윈도우로 한 칸씩 우측으로 이동하면서 윈도우 내에 모든 문자가 중복이 없도록 투 포인터로 윈도우 사이즈를 조절하면서 풀이해본다.
먼저, 투 포인터로 문제를 풀이하되, 포인터 2개 모두 왼쪽에서 출발한다. 각각 왼쪽 시작점에서 출발해 두 번째 포인터(`index`)는 다음과 같이 계속 오른쪽으로 확장한다.
```python
for index, char in enumerate(s):
	if char in used:
		start = used[char] + 1
	else:
		...
```
만약 이미 등장한 문자라면 used에 있을 것이고 이 경우 첫 번째 포인터인 `start`를 `userd[char] + 1` 위치로 갱신한다. 등장하지 않았던, 처음 보는 문자라면 다음과 같이 처리한다.
```python
for index, char in enumerate(s):
	if char in used:
		...
	else:
		max_length = max(max_length, index - start + 1)
```
처음 보는 문자인 경우, 매번 `max()`로 부분 문자열의 길이를 확인하면서 더 큰 값인 경우 갱신한다. 또한 다음과 같이 현재 문자의 위치는 계속 갱신해준다.
```python
for index, char in enumerate(s):
	if char in used:
		...
	else:
		...
	used[char] = index
```
`used[char]`는 현재 문자를 키로 하는 해시 테이블이며, 여기에는 현재 위치를 값으로 삽입한다. 즉 앞서 살펴본 `start = used[char] + 1`는 '현재 위치 +1'이 되고 이미 등장했던 문자인 경우 왼쪽 포인터인 `start`를 현재 위치까지 옮기게 된다. 그런데 이미 등장했다고 무작정 옮겨 버리면 곤란하다. 현재 슬라이딩 윈도우의 바깥에 있는 문자는 예전에 등장한 적이 있더라도 지금은 무시해야 하기 때문이다. 따라서 비교 구문에 다음과 같이 `and` 이후에 조건 `start <= used[char]`를 추가한다.
```python
for index, char in enumerate(s):
	if char in used and start <= used[char]:
		...
	else:
		...
```
이렇게 하면 슬라이딩 윈도우 안쪽에 있는 중복 문자에 대해서만 True 처리가 될 것이다.

---
### 31. 상위 K 빈도 요소
>k번 이상 등장하는 요소를 추출하라.

###### 1. Counter를 이용한 음수 순 추출
요소의 값을 키로 하는 해시 테이블을 만들고 여기에 빈도 수를 저장한 다음, 우선순위 큐를 이용해 k번만큼 추출하면 k번 이상 등장하는 요소를 손쉽게 추출할 수 있다. 파이썬에서 우선순위 큐는 힙을 활용하는 `heapq` 모듈을 사용한다. 먼저 빈도 수는 `collections.Counter`를 이용하여 다음과 같이 쉽게 구해본다.
`freqs = collections.Counter(nums)`
입력값이 `[1,1,1,2,2,3]`일 때 `freqs`의 결과를 출력해보면 다음과 같다.
```python
>>> type(s.freqs)
collections.Counter
>>> s.freqs
Counter({
	 1: 3,
	 2: 2,
	 3: 1
})
```
이제 힙에 삽입해본다. 삽입 방식은 2가지가 있는데, 첫 번째는 일반적인 파이썬의 리스트에 모두 삽입한 다음 마지막에 `heapify()`를 하는 방식과, 두 번째는 매번 `heappush()`를 하는 방식이다. `heappush()`로 삽입하게 되면 매번 `heapify()`가 일어나기 때문에 별도로 처리할 필요가 없다. 이 방식이 원래 힙의 삽입 방식이기도 하다.
```python
for f in freqs:
	heapq.heappush(freqs_heap, (-freqs[f], f))
```
여기서는 빈도 수를 키로 하고, freqs의 키를 값으로 했다. 즉 키/값을 바꿔서 힙에 추가했다. 힙은 키 순서대로 정렬되기 때문에 이를 위해 빈도 수를 키로 하였다. 또한, 값을 음수로 저장했다. 파이썬 `heapq` 최소 힙(Min-Heap)만 지원하기 때문이다. 모듈 차원에서는 최대 힙(Max-Heap)도 지원하긴 하지만 메소드가 프로텍티드 멤버(Protected Member)로 선언되어 있고 함수명이 밑줄(\_)로 시작하기 때문에(PEP 8에서 내부 용도로 규정) 직접 호출하는게 권장하는 방법은 아니다. 따라서 여기서는 최소 힙을 그대로 사용하되 음수로 변환해 가장 빈도 수가 높은 값이 가장 큰 음수가 되게 한다. 이렇게 하면 최소 힙으로도 빈도 수가 가장 높았던 값을 추출할 수 있다. 마지막으로 다음과 같이 `heappop()`으로 k번만큼 값을 추출하면 결과를 얻을 수 있다.
```python
topk = list()
for _ in range(k):
	topk.append(heapq.heappop(freqs_heap)[1])
```

###### 2. 파이썬다운 방식
`Counter`에는 `most_common()`이라는 빈도 수가 높은 순서대로 아이템을 추출하는 기능을 제공한다.
```python
>>> collections.Counter(nums).most_common(k)
[(1, 3), (2, 2)]
```
여기서 정답인 1과 2를 추출하기만 하면 된다. 파이썬의 2가지 기능인 `zip()`과 `*`를 활용해본다.
```python
>>> list(zip(*collections.Counter(nums).most_common(k)))[0]
(1, 2)
```

| 풀이  | 방식                   | 실행 시간 |
| --- | -------------------- | ----- |
| 1   | Counter를 이용한 음수 순 추출 | 108ms |
| 2   | 파이썬다운 방식             | 104ms |

>[!zip() 함수]
>`zip()` 함수는 2개 이상의 시퀀스를 짧은 길이를 기준으로 일대일 대응하는 새로운 튜플 시퀀스를 만드는 역할을 한다. 먼저 다음과 같이 `a, b, c` 리스트를 각각 정의하고 `zip(a, b)`를 실행한 결과를 살펴본다.
>```python
> >>> a = [1,2,3,4,5]
> >>> b = [2,3,4,5]
> >>> c = [3,4,5]
> >>> zip(a, b)
> <zip object at 0x105b6d9b0>
> ```
> 파이썬 2에서는 `zip()`의 결과가 바로 리스트가 된다. 하지만 파이썬 3+에서는 제너레이터를 리턴한다. 제너레이터에서 실제값을 추출하기 위해서는 다음과 같이 `list()`로 한 번 더 묶어주면 된다.
> ```python
> >>> list(zip(a, b))
> [(1, 2), (2, 3), (3, 4), (4, 5)]
> >>> list(zip(a, b, c)
> [(1, 2, 3), (2, 3, 4), (3, 4, 5)]
> ```
> 아울러 `zip()`의 결과 자체는 리스트 시퀀스가 아닌 튜플 시퀀스를 만들기 때문에, 값을 변경하는 게 불가능하다. 불변(Immutable) 객체다.
> 이처럼 `zip()`은 여러 시퀀스에서 동일한 인덱스의 아이템을 순서대로 추출하여 튜플로 만들어 주는 역할을 한다. 앞서 문제 풀이에서 `[(1, 3), (2, 2)]`는 `zip()`으로 묶게 되면 `[(1, 2), (3, 2)]`가 될 것이다. 튜플의 값과 개수가 모두 2개라서 다소 헷갈릴 수 있는데, 개수를 늘려서 다음 코드를 살펴보면 좀 더 이해하기 쉬울 것 같다.
> ```python
> >>> a = ['a1', 'a2']
> >>> b = ['b1', 'b2']
> >>> c = ['c1', 'c2']
> >>> d = ['d1', 'd2']
> >>> list(zip(a, b, c, d))
> [('a1', 'b1', 'c1', 'd1'), ('a2', 'b2', 'c2', 'd2')]
> ```
> 이처럼 a, b, c, d 각각의 리스트가 `zip()`으로 묶여서 2개의 튜플이 되었다.

>[!아스테리스크(*)]
> `zip()`의 파라미터는 1개가 될 수도 있고, 2개가 될 수도, 10개가 될 수도 있다. 앞서 참고 마지막의 입력값을 기준으로 실험해보면 다음과 같다.
> ```python
> >>> list(zip(a))
> [('a1', ), ('a2', )]
> >>> list(zip(a, b))
> [('a1', 'b1'), ('a2', 'b2')]
> >>> list(zip(a, b, c))
> [('a1', 'b1', 'c1'), ('a2', 'b2', 'c2')]
> ```
> 어떻게 하면 이렇ㅅ게 할 수 있을까? 여기에는 `*`를 활용한다. C를 개발해본 분들이라면 포인터 변수와 혼동될 수 있다. 그러나 파이썬에는 포인터가 존재하지 않는다. 게다가 생긴 건 비슷하지만 전혀 다른 동작을 수행한다. 파이썬에서 `*`는 언팩(Unpack)이다. 시퀀스 언패킹 연산자(Sequence Unpacking Operator)로 말 그대로 시퀀스를 풀어헤치는 연산자를 뜻하며, 주로 튜플이나 리스트를 언패킹하는 데 사용한다. 앞서 31번 문제 풀이 \#2에서와 같이 언패킹을 했을 때와 하지 않았을 때를 비교해보면 그 용도를 분명히 알 수 있다.
> ```python
> >>> collections.Counter(nums).most_common(k)
> [(1, 3), (2, 2)]
> # 언패킹을 했을 때
> >>> list(zip(*collections.Counter(nums).most_common(k)))
> [(1, 2), (3, 2)]
> # 언패킹을 하지 않았을 때
>  >>> list(zip(collections.Counter(nums).most_common(k)))
>  [((1, 3), ), ((2, 2), )]
>  ```
>  입력값이 `[1,1,1,2,2,3]`일 때 `collections.Counter(nums).most_common(k)`의 결과가 `[(1, 3), (2, 2)]`임은 이미 살펴본바 있다. 그러나 이 값을 그대로 `zip()`으로 묶어 보면 엉뚱한 결과가 나온다. 튜플이 풀어지지 않고 그대로 하나의 값처럼 묶여 버렸다. 이 경우 `*`로 언패킹을 해줘야 튜플의 값을 풀어 헤칠 수 있다. 언패킹한 값만 별도로 출력할 수 가 없기 때문에 디버깅이 어렵지만, 아마 내부적으로는 튜플이 제거되고 `[(1, 3), (2, 2)]`와 같은 형태로 모두 리스트로 풀어질 것이다. 이제 이 값을 `zip()`으로 묶으면 정상적으로 묶이게 된다. 즉 정답인 1과 2가 하나의 튜플로 묶이게 된다. 간단한 예제를 하나 더 살펴본다.
>  ```python
>  >>> fruits = ['lemon', 'pear', 'wartermelon', 'tomato']
>  >>> fruits
>  ['lemon', 'pear', 'wartermelon', 'tomato']
>  ```
>  `fruits`라는 리스트를 출력하면 당연히 리스트 형태로 출력된다. 만약 리스트에서 각 요소의 값만 출력하고 싶다면 어떻게 하면 될까?
>  ```python
>  >>> print(fruits[0], fruits[1], fruits[2], fruits[3])
>  lemon pear watermelon tomato
>  ```
>  이렇게 출력할 수 있다. 또는 `for` 반복문으로 순회하여 값을 출력할 수도 있을 것이다.
>  이때 `*`로 언패킹 해주면 다음과 같이 매우 간편하게 출력할 수 있다.
>  ```python
>  >>> print(*fruits)
>  lemon pear watermelon tomato
>  ```
>  이외에도 `*`는 활용도가 많다. 언패킹뿐만 아니라 함수의 파라미터가 되었을 때는 반대로 패킹(Packing)도 가능하다. `zip()`에 파라미터를 여러 개 쓸 수 있다는 얘기 또한 내부적으로 `zip()` 함수 정의에서 `*`로 패킹하고 있다는 얘기이기도 하다.
>  ```python
>  >>> def f(*params)
> 		 print(params)
> 
> >>> f('a', 'b', 'c')
> ('a', 'b', 'c')
>  ```
>  이처럼 하나의 파라미터를 받는 함수에 3개의 파라미터를 전달했지만, params 변수 하나로 패킹되어 처리된다. 몇 개의 파라미터를 넘기든, 모두 처리가 된다. 이번에는 다음과 같이 또 다른 활용 예를 살펴본다.
>  ```python
>  >>> a, *b = [1,2,3,4]
>  >>> a
>  1
>  >>> b
>  [2, 3, 4]
>  >>> *a, b = [1, 2, 3, 4]
>  >>> a
>  [1, 2, 3]
>  >>> b
>  [4]
>  ```
>  변수의 할당 또한 이렇게 `*`로 묶어서 처리할 수 있다. 일반적인 변수는 값을 하나만 취하지만 `*`로 처리하게 되면 나머지 모든 값을 취하게 된다. 이외에도 활용 방법은 상당히 많다. `*`는 파이썬에서 매우 중요하며 자주 쓰이는 기능 중 하나이므로, 반드시 숙지하기 바란다. 마지막으로 하나가 아닌 2개를 쓰는 경우도 있다. `**`인데 마찬가지로 C의 더블 포인터와 동일하게 생겼지만, 전혀 다른 동작을 수행한다. 파이썬에서 `*` 1개는 튜플 또는 리스트 등의 시퀀스 언패킹이고, `**` 2개는 아듬과 같이 키/값 페어를 언패킹하는 데 사용된다.
>  ```python
>  >>> date_info = {'year': '2020', 'month': '01', 'day': '7'}
>  >>> new_info = {**date_info, 'day': "14"}
>  >>> new_info
>  {'year': '2020', 'month': '01', 'day': '14'}
>  ```
>  이처럼 `**date_info`에 모든 요소를 언패킹할 수 있으며 여기서는 `'day': "14"`의 새로운 값으로 업데이트도 시도했다. 그 결과 day의 값은 변경된 것을 확인할 수 있다.
