>[!해시 테이블]
>해시 테이블 또는 해시 맵은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형(ADT)을 구현하는 자료구조다.

해시 테이블의 가장 큰 특징은 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 *O(1)* 이라는 점이다. 덕분에 데이터 양에 관계 없이 빠른 성능을 기대할 수 있다는 장점이 있다.

### 해시
>[!해시]
>해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수를 말한다.

해시 테이블의 핵심은 해시 함수다. 여기서 입력값은 ABC, 1324BC, AF32B로 각각 3글자, 6글자, 5글자이지만, 화살표로 표시한 특정 함수를 통과하면 2바이트의 고정 크기 값으로 매핑된다. 여기서 화살표 역할을 하는 함수가 바로 해시 함수이다.
```
ABC -> A1
1324BC -> CB
AF32B -> D5
```
해시 테이블을 인덱싱하기 위해 이처럼 해시 함수를 사용하는 것을 해싱(Hashing)이라 하며, 해싱은 정보를 가능한 한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법 중 하나다. 해싱은 최적의 검색이 필요한 분야에 사용되며, 심볼 테이블(일반적으로 해시 테이블로 구현) 등의 자료구조를 구현하기에도 적합하다. 이외에도 해시 함수는 체크섬(Checksum), 손실 압축, 무작위화 함수(Randomization Function), 암호 등과도 관련이 깊으며 때로는 서로 혼용되기도 한다.
성능 좋은 해시 함수들의 특징은 다음과 같다.
- 해시 함수 값 충돌의 최소화
- 쉽고 빠른 연산
- 해시 테이블 전체에 해시 값이 균일하게 분포
- 사용할 키의 모든 정보를 이용하여 해싱
- 해시 테이블 사용 효율이 높을것

>생일 문제

생각보다 충돌은 쉽게 일어난다. 흔한 예로 생일 문제를 들 수 있다. 생일의 가짓수는 365개(윤년 제외)이므로, 여러 사람이 모였을 때 생일이 같은 2명이 존재할 확률을 얼핏 생각해보면 비둘기집 원리(Pigeonhole Principle)에 따라 366명 이상이 모여야 일어나는 일 같다. 하지만 실제로는 23명만 모여도 50%를 넘고, 57명이 모이면 그때부터는 99%를 넘어선다.
일반적인 상식(잘못된 상식)과는 달리, 충돌은 생각보다 쉽게 일어나므로 충돌을 최소화하는 일은 무엇보다 중요하다.

>[!비둘기집 원리]
>비둘기집 원리란, n개 아이템을 m개 컨테이너에 넣을 때, n>m이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리를 말한다.

왜 충돌은 일어날 수밖에 없을까? 비둘기집 원리는 충돌의 원리를 잘 설명한다. 비둘기집 원리에 따라 9개의 공간이 있는 곳에 10개의 아이템이 들어온다면 반드시 1번 이상은 충돌이 발생하게 된다. 좋은 해시 함수라면 충돌을 최소화하여 단 1번의 충돌만 일어나게 하겠지만, 좋지 않은 해시 함수의 경우 심하면 9번 모두 충돌해서, 10개의 공간 중 1개 밖에 사용하지 못할 수도 있다. 여러 번 충돌한다는 것은 그만큼 추가 연산을 필요로 하기 때문에 가급적 충돌은 최소화하는 것이 좋다.

>[!로드 팩터]
>로드 팩터(Load Factor)란 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것이다.
>`load factor = n/k`

로드 팩터 비율에 따라서 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지를 결정한다. 또한 이 값은 해시함수가 키들을 잘 분산해 주는지를 말하는 효율성 측정에도 사용된다. 자바 10에서는 해시맵의 디폴트 로드 팩터를 0.75로 정했으며 '시간과 공간 비용의 적절한 절충안'이라고 얘기한다. 일반적으로 로드 팩터가 증가할수록 해시 테이블의 성능은 점점 감소하게 되며, 자바 10의 경우 0.75를 넘어설 경우 동적 배열처럼 해시 테이블의 공간을 재할당한다.

>해시 함수

해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것을 해싱(Hashing)이라고 한다. 해싱에는 다양한 알고리즘이 있으며, 최상의 분포를 제공하는 방법은 데이터에 따라 제각각이다. 여기서는 가장 단순하면서도 널리 쓰이는 정수형 해싱 기법인 모듈로 연산을 이용한 나눈셈 방식(Modulo-Division Method) 하나만 살펴본다. 수식은 다음과 같이 정리할 수 있다.
`h(x) = x mod m`
h(x)는 입력값  x의 해시 함수를 통해 생성된 결과다. m은 해시 테이블의 크기로, 일반벅으ㅡ로 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋다. h(x)는 이 값의 모듈로 연산의 결과로, 매우 단순한 방법이지만 실무에서는 이미 많은 키 세트가 충분히 랜덤한 상태고, 키 세트가 어떤 큰 소수에 의해 순환 구조가 될 확률은 낮기 때문에 실제로는 잘 동작한다. x는 어떤 간단한 규칙을 통해 만들어낸 충분히 랜덤한 상태의 키의 값이다. '이펙티브 자바'의 저자 조슈아 블로크는 자바를 설계할 때, 값 x를 다음과 같이 다항식의 결과로 정의했다.
`P(x) = s[0] * x^(n-1) + s[1] * x^(n-2) + ... + s[n-1]`
여기서 x는 31로 하는 거듭제곱 P(31)의 연산으로 정의했다고 밝힌 바 있다.

>충돌

아무리 좋은 해시 함수라도 충돌(Collision)은 발생하게 된다. 충돌이 발생할 경우 어떤 식으로 처리하게 되는지 살펴본다.

>개별 체이닝(Separate Chaining)

해시는 키를 해싱한 결과며, '윤아'와 '서현'을 해싱한 결과는 충돌한다고 가정한다.

| 키   | 값   | 해시  | 충돌 여부 |
| --- | --- | --- | ----- |
| 윤아  | 15  | 2   | 충돌    |
| 유리  | 47  | 1   |       |
| 서현  | 17  | 2   | 충돌    |
| 수영  | 7   | 4   |       |
해시 테이블의 기본 방식이기도 한 개별 체이닝은 충돌 발생 시, 연결 리스트로 연결하는 방식이다. 충돌이 발생한 '윤아'와 '서현'은 '윤아'의 다음 아이템이 '서현'인 형태로 서로 연결 리스트로 연결되었다. 이처럼 기본적인 자료구조와 임의로 정한 간단한 알고리즘만 있으면 되므로, 개별 체이닝 방식은 인기가 높다. 원래 해시 테이블 구조의 원형이기도 하며 가장 전통적인 방식으로, 흔히 해시 테이블이라고 하면 바로 이 방식을 말한다.
**간단한 원리 요약**
1. 키의 해시 값을 계산한다.
2. 해시 값을 이용해 배열의 인덱스를 구한다.
3. 같은 인덱스가 있다면 연결 리스트로 연결한다.
잘 구현한 경우 대부분의 탐색은 *O(1)* 이지만 최악의 경우, 즉 모든 해시 충돌이 발생했다고 가정할 경우에는 *O(n)* 이 된다. 자바 8에서는 연결 리스트 구조를 좀 더 최적화해서, 데이터의 개수가 많아지면 레드-블랙 트리에 저장하는 형태로 병행해 사용하기도 했다.

>오픈 어드레싱(Open Addressing)

오픈 어드레싱 방식은 충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식이다. 사실상 무한정 저장할 수 있는 체이닝 방식과 달리, 오픈 어드레싱 방식은 전체 슬롯의 개수 이상은 저장할 수 없다. 충돌이 일어나면 테이블 공간 내에서 탐사(Probing)를 통해 빈 공간을 찾아 해결하며, 이 때문에 개별 체이닝 방식과 달리, 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.
여러 가지 오픈 어드레싱 방식 중에서 가장 간단한 방식인 선형 탐사(Linear Probing)방식은 충돌이 발생할 경우 해당 위치부터 순차적으로 탐사를 하나씩 진행한다. 특정 위치가 선점되어 있으면 바로 그 다음 위치를 확인하는 식이다. 이렇게 탐사를 진행하다가 비어 있는 공간을 발견하면 삽입하게 된다. 선형 탐사 방식은 구현 방법이 간단하면서도, 의외로 전체적인 성능이 좋은 편이기도 하다.
선형 탐사의 한 가지 문제점은 해시 테이블에 저장되는 데이터들이 고르게 분포되지 않고 뭉치는 경향이 있다는 점이다. 해시 테이블 여기저기에 연속된 데이터 그룹이 생기는 이러한 현상을 클러스터링(Clustering)이라 하는데, 클러스터들이 점점 커지게 되면 인근 클러스터들과 서로 합쳐지는 일이 발생한다. 그렇게 되면 해시 테이블의 특정 위치에는 데이터가 몰리게 되고, 다른 위치에는 상대적으로 데이터가 거의 없는 상태가 될 수 있다. 이러한 클러스터링 현상은 탐사 시간을 오래 걸리게 하며, 전체적으로 해싱 효율을 떨어 뜨리는 원인이 된다.

오픈 어드레싱 방식은 버킷 사이즈보다 큰 경우 삽입할 수 없다. 따라서 기준이 되는 로드 팩터 비율을 넘어서게 되면, 그로스 팩터(Growth Factor)의 비율에 따라 더 큰 크기의 또 다른 버킷을 생성한 후 여기에 새롭게 복사하는 리해싱(Rehashing) 작업이 일어난다. 이는 동적 배열에서 공간이 가득 찰 경우, 더블링으로 새롭게 복사해서 옮겨가는 과정과 유사하다.

>언어별 해시 테이블 구현 방식

리스트와 함께 파이썬에서 가장 흔하게 쓰이는 자료형인 딕셔너리는 해시 테이블로 구현되어 있다. 파이썬의 해시 테이블은 충돌 시 오픈 어드레싱 방식으로 구현되어 있다. CPython 구현에는 다음과 같은 주석이 적혀 있다.
**`체이닝 시 malloc 으로 메모리를 할당하는 오버헤드가 높아 오픈 어드레싱을 택했다.`**
파이썬의 코어 개발에 관여했던 앤드큐 커클링은 파이썬이 체이닝을 사용하지 않는 이유를 설명한 바 있는데, 연결 리스트를 만들기 위해서는 추가 메모리 할당이 필요하고, 추가 메모리 할당은 상대적으로 느린 작업이기 때문에 택하지 않았다고 기술했다.
오픈 어드레싱의 한 방식인 선형 탐사 방식은 일반적으로 체이닝에 비해 성능이 더 좋다. 그러나 슬롯의 80% 이상이 차게 되면 급격한 성능 저하가 일어나며, 체이닝과 달리 전체 슬롯의 전체 개수 이상, 즉 로드 팩터 1 이상은 저장할 수 없다. 빈 공간을 탐사하는 선형 탐사 방식은 공간이 찰수록 탐사에 점점 더 오랜 시간이 걸리며, 가득 차게 될 경우 더 이상 빈 공간을 찾을 수 없기 때문이다. 따라서 최근의 루비나 파이썬 같은 모던(Modern) 언어들은 오픈 어드레싱 방식을 택해 성능을 높이는 대신, 로드 팩터를 작게 잡아 성능 저하 문제를 해결한다. 파이썬의 로드 팩터는 0.66으로 자바보다 작으며 루비는 0.5로 훨씬 더 작다.
*각 언어별 해시 테이블 구현*

| 언어                 | 방식      |
| ------------------ | ------- |
| C++(GCC libstdc++) | 개별 체이닝  |
| 자바                 | 개별 체이닝  |
| 고(Go)              | 개별 체이닝  |
| 루비                 | 오픈 어드레싱 |
| 파이썬                | 오픈 어드레싱 |

----
### 28. 해시맵 디자인 (리트코드 706)
>다음의 기능을 제공하는 해시맵을 디자인하라.
>- put(key, value): 키, 값을 해시맵에 삽입. 만약 이미 존재하는 키라면 업데이트.
>- get(key): 키에 해당하는 값을 조회. 만약 키가 존재하지 않는다면 -1 리턴.
>- remove(key): 키에 해당하는 키, 값을 해시맵에서 삭제.

- 1) 개별 체이닝 방식을 이용한 해시 테이블 구현
	- 초기화 메서드 구현
		- 기본 사이즈는 1,000개 정도로 적당히 설정하고, 각 ListNode를 담게 될 기본 자료형을 선언한다. 편리하게 구현하기 위해 존재하지 않는 키를 조회할 경우 자동으로 디폴트를 생성해주는 collections.defaultdict를 사용했다.
	- put() 구현
		- 편의상 모든 키를 정수형으로 지정했다. 따라서 size의 개수만큼 모듈로 연산을 한 나머지를 해시값으로 정하는 매우 단순한 형태로 처리한다. 이처럼 모듈로 연산을 통한 해싱은 해시 테이블의 가장 기본적인 해싱 방식이기도 하다. 이제 해싱한 결과인 index는 해시 테이블의 인덱스가 될 것이다.
		- 해당 인덱스에 아무것도 없다면 키, 값을 삽입하고 바로 종료한다. 여기서, `self.table[index] is None`으로 비교하지 않고 `self.table[index].value is None`으로 `value`의 존재 유무를 비교한 이유는 `self.table`이 `defaultdict` 이기 때문이다. `defaultdict`는 존재하지 않는 인덱스로 조회를 시도할 경우 에러를 발생하지 않고 바로 디폴트 객체를 생성한다. 여기서는 `defaultdict(ListNode)`로 선언했기 때문에 바로 빈 `ListNode`를 생성할 것이다.
		  `ListNode()` 클래스의 생성 함수 `__init__()`을 살펴보면, `key=None, value=None`을 초깃값으로 정했기 때문에, 각각이 `None`인 `ListNode`가 조회 즉시 생성될 것이다.
		- 해당 인덱스에 노드가 존재하는 경우, 즉, 해시 충돌(Hash Collision)이 발생한 경우인데, 개별 체이닝 방식으로 충돌을 해결한다. 즉 연결리스트로 이어나갈 것이다. p는 인덱스의 첫 번째 값이며 여기서부터 p.next를 계속 탐색한다. 종료 조건은 2가지 경우인데, 첫 번째는 이미 키가 존재할 경우 값을 업데이트하고 빠져나가는 경우고, 두 번째는 `p.next is None`이라면 아무것도 하지 않고 루프를 빠져나가는 경우다. 만약 후자를 처리하지 않는다면 `p = p.next`로 인해 `p`는 `None`이 되기 때문에 `p.next = ListNode(key, value)`에서 에러가 발생할 것이다.
		  에러 없이 정상적으로 진행되면 이 코드에서 `p.next`에 새 노드가 생성되면서 연결된다. 기존에 존재하지 않았던 키라면 맨 마지막에 새로운 노드가 연결될 것이다. 여기까지가 개별 체이닝 방식의 해시 테이블 삽입 원리다.
	- get() 구현
		- 모듈로 연산으로 인덱스를 결정하고, 해당 인덱스에 아무것도 없다면 `-1`을 리턴한다. 이 경우는 해당하는 노드는 물론, 아직 어떠한 키도 이 값으로 해싱되지 않은 경우다.
		- 해싱 결과에 하나 이상의 노드가 존재한다면, `p.next`로 탐색하면서 일치하는 키를 찾는다. 찾게 되면 값을 리턴하고, 찾지 못한다면 루프를 빠져나오면서 마찬가지로 `-1`을 리턴한다.
	- remove() 구현
		- 인덱스를 구한 다음 아무것도 없다면, 잘못된 키를 삭제 시도한 경우이므로 그냥 리턴한다. 값이 있을 때는 2가지 케이스로 나눠서 처리한다.
		- **1) 인덱스의 첫 번째 노드일 때 삭제 처리**
			- 인덱스의 첫 번째 노드일 때, `p.next is None`이라면 유일한 노드를 삭제하는 경우이므로 원래는 모두 없애야 한다. 그러나 여기서는 `ListNode()`로 빈 노드를 할당하게 했다. `self.table`은 `defaultdict(ListNode)`이기 때문에 매번 빈 노드를 생성하기 때문이다. 만약 여기서 `self.table[index] = None`을 할당한다면 앞서 추가, 조회 함수에서 `self.table[index].value is None`으로 비교를 시도할 때 에러가 발생할 것이다.
		- **2) 연결 리스트인 노드일 때 삭제 처리**
			- `prev`는 이전 노드, `p`는 현재 노드로, 계속 `p.next`로 탐색하다가 일치하는 노드를 찾게 되면, 이전 노드의 다음을 현재 노드의 다음으로 연결한다. 즉 현재 노드를 아무런 연결 고리가 없도록 끊어 버린다. 가만히 살펴보면 약간의 버그 가능성이 엿보인다. 만약 루프에 들어서자마자 일치하는 키를 발견하게 되면 `prev.next = p.next`가 동일한 부분이 될 것이다. 그러나 이런 경우는 발생하지 않는다. 왜냐하면 처음부터 일치하는 경우는 이미 1)에서 처리가 되기 때문이다. 따라서 여기서는 반드시 한 번 이상 반복한 후에야 일치하는 경우가 생길 것이다.
---
### 29. 보석과 돌
>J는 보석이며, S는 갖고 있는 돌이다. S에는 보석이 몇 개나 있을까? 대소문자는 구분한다.

###### 1. 해시 테이블을 이용한 풀이
이 문제는 갖고 있는 돌 S의 각각의 개수를 모두 헤아린 다음, J의 각 요소를 키로 하는 각 개수를 합산하면 풀이할 수 있다.
- 해시 테이블 생성
	- `freqs`라는 해시 테이블을 선언하나. 그리고 들의 모음인 S를 문자 단위로 하나씩 분리해 반복한다. 만약 처음 등장한 문자라면 1을 선언하고, 기존에 있던 문자라면 1을 더한다. 각 문자별 빈도 수가 저장된다. 이제 이 중에서 보석을 나타내는 J의 문자를 꺼내어 해당 문자의 빈도 수를 합하면 최종 결과가 된다.
###### 2. defaultdict를 이용한 비교 생략
default dict를 사용하면 코드 줄 수를 훨씬 더 줄일 수 있다. 키가 존재하는지 여부를 매번 판별할 필요가 없기 때문에 이처럼 바로 계산할 수 있고, 코드 수도 많이 줄어들어 깔끔해졌다.

###### 3. Counter로 계산 생략
Counter를 사용하면 코드를 더욱 짧게 줄일 수 있다. 각 개수를 계산하는 부분까지 자동으로 처리할 수 있기 때문이다. 아울러 Counter는 존재하지 않는 키의 경우 `KeyError`를 발생하는 게 아니라 `0`을 출력해 주기 때문에, `defaultdict`와 마찬가지로 에러에 대한 예외 처리를 할 필요가 없다. 단순히 J에 포함된 문자의 개수를 계산하기만 하면 된다.

###### 4. 파이썬다운 방식(리스트 컴프리헨션)
이 문제는 파이썬다운 방식(Pythonic Way)으로 단 한 줄로 계산할 수 있다.
```python
return sum(s in J for s in S)
```
리스트 컴프리헨션 작동 방식
```python
>>> [s for s in S]   #S = ['a', 'A', 'A', 'b', 'b']
`['a', 'A', 'A', 'b', 'b']`
```
이렇게 하면 각 문자를 하나씩 출력하는 리스트 컴프리헨션 이다.
```python
>>> [s in J for s in S]   #S = ['a', 'A', 'A', 'b', 'b'], J = ['a', 'A']
`[True, True, True, False, False]`
```
여기에 약간의 비교 구문을 추가해 `S`의 문자 `s`가 `J`에 포함되어 있는지 여부를 출력할 수 있다. `['a', 'A', 'A', 'b', 'b']`에서 첫 번째와 두 번째, 세 번째에 각각 `J`의 `a`와 `A`가 포함되어 있으므로 `True`, 나머지는 모두 `False`다. 이제 이 값을 다읍과 같이 `sum()`으로 합산한다.
```python
>>> sum([s in J for s in S])
3
```
결과는 `True`의 개수로, 3이 된다. 여기서 리스트 컴프리헨션을 의미하는 앞뒤의 대괄호 `[]`는 다음과 같이 제거할 수 있다.
```python
>>> sum(s in J for s in S)
3
```
위 4가지 풀이 방식은 실행속도가 동일하다.

| 풀이  | 방식                     | 실행 시간 | 코드 줄 수 |
| --- | ---------------------- | ----- | ------ |
| 1   | 해시 테이블을 이용한 풀이         | 32ms  | 14줄    |
| 2   | defaultdict를 이용한 비교 생략 | 28ms  | 10줄    |
| 3   | Counter로 계산 생략         | 32ms  | 7줄     |
| 4   | 파이썬다운 방식               | 28ms  | 1줄     |
