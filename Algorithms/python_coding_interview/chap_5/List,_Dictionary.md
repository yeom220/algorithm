## 리스트

>각 언어별 동적 배열 구현

| 언어  | 동적 배열       |
| --- | ----------- |
| 파이썬 | list()      |
| C++ | std::vector |
| 자바  | ArrayList   |

>리스트의 주요 연산 시간 복잡도

| 연산             | 시간 복잡도       | 설명                                                                                                         |
| -------------- | ------------ | ---------------------------------------------------------------------------------------------------------- |
| len(a)         | *O(1)*       | 전체 요소의 개수를 리턴한다.                                                                                           |
| a[i]           | *O(1)*       | 인덱스 i의 요소를 가져온다.                                                                                           |
| a[i:j]         | *O(k)*       | i 부터 j 까지 슬라이스의 길이만큼인 k 개의 요소를 가져온다. 이 경우 객체 k 개에 대한 조회가 필요하므로 *O(k)*이다.                                   |
| elem in a      | *O(n)*       | elem 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다.                                                           |
| a.count(elem)  | *O(n)*       | elem 요소의 개수를 리턴한다.                                                                                         |
| a.index(elem)  | *O(n)*       | elem 요소의 인덱스를 리턴한다.                                                                                        |
| a.append(elem) | *O(1)*       | 리스트 마지막에 elem 요소를 추가한다.                                                                                    |
| a.pop()        | *O(1)*       | 리스트 마지막 요소를 추출한다. 스택의 연산이다.                                                                                |
| a.pop(0)       | *O(n)*       | 리스트 첫번째 요소를 추출한다. 큐의 연산이다. 이 경우 전체 복사가 필요하므로 *O(n)*이다. 큐의 연산을 주로 사용한다면 리스트보다는 *O(1)*에 가능한 데크(deque)를 권장한다. |
| del a[i]       | *O(n)*       | i 에 따라 다르다. 최악의 경우 *O(n)*                                                                                  |
| a.sort()       | *O(n log n)* | 정렬한다. 팀소트(Timsort)를 사용하며, 최선의 경우 *O(n)*에도 실행될 수 있다.                                                        |
| min(a), max(a) | *O(n)*       | 최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다.                                                                         |
| a.reverse()    | *O(n)*       | 뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.                                                              |
- 리스트의 경우 탐색 시 값의 존재 유무를 확인하려면 정렬된 경우에는 **이전 검색**이 효율적이다. 그러나 매번 정렬이 필요하고 대개는 리스트가 정렬된 상태가 아니기 때문에, 리스트의 경우에는 모든 엘리먼트를 순차적으로 조회하는 형태로 구현되어 있다. 최악의 경우 *O(n)*

##### 리스트 활용 방법
```python
# 리스트 선언 방법들
a = list()
a = []
a = [1, 2, 3]
a.append(4) # 4 추가
> [1, 2, 3, 4]

# 특정 인덱스 삽입
a.insert(3,5)
> [1, 2, 3, 5, 4]

# 다양한 자료형을 단일 리스트에 관리할 수 있다.
a.append('안녕')
a.append(True)
a
> [1, 2, 3, 5, 4, '안녕', True]

# 값 조회
a[3]
> 5

# 슬라이싱 (특정 범위 내의 값을 리턴)
a[1:3]
> [2, 3]
a[:3] # 시작 인덱스 생략
> [1, 2, 3]
a[4:] # 종료 인덱스 생략
> [4, '안녕', True]
# 인덱스 1, 2, 3의 값
a[1:4]
> [2, 3, 5]
# 3번째 파라미터는 단계(step)의 의미로 지정 숫자만큼 건너뜀
a[1:4:2] # 인덱스 1, 3의 값
> [2, 5]

# 예외 처리
try:
	print(a[9])
except IndexError:
	print('존재하지 않는 인덱스')
> 존재하지 않는 인덱스

a
> [1, 2, 3, 5, 4, '안녕', True]
# 특정 인덱스 요소 삭제
del a[1]
> [1, 3, 5, 4, '안녕', True]
# 특정 값 요소 삭제
a.remove(3)
> [1, 5, 4, '안녕', True]
# 요소 추출
a.pop(3)
> '안녕'
a
> [1, 5, 4, True]
```
##### 리스트의 특징
- 파이썬은 모든 것이 객체며, 리스트는 이들 객체에 대한 포인터 목록을 관리하는 형태로 구현되어 있다.
- 리스트는 연결 리스트에 대한 포인터 목록을 관리하고 있기 때문에 정수, 문자, 불리언 등 제각기 다양한 타입을 동시에 단일 리스트에서 관리하는 게 가능하다.
- 각 자료형의 크기는 저마다 다르기 때문에 연속된 메모리 공간에 할당하는 것은 불가능하다. 결국 각각의 객체에 대한 참조로 구현할 수 밖에 없다. 당연히 인덱스를 조회하는 데에도 모든 포인터의 위치를 찾아가서 타입 코드를 확인하고 값을 일일이 살펴봐야 하는 등 추가적인 작업이 필요하기 때문에, 속도 면에서도 훨씬 더 불리하다.

## 딕셔너리

>각 언어별 해시 테이블 구현

| 언어  | 해시테이블              |
| --- | ------------------ |
| 파이썬 | dict()             |
| C++ | std::unordered_map |
| 자바  | HashMap            |
- 딕셔너리는 숫자, 문자, 집합까지 불변 객체를 모두 키로 사용 가능하다. (해싱)
- 해시 테이블을 이용해 자료를 저장한다.
- 입력과 조회 모두 *O(1)* 이다.
- 해시 테이블은 최악의 경우 *O(n)* 이 될수 있으나 분할 상환 분석에 따른 시간 복잡도는 *O(1)* 이다.
>딕셔너리의 주요 연산 시간 복잡도

| 연산             | 시간 복잡도 | 설명                   |
| -------------- | ------ | -------------------- |
| len(a)         | *O(1)* | 요소의 개수를 리턴한다.        |
| a[key]         | *O(1)* | 키를 조회하여 값을 리턴한다.     |
| a[key] = value | *O(1)* | 키/값을 삽입한다.           |
| key in a       | *O(1)* | 딕셔너리에 키가 존재하는지 확인한다. |
- 기존 딕셔너리는 입력 순서가 유지되지 않았지만 3.7이후로 인덱스가 추가되어 순서가 유지된다.
- 파이썬 3.7+: 딕셔너리 입력 순서 유지
- 파이썬 3.6+: 딕셔너리 메모리 사용량 20% 감소
##### 딕셔너리의 활용 방법
```python
# 딕셔너리는 다음과 같이 선언할 수 있다.
a = dict()
a = {}
a = {'key1':'vailue1', 'key2':'value2'}
a
> {'key1':'vailue1', 'key2':'value2'}
a['key3'] = 'value3'
> {'key1':'vailue1', 'key2':'value2', 'key3':'value3'}
a['key1']
> 'value1'
# 예외 처리
try:
	print(a['key4'])
except KeyError:
	print('존재하지 않는 키')

# 키 확인
'key4' in a
> False

if 'key4' in a :
	print('존재하는 키')
else:
	print('존재하지 않는 키')
> 존재하지 않는 키

# 딕셔너리 반복문
for k, v in a.items():
	print(k, v)
> key1 value1
> key2 value2
> key3 value3

# 키 삭제
del a['key1']
> {'key2':'vailue2', 'key3':'value3'}
```
##### 딕셔너리 모듈
- defaultdict 객체
	- 존재하지 않는 키를 조회할 경우 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다.
```python
a = collections.defaultdict(int)
a['A'] = 5
a['B'] = 4
a
> defaultdict(<class 'int'>, {'A':5, 'B':4})

# C는 없는 키지만 디폴트인 0으로 자동 생성한 후 1을 더했다.
a['C'] += 1
a
> defaultdict(<class 'int'>, {'A':5, 'B':4, 'C':1})
```
- Counter 객체
	- 아이템에 대한 개수를 계산해 딕셔너리로 리턴한다.
	- 키에는 아이템의 값이, 값에는 해당 아이템의 개수가 들어간다.
	- 딕셔너리를 한번 더 래핑(Wrapping)한 collections.Counter 클래스를 갖는다.
```python
a = [1, 2, 3, 4, 5, 5, 5, 6, 6]
b = collections.Counter(a)
b
> Counter({5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1}) # 키에 값, 값에 개수가 들어간 딕셔너리
# 실제 타입은 딕셔너리를 래핑한 Counter 클래스
type(b)
> <class 'collections.Counter'>

# 가장 빈도 수 높은 수 추출
b.most_common(2)
> [(5, 3), (6, 2)]
```
- OrderedDict 객체
	- 대부분의 언어에서 해시 테이블을 이용한 자료형은 입력 순서가 유지되지 않는다. 파이썬도 3.6 이하에서는 마찬가지였고 입력 순서가 유지되는 OrderedDict 객체를 제공했다.
	- 파이썬 3.7부터 딕셔너리는 내부적으로 인덱스를 이용하며 입력 순서가 유지되도록 개선됐다.
```python
collections.OrderedDict({'banana':3, 'apple':4, 'pear':1, 'orange':2})
> OrderedDict(p[('banana', 3), ('apple', 4), ('pear', 1), ('orange', 2)])
```
##### 타입 선언
- 파이썬에서 타입을 선언하는 문법은 타입의 이름을 지정하는 방법이 있지만, 기호를 사용해서 간편하게 처리할 수도 있다.
- 이름으로 선언하는 방식
```python
a = list()
type(a)
> <class 'list'>

# 리스트
type([])
> <class 'list'>
# 튜플
type(())
> <class 'tuple'>
# 딕셔너리
type({})
> <class 'dict'>
# 집합
type({1})
> <class 'set'>
```

