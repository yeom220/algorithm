### 프론트 컨트롤러 패턴 소개
- 프론트 컨트롤러 도입 전
	- 각각의 Path마다 서블릿이 있어야 함(공통(중복) 로직 생김)
- 프론트 컨트롤러 도입 후
	- 모든 요청을 프론트 컨트롤러에서 받아서 각각 역할에 맞는 컨트롤러로 전달함
	- 공통 로직을 프론트 컨트롤러에서 처리하여 중복 로직 문제를 해결할 수 있음
- **FrontController 패턴 특징**
	- 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음
	- 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출
	- 입구를 하나로
	- 공통 처리 가능
	- 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨
- **스프링 웹 MVC와 프론트 컨트롤러
	- 스프링 웹 MVC의 핵심도 프론트 컨트롤러
	- 스프링 웹 MVC의 **DispatcherServlet**이 프론트 컨트롤러 패턴으로 구현되어 있다.

### 프론트 컨트롤러 도입 - v1
- v1 구조
	- 1. URL 매핑 정보에서 컨트롤러 조회
	- 2. 컨트롤러 호출
	- 3. 컨트롤러에서 JSP forward
	- 4. HTML 응답
- ControllerV1 인터페이스 작성
	- 서블릿과 비슷한 모양의 컨트롤러 인터페이스를 도입한다. 각 컨트롤러들은 이 인터페이스를 구현하면 된다. 프론트 컨트롤러는 이 인터페이스를 호출해서 구현과 관계없이 로직의 일관성을 가져갈 수 있다.
- MemberFormControllerV1 - 회원 등록 컨트롤러 작성
- MemberSaveControllerV1 - 회원 저장 컨트롤러 작성
- MemberListControllerV1 - 회원 목록 컨트롤러 작성
- FrontControllerServletV1 - 프론트 컨트롤러 작성
	- **urlPatterns**
		- `urlPatterns = "/front-controller/v1/*`: `/front-controller/v1`을 포함한 하위 모든 요청은 이 서블릿에서 받아들인다.
	- **controllerMap**
		- key: 매핑 URL
		- value: 호출된 컨트롤러
	- **service()**
		- `requestURI`를 조회해서 실제 호출할 컨트롤러를 `comtrollerMap`에서 찾는다. 만약 없다면 404 상태 코드를 반환한다.
		- 컨트롤러를 찾고 `controller.process(request, response);`을 호출해서 해당 컨트롤러를 실행한다.
	- **JSP**
		- JSP는 이전 MVC에서 사용했던 것을 그대로 사용한다.

### View 분리 - v2
- 모든 컨트롤러에서 뷰로 이동하는 부분에 중복이 있고, 깔끔하지 않다.
- 이 부분을 깔끔하게 분리하기 위해 별도로 뷰를 처리하는 객체를 만든다.
- v2 구조
	- 1. URL 매핑 정보에서 컨트롤러 조회
	- 2. 컨트롤러 호출
	- 3. MyView 반환
	- 4. render() 호출
	- 5. JSP forward
- **MyView** 작성
- ControllerV2 인터페이스 작성
- MemberFormControllerV2 - 회원 등록 폼 작성
	- 각 컨트롤러는 복잡한 `dispatcher.forward()`를 직접 생성해서 호출하지 않아도 된다. 단순히 MyView 객체를 생성하고 거기에 뷰 이름만 넣고 반환하면 된다.
- MemberSaveControllerV2 - 회원 저장 작성
- MemberListControllerV2 - 회원 목록 작성
- FrontControllerServletV2 작성
	- ControllerV2의 반환 타입이 `MyView`이므로 프론트 컨트롤러는 컨트롤러의 호출 결과로 `MyView`를 반환 받는다. 그리고 `view.render()`를 호출하면 `forward` 로직을 수행해서 JSP가 실행된다.
	- 프론트 컨트롤러의 도입으로 `MyView` 객체의 `render()`를 호출하는 부분을 모두 일관되게 처리할 수 있다. 각각의 컨트롤러는 `MyView` 객체를 생성만 해서 반환하면 된다.

### Model 추가 - v3
