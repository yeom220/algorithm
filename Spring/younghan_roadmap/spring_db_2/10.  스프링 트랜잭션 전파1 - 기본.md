### 스프링 트랜잭션 전파1 - 커밋, 롤백
트랜잭션이 둘 이상 있을 때 어떻게 동작하는지 자세히 알아보고, 스프링이 제공하는 트랜잭션 전파(propagation)라는 개념도 알아본다.
트랜잭션 전파를 이해하는 과정을 통해서 스프링 트랜잭션의 동작 원리도 더 깊이있게 이해할 수 있을 것이다.

**BasicTxTest**
- `@TestConfiguration`: 해당 테스트에서 필요한 스프링 설정을 추가로 할 수 있다.
- `DataSourceTransactionManager`를 스프링 빈으로 등록했다. 이후 트랜잭션 매니저인 `PlatformTransactionManager`를 주입 받으면 방금 등록한 `DataSourceTransactionManager`가 주입된다.

**commit()**
`txManager.getTransaction(new DefaultTransactionAttribute())`
트랜잭션 매니저를 통해 트랜잭션을 시작(획득)한다.

`txManager.commit(status)`
트랜잭션을 커밋한다.

**commit() - 실행 로그**

**rollback()**
`txManager.getTransaction(new DefaultTransactionAttribute())`
트랜잭션 매니저를 통해 트랜잭션을 시작(획득)한다.

`txManager.rollback(status)`
트랜잭션을 롤백한다.

**rollback() - 실행 로그**

이미 앞서 학습한 내용들이어서 이해하기는 어렵지 않을 것이다. 다음에는 트랜잭션을 하나 더 추가해본다.


### 스프링 트랜잭션 전파2 - 트랜잭션 두 번 사용
이번에는 트랜잭션이 각각 따로 사용되는 경우를 확인해본다.
이 예제는 트랜잭션1이 완전히 끝나고나서 트랜잭션2를 수행한다.

**double_commit() - BasicTxTest 추가**

**double_commit() - 실행로그**


**트랜잭션1**
- `Acquired Connection [HikariProxyConnection@1064414847 wrapping conn0] for JDBC transaction`
	- 트랜잭션1을 시작하고, 커넥션 풀에서 `conn0` 커넥션을 획득했다.
- `Releasing JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] after transaction`
	- 트랜잭션1을 커밋하고, 커넥션 풀에 `conn0` 커넥션을 반납했다.

**트랜잭션2**
- `Acquired Connection [HikariProxyConnection@ 778350106 wrapping conn0] for JDBC transaction`
	- 트랜잭션2를 시작하고, 커넥션 풀에서 `conn0` 커넥션을 획득했다.
- `Releasing JDBC Connection [HikariProxyConnection@ 778350106 wrapping conn0] after transaction`
	- 트랜잭션2를 커밋하고, 커넥션 풀에 `conn0` 커넥션을 반납했다.

**주의!**
로그를 보면 트랜잭션1과 트랜잭션2가 같은 `conn0` 커넥션을 사용중이다. 이것은 중간에 커넥션 풀 때문에 그런 것이다. 트랜잭션1은 `conn0` 커넥션을 모두 사용하고 커넥션 풀에 반납까지 완료했다. 이후에 트랜잭션2가 `conn0`를 커넥션 풀에서 획득한 것이다. 따라서 둘은 완전히 다른 커넥션으로 인지하는 것이 맞다.
그렇다면 둘을 구분할 수 있는 다른 방법은 없을까?
히카리 커넥션 풀에서 커넥션을 획득하면 실제 커넥션을 그대로 반환하는 것이 아니라 내부 관리를 위해 히카리 프록시 커넥션이라는 객체를 생성해서 반환한다. 물론 내부에는 실제 커넥션이 포함되어 있다. 이 객체의 주소를 확인하면 커넥션 풀에서 획득한 커넥션을 구분할 수 있다.
- 트랜잭션1: `Acquired Connection [HikariProxyConnection@1000000 wrapping conn0]`
- 트랜잭션2: `Acquired Connection [HikariProxyConnection@2000000 wrapping conn0]`

히카리 커넥션풀이 반환해주는 커넥션을 다루는 프록시 객체의 주소가 트랜잭션 1은 `HikariProxyConnection@1000000`이고, 트랜잭션2는 `HikariProxyConnection@2000000`으로 서로 다른 것을 확인할 수 있다.
결과적으로 `conn0`을 통해 커넥션이 재사용 된 것을 확인할 수 있고, `HikariProxyConnection@1000000`, `HikariProxyConnection@2000000`을 통해 각각 커넥션 풀에서 커넥션을 조회한 것을 확인할 수 있다.

- 트랜잭션이 각각 수행되면서 사용되는 DB 커넥션도 각각 다르다.
- 이 경우 트랜잭션을 각자 관리하기 때문에 전체 트랜잭션을 묶을 수 없다. 예를 들어서 트랜잭션1이 커밋하고, 트랜잭션2가 롤백하는 경우 트랜잭션1에서 저장한 데이터는 커밋되고, 트랜잭션2에서 저장한 데이터는 롤백된다.

**double_commit_rollback() - BasicTxTest 추가**
- 트랜잭션1은 커밋하고, 트랜잭션2는 롤백한다.
- 전체 트랜잭션을 묶지 않고 각각 관리했기 때문에, 트랜잭션1에서 저장한 데이터는 커밋되고, 트랜잭션2에서 저장한 데이터는 롤백된다.

**double_commit_rollback() - 실행로그**
- 로그를 보면 트랜잭션1은 커밋되지만, 트랜잭션2는 롤백되는 것을 확인할 수 있다.



### 스프링 트랜잭션 전파3 - 전파 기본
트랜잭션을 각각 사용하는 것이 아니라, 트랜잭션이 이미 진행중인데, 여기에 추가로 트랜잭션을 수행하면 어떻게 될까?
기존 트랜잭션과 별도의 트랜잭션을 진행해야 할까? 아니면 기존 트랜잭션을 그대로 이어 받아서 트랜잭션을 수행해야 할까?
이런 경우 어떻게 동작할지 결정하는 것을 트랜잭션 전파(propagation)라 한다.
참고로 스프링은 다양한 트랜잭션 전파 옵션을 제공한다.

>**참고**
>지금부터 설명하는 내용은 트랜잭션 전파의 기본 옵션인 `REQUIRED`를 기준으로 설명한다.

**외부 트랜잭션이 수행중인데, 내부 트랜잭션이 추가로 수행됨**
- **클라이언트 -> 로직1(외부 트랜잭션) -> 로직2(내부 트랜잭션)**
	- 외부 트랜잭션이 수행중이고, 아직 끝나지 않았는데, 내부 트랜잭션이 수행된다.
	- 외부 트랜잭션이라고 이름 붙인 것은 둘 중 상대적으로 밖에 있기 때문에 외부 트랜잭션이라 한다. 처음 시작된 트랜잭션으로 이해하면 된다.
	- 내부 트랜잭션은 외부에 트랜잭션이 수행되고 있는 도중에 호출되기 때문에 마치 내부에 있는 것처럼 보여서 내부 트랜잭션이라 한다.
- 스프링에서 이 경우 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션을 만들어 준다. 내부 트랜잭션이 외부 트랜잭션에 참여하는 것이다. 이것이 기본 동작이고, 옵션을 통해 다른 동작방식도 선택할 수 있다.

**물리 트랜잭션, 논리 트랜잭션**
- **클라이언트 -> \[로직1(논리 트랜잭션) -> 로직2(논리 트랜잭션)](하나의 물리 트랜잭션)**
	- 스프링은 이해를 돕기 위해 논리 트랜잭션과 물리 트랜잭션이라는 개념을 나눈다.
	- 논리 트랜잭션들은 하나의 물리 트랜잭션으로 묶인다.
	- 물리 트랜잭션은 우리가 이해하는 실제 데이터베이스에 적용되는 트랜잭션을 뜻한다. 실제 커넥션을 통해서 트랜잭션을 시작(`setAutoCommit(false)`)하고, 실제 커넥션을 통해서 커밋, 롤백하는 단위이다.
	- 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위이다.
	- 이러한 논리 트랜잭션 개념은 트랜잭션이 진행되는 중에 내부에 추가로 트랜잭션을 사용하는 경우에 나타난다. 단순히 트랜잭션이 하나인 경우 둘을 구분하지는 않는다. (더 정확히는 `REQUIRED` 전파 옵션을 사용하는 경우에 나타나고, 이 옵션은 뒤에서 설명한다.)

그럼 왜 이렇게 논리 트랜잭션과 물리 트랜잭션을 나누어 설명하는 것일까?
트랜잭션이 사용중일 때 또 다른 트랜잭션이 내부에 사용되면 여러가지 복잡한 상황이 발생한다. 이때 논리 트랜잭션 개념을 도입하면 다음과 같은 단순한 원칙을 만들 수 있다.

**원칙**
- **모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.**
- **하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.**

모든 트랜잭션 매니저를 커밋해야 물리 트랜잭션이 커밋된다. 하나의 트랜잭션 매니저라도 롤백하면 물리 트랜잭션은 롤백된다.

- **클라이언트 -> \[로직1(외부 커밋) -> 로직2(내부 커밋)](전체 커밋)**
	- 모든 논리 트랜잭션이 커밋 되었으므로 물리 트랜잭션도 커밋된다.
- **클라이언트 -> \[로직1(외부 롤백) -> 로직2(내부 커밋)](전체 롤백)**
	- 외부 논리 트랜잭션이 롤백 되었으므로 물리 트랜잭션은 롤백된다.
- **클라이언트 -> \[로직1(외부 커밋) -> 로직2(내부 롤백)](전체 롤백)**
	- 내부 논리 트랜잭션이 롤백 되었으므로 물리 트랜잭션은 롤백된다.


### 스프링 트랜잭션 전파4 - 전파 예제
